module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type ActiveSubscriptions {
  id: ID!
  user: User!
  subscription: UserRole!
  startDate: DateTime!
  endDate: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ActiveSubscriptionsConnection {
  pageInfo: PageInfo!
  edges: [ActiveSubscriptionsEdge]!
  aggregate: AggregateActiveSubscriptions!
}

input ActiveSubscriptionsCreateInput {
  id: ID
  user: UserCreateOneInput!
  subscription: UserRoleCreateOneInput!
  startDate: DateTime!
  endDate: DateTime!
}

type ActiveSubscriptionsEdge {
  node: ActiveSubscriptions!
  cursor: String!
}

enum ActiveSubscriptionsOrderByInput {
  id_ASC
  id_DESC
  startDate_ASC
  startDate_DESC
  endDate_ASC
  endDate_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ActiveSubscriptionsPreviousValues {
  id: ID!
  startDate: DateTime!
  endDate: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ActiveSubscriptionsSubscriptionPayload {
  mutation: MutationType!
  node: ActiveSubscriptions
  updatedFields: [String!]
  previousValues: ActiveSubscriptionsPreviousValues
}

input ActiveSubscriptionsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ActiveSubscriptionsWhereInput
  AND: [ActiveSubscriptionsSubscriptionWhereInput!]
  OR: [ActiveSubscriptionsSubscriptionWhereInput!]
  NOT: [ActiveSubscriptionsSubscriptionWhereInput!]
}

input ActiveSubscriptionsUpdateInput {
  user: UserUpdateOneRequiredInput
  subscription: UserRoleUpdateOneRequiredInput
  startDate: DateTime
  endDate: DateTime
}

input ActiveSubscriptionsUpdateManyMutationInput {
  startDate: DateTime
  endDate: DateTime
}

input ActiveSubscriptionsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  subscription: UserRoleWhereInput
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ActiveSubscriptionsWhereInput!]
  OR: [ActiveSubscriptionsWhereInput!]
  NOT: [ActiveSubscriptionsWhereInput!]
}

input ActiveSubscriptionsWhereUniqueInput {
  id: ID
}

type AggregateActiveSubscriptions {
  count: Int!
}

type AggregateAwayTeamFixture {
  count: Int!
}

type AggregateCountry {
  count: Int!
}

type AggregateFandemSubscription {
  count: Int!
}

type AggregateFixture {
  count: Int!
}

type AggregateFollower {
  count: Int!
}

type AggregateGameweek {
  count: Int!
}

type AggregateHomeTeamFixture {
  count: Int!
}

type AggregateInfluencer {
  count: Int!
}

type AggregatePhoto {
  count: Int!
}

type AggregateSeason {
  count: Int!
}

type AggregateStatus {
  count: Int!
}

type AggregateTeam {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateUserAssignedRole {
  count: Int!
}

type AggregateUserFollowers {
  count: Int!
}

type AggregateUserInfluencers {
  count: Int!
}

type AggregateUserPhoto {
  count: Int!
}

type AggregateUserRole {
  count: Int!
}

type AggregateUserStatus {
  count: Int!
}

type AwayTeamFixture {
  id: ID!
  fixture: Fixture!
  awayTeam: Team!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AwayTeamFixtureConnection {
  pageInfo: PageInfo!
  edges: [AwayTeamFixtureEdge]!
  aggregate: AggregateAwayTeamFixture!
}

input AwayTeamFixtureCreateInput {
  id: ID
  fixture: FixtureCreateOneWithoutTeamAInput!
  awayTeam: TeamCreateOneWithoutAwayFixturesInput!
}

input AwayTeamFixtureCreateManyWithoutAwayTeamInput {
  create: [AwayTeamFixtureCreateWithoutAwayTeamInput!]
  connect: [AwayTeamFixtureWhereUniqueInput!]
}

input AwayTeamFixtureCreateOneWithoutFixtureInput {
  create: AwayTeamFixtureCreateWithoutFixtureInput
  connect: AwayTeamFixtureWhereUniqueInput
}

input AwayTeamFixtureCreateWithoutAwayTeamInput {
  id: ID
  fixture: FixtureCreateOneWithoutTeamAInput!
}

input AwayTeamFixtureCreateWithoutFixtureInput {
  id: ID
  awayTeam: TeamCreateOneWithoutAwayFixturesInput!
}

type AwayTeamFixtureEdge {
  node: AwayTeamFixture!
  cursor: String!
}

enum AwayTeamFixtureOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AwayTeamFixturePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AwayTeamFixtureScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AwayTeamFixtureScalarWhereInput!]
  OR: [AwayTeamFixtureScalarWhereInput!]
  NOT: [AwayTeamFixtureScalarWhereInput!]
}

type AwayTeamFixtureSubscriptionPayload {
  mutation: MutationType!
  node: AwayTeamFixture
  updatedFields: [String!]
  previousValues: AwayTeamFixturePreviousValues
}

input AwayTeamFixtureSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AwayTeamFixtureWhereInput
  AND: [AwayTeamFixtureSubscriptionWhereInput!]
  OR: [AwayTeamFixtureSubscriptionWhereInput!]
  NOT: [AwayTeamFixtureSubscriptionWhereInput!]
}

input AwayTeamFixtureUpdateInput {
  fixture: FixtureUpdateOneRequiredWithoutTeamAInput
  awayTeam: TeamUpdateOneRequiredWithoutAwayFixturesInput
}

input AwayTeamFixtureUpdateManyWithoutAwayTeamInput {
  create: [AwayTeamFixtureCreateWithoutAwayTeamInput!]
  delete: [AwayTeamFixtureWhereUniqueInput!]
  connect: [AwayTeamFixtureWhereUniqueInput!]
  set: [AwayTeamFixtureWhereUniqueInput!]
  disconnect: [AwayTeamFixtureWhereUniqueInput!]
  update: [AwayTeamFixtureUpdateWithWhereUniqueWithoutAwayTeamInput!]
  upsert: [AwayTeamFixtureUpsertWithWhereUniqueWithoutAwayTeamInput!]
  deleteMany: [AwayTeamFixtureScalarWhereInput!]
}

input AwayTeamFixtureUpdateOneRequiredWithoutFixtureInput {
  create: AwayTeamFixtureCreateWithoutFixtureInput
  update: AwayTeamFixtureUpdateWithoutFixtureDataInput
  upsert: AwayTeamFixtureUpsertWithoutFixtureInput
  connect: AwayTeamFixtureWhereUniqueInput
}

input AwayTeamFixtureUpdateWithoutAwayTeamDataInput {
  fixture: FixtureUpdateOneRequiredWithoutTeamAInput
}

input AwayTeamFixtureUpdateWithoutFixtureDataInput {
  awayTeam: TeamUpdateOneRequiredWithoutAwayFixturesInput
}

input AwayTeamFixtureUpdateWithWhereUniqueWithoutAwayTeamInput {
  where: AwayTeamFixtureWhereUniqueInput!
  data: AwayTeamFixtureUpdateWithoutAwayTeamDataInput!
}

input AwayTeamFixtureUpsertWithoutFixtureInput {
  update: AwayTeamFixtureUpdateWithoutFixtureDataInput!
  create: AwayTeamFixtureCreateWithoutFixtureInput!
}

input AwayTeamFixtureUpsertWithWhereUniqueWithoutAwayTeamInput {
  where: AwayTeamFixtureWhereUniqueInput!
  update: AwayTeamFixtureUpdateWithoutAwayTeamDataInput!
  create: AwayTeamFixtureCreateWithoutAwayTeamInput!
}

input AwayTeamFixtureWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fixture: FixtureWhereInput
  awayTeam: TeamWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AwayTeamFixtureWhereInput!]
  OR: [AwayTeamFixtureWhereInput!]
  NOT: [AwayTeamFixtureWhereInput!]
}

input AwayTeamFixtureWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Country {
  id: ID!
  iso: String!
  name: String!
  code: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CountryConnection {
  pageInfo: PageInfo!
  edges: [CountryEdge]!
  aggregate: AggregateCountry!
}

input CountryCreateInput {
  id: ID
  iso: String!
  name: String!
  code: String!
}

input CountryCreateOneInput {
  create: CountryCreateInput
  connect: CountryWhereUniqueInput
}

type CountryEdge {
  node: Country!
  cursor: String!
}

enum CountryOrderByInput {
  id_ASC
  id_DESC
  iso_ASC
  iso_DESC
  name_ASC
  name_DESC
  code_ASC
  code_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CountryPreviousValues {
  id: ID!
  iso: String!
  name: String!
  code: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CountrySubscriptionPayload {
  mutation: MutationType!
  node: Country
  updatedFields: [String!]
  previousValues: CountryPreviousValues
}

input CountrySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CountryWhereInput
  AND: [CountrySubscriptionWhereInput!]
  OR: [CountrySubscriptionWhereInput!]
  NOT: [CountrySubscriptionWhereInput!]
}

input CountryUpdateDataInput {
  iso: String
  name: String
  code: String
}

input CountryUpdateInput {
  iso: String
  name: String
  code: String
}

input CountryUpdateManyMutationInput {
  iso: String
  name: String
  code: String
}

input CountryUpdateOneInput {
  create: CountryCreateInput
  update: CountryUpdateDataInput
  upsert: CountryUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CountryWhereUniqueInput
}

input CountryUpsertNestedInput {
  update: CountryUpdateDataInput!
  create: CountryCreateInput!
}

input CountryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  iso: String
  iso_not: String
  iso_in: [String!]
  iso_not_in: [String!]
  iso_lt: String
  iso_lte: String
  iso_gt: String
  iso_gte: String
  iso_contains: String
  iso_not_contains: String
  iso_starts_with: String
  iso_not_starts_with: String
  iso_ends_with: String
  iso_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CountryWhereInput!]
  OR: [CountryWhereInput!]
  NOT: [CountryWhereInput!]
}

input CountryWhereUniqueInput {
  id: ID
}

scalar DateTime

type FandemSubscription {
  id: ID!
  name: String!
  description: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FandemSubscriptionConnection {
  pageInfo: PageInfo!
  edges: [FandemSubscriptionEdge]!
  aggregate: AggregateFandemSubscription!
}

input FandemSubscriptionCreateInput {
  id: ID
  name: String!
  description: String!
}

input FandemSubscriptionCreateManyInput {
  create: [FandemSubscriptionCreateInput!]
  connect: [FandemSubscriptionWhereUniqueInput!]
}

type FandemSubscriptionEdge {
  node: FandemSubscription!
  cursor: String!
}

enum FandemSubscriptionOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FandemSubscriptionPreviousValues {
  id: ID!
  name: String!
  description: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input FandemSubscriptionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FandemSubscriptionScalarWhereInput!]
  OR: [FandemSubscriptionScalarWhereInput!]
  NOT: [FandemSubscriptionScalarWhereInput!]
}

type FandemSubscriptionSubscriptionPayload {
  mutation: MutationType!
  node: FandemSubscription
  updatedFields: [String!]
  previousValues: FandemSubscriptionPreviousValues
}

input FandemSubscriptionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FandemSubscriptionWhereInput
  AND: [FandemSubscriptionSubscriptionWhereInput!]
  OR: [FandemSubscriptionSubscriptionWhereInput!]
  NOT: [FandemSubscriptionSubscriptionWhereInput!]
}

input FandemSubscriptionUpdateDataInput {
  name: String
  description: String
}

input FandemSubscriptionUpdateInput {
  name: String
  description: String
}

input FandemSubscriptionUpdateManyDataInput {
  name: String
  description: String
}

input FandemSubscriptionUpdateManyInput {
  create: [FandemSubscriptionCreateInput!]
  update: [FandemSubscriptionUpdateWithWhereUniqueNestedInput!]
  upsert: [FandemSubscriptionUpsertWithWhereUniqueNestedInput!]
  delete: [FandemSubscriptionWhereUniqueInput!]
  connect: [FandemSubscriptionWhereUniqueInput!]
  set: [FandemSubscriptionWhereUniqueInput!]
  disconnect: [FandemSubscriptionWhereUniqueInput!]
  deleteMany: [FandemSubscriptionScalarWhereInput!]
  updateMany: [FandemSubscriptionUpdateManyWithWhereNestedInput!]
}

input FandemSubscriptionUpdateManyMutationInput {
  name: String
  description: String
}

input FandemSubscriptionUpdateManyWithWhereNestedInput {
  where: FandemSubscriptionScalarWhereInput!
  data: FandemSubscriptionUpdateManyDataInput!
}

input FandemSubscriptionUpdateWithWhereUniqueNestedInput {
  where: FandemSubscriptionWhereUniqueInput!
  data: FandemSubscriptionUpdateDataInput!
}

input FandemSubscriptionUpsertWithWhereUniqueNestedInput {
  where: FandemSubscriptionWhereUniqueInput!
  update: FandemSubscriptionUpdateDataInput!
  create: FandemSubscriptionCreateInput!
}

input FandemSubscriptionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FandemSubscriptionWhereInput!]
  OR: [FandemSubscriptionWhereInput!]
  NOT: [FandemSubscriptionWhereInput!]
}

input FandemSubscriptionWhereUniqueInput {
  id: ID
}

type Fixture {
  id: ID!
  fplCode: Int!
  event: Gameweek!
  finished: Boolean!
  finishedProvisional: Boolean!
  fixtureId: Int!
  kickoffTime: DateTime
  minutes: Int!
  provisionalStartTime: Boolean!
  started: Boolean!
  teamA: AwayTeamFixture!
  teamADifficulty: Int!
  teamAScore: Int
  teamH: HomeTeamFixture!
  teamHDifficulty: Int!
  teamHScore: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FixtureConnection {
  pageInfo: PageInfo!
  edges: [FixtureEdge]!
  aggregate: AggregateFixture!
}

input FixtureCreateInput {
  id: ID
  fplCode: Int!
  event: GameweekCreateOneInput!
  finished: Boolean!
  finishedProvisional: Boolean!
  fixtureId: Int!
  kickoffTime: DateTime
  minutes: Int!
  provisionalStartTime: Boolean!
  started: Boolean!
  teamA: AwayTeamFixtureCreateOneWithoutFixtureInput!
  teamADifficulty: Int!
  teamAScore: Int
  teamH: HomeTeamFixtureCreateOneWithoutFixtureInput!
  teamHDifficulty: Int!
  teamHScore: Int
}

input FixtureCreateOneWithoutTeamAInput {
  create: FixtureCreateWithoutTeamAInput
  connect: FixtureWhereUniqueInput
}

input FixtureCreateOneWithoutTeamHInput {
  create: FixtureCreateWithoutTeamHInput
  connect: FixtureWhereUniqueInput
}

input FixtureCreateWithoutTeamAInput {
  id: ID
  fplCode: Int!
  event: GameweekCreateOneInput!
  finished: Boolean!
  finishedProvisional: Boolean!
  fixtureId: Int!
  kickoffTime: DateTime
  minutes: Int!
  provisionalStartTime: Boolean!
  started: Boolean!
  teamADifficulty: Int!
  teamAScore: Int
  teamH: HomeTeamFixtureCreateOneWithoutFixtureInput!
  teamHDifficulty: Int!
  teamHScore: Int
}

input FixtureCreateWithoutTeamHInput {
  id: ID
  fplCode: Int!
  event: GameweekCreateOneInput!
  finished: Boolean!
  finishedProvisional: Boolean!
  fixtureId: Int!
  kickoffTime: DateTime
  minutes: Int!
  provisionalStartTime: Boolean!
  started: Boolean!
  teamA: AwayTeamFixtureCreateOneWithoutFixtureInput!
  teamADifficulty: Int!
  teamAScore: Int
  teamHDifficulty: Int!
  teamHScore: Int
}

type FixtureEdge {
  node: Fixture!
  cursor: String!
}

enum FixtureOrderByInput {
  id_ASC
  id_DESC
  fplCode_ASC
  fplCode_DESC
  finished_ASC
  finished_DESC
  finishedProvisional_ASC
  finishedProvisional_DESC
  fixtureId_ASC
  fixtureId_DESC
  kickoffTime_ASC
  kickoffTime_DESC
  minutes_ASC
  minutes_DESC
  provisionalStartTime_ASC
  provisionalStartTime_DESC
  started_ASC
  started_DESC
  teamADifficulty_ASC
  teamADifficulty_DESC
  teamAScore_ASC
  teamAScore_DESC
  teamHDifficulty_ASC
  teamHDifficulty_DESC
  teamHScore_ASC
  teamHScore_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FixturePreviousValues {
  id: ID!
  fplCode: Int!
  finished: Boolean!
  finishedProvisional: Boolean!
  fixtureId: Int!
  kickoffTime: DateTime
  minutes: Int!
  provisionalStartTime: Boolean!
  started: Boolean!
  teamADifficulty: Int!
  teamAScore: Int
  teamHDifficulty: Int!
  teamHScore: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FixtureSubscriptionPayload {
  mutation: MutationType!
  node: Fixture
  updatedFields: [String!]
  previousValues: FixturePreviousValues
}

input FixtureSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FixtureWhereInput
  AND: [FixtureSubscriptionWhereInput!]
  OR: [FixtureSubscriptionWhereInput!]
  NOT: [FixtureSubscriptionWhereInput!]
}

input FixtureUpdateInput {
  fplCode: Int
  event: GameweekUpdateOneRequiredInput
  finished: Boolean
  finishedProvisional: Boolean
  fixtureId: Int
  kickoffTime: DateTime
  minutes: Int
  provisionalStartTime: Boolean
  started: Boolean
  teamA: AwayTeamFixtureUpdateOneRequiredWithoutFixtureInput
  teamADifficulty: Int
  teamAScore: Int
  teamH: HomeTeamFixtureUpdateOneRequiredWithoutFixtureInput
  teamHDifficulty: Int
  teamHScore: Int
}

input FixtureUpdateManyMutationInput {
  fplCode: Int
  finished: Boolean
  finishedProvisional: Boolean
  fixtureId: Int
  kickoffTime: DateTime
  minutes: Int
  provisionalStartTime: Boolean
  started: Boolean
  teamADifficulty: Int
  teamAScore: Int
  teamHDifficulty: Int
  teamHScore: Int
}

input FixtureUpdateOneRequiredWithoutTeamAInput {
  create: FixtureCreateWithoutTeamAInput
  update: FixtureUpdateWithoutTeamADataInput
  upsert: FixtureUpsertWithoutTeamAInput
  connect: FixtureWhereUniqueInput
}

input FixtureUpdateOneRequiredWithoutTeamHInput {
  create: FixtureCreateWithoutTeamHInput
  update: FixtureUpdateWithoutTeamHDataInput
  upsert: FixtureUpsertWithoutTeamHInput
  connect: FixtureWhereUniqueInput
}

input FixtureUpdateWithoutTeamADataInput {
  fplCode: Int
  event: GameweekUpdateOneRequiredInput
  finished: Boolean
  finishedProvisional: Boolean
  fixtureId: Int
  kickoffTime: DateTime
  minutes: Int
  provisionalStartTime: Boolean
  started: Boolean
  teamADifficulty: Int
  teamAScore: Int
  teamH: HomeTeamFixtureUpdateOneRequiredWithoutFixtureInput
  teamHDifficulty: Int
  teamHScore: Int
}

input FixtureUpdateWithoutTeamHDataInput {
  fplCode: Int
  event: GameweekUpdateOneRequiredInput
  finished: Boolean
  finishedProvisional: Boolean
  fixtureId: Int
  kickoffTime: DateTime
  minutes: Int
  provisionalStartTime: Boolean
  started: Boolean
  teamA: AwayTeamFixtureUpdateOneRequiredWithoutFixtureInput
  teamADifficulty: Int
  teamAScore: Int
  teamHDifficulty: Int
  teamHScore: Int
}

input FixtureUpsertWithoutTeamAInput {
  update: FixtureUpdateWithoutTeamADataInput!
  create: FixtureCreateWithoutTeamAInput!
}

input FixtureUpsertWithoutTeamHInput {
  update: FixtureUpdateWithoutTeamHDataInput!
  create: FixtureCreateWithoutTeamHInput!
}

input FixtureWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fplCode: Int
  fplCode_not: Int
  fplCode_in: [Int!]
  fplCode_not_in: [Int!]
  fplCode_lt: Int
  fplCode_lte: Int
  fplCode_gt: Int
  fplCode_gte: Int
  event: GameweekWhereInput
  finished: Boolean
  finished_not: Boolean
  finishedProvisional: Boolean
  finishedProvisional_not: Boolean
  fixtureId: Int
  fixtureId_not: Int
  fixtureId_in: [Int!]
  fixtureId_not_in: [Int!]
  fixtureId_lt: Int
  fixtureId_lte: Int
  fixtureId_gt: Int
  fixtureId_gte: Int
  kickoffTime: DateTime
  kickoffTime_not: DateTime
  kickoffTime_in: [DateTime!]
  kickoffTime_not_in: [DateTime!]
  kickoffTime_lt: DateTime
  kickoffTime_lte: DateTime
  kickoffTime_gt: DateTime
  kickoffTime_gte: DateTime
  minutes: Int
  minutes_not: Int
  minutes_in: [Int!]
  minutes_not_in: [Int!]
  minutes_lt: Int
  minutes_lte: Int
  minutes_gt: Int
  minutes_gte: Int
  provisionalStartTime: Boolean
  provisionalStartTime_not: Boolean
  started: Boolean
  started_not: Boolean
  teamA: AwayTeamFixtureWhereInput
  teamADifficulty: Int
  teamADifficulty_not: Int
  teamADifficulty_in: [Int!]
  teamADifficulty_not_in: [Int!]
  teamADifficulty_lt: Int
  teamADifficulty_lte: Int
  teamADifficulty_gt: Int
  teamADifficulty_gte: Int
  teamAScore: Int
  teamAScore_not: Int
  teamAScore_in: [Int!]
  teamAScore_not_in: [Int!]
  teamAScore_lt: Int
  teamAScore_lte: Int
  teamAScore_gt: Int
  teamAScore_gte: Int
  teamH: HomeTeamFixtureWhereInput
  teamHDifficulty: Int
  teamHDifficulty_not: Int
  teamHDifficulty_in: [Int!]
  teamHDifficulty_not_in: [Int!]
  teamHDifficulty_lt: Int
  teamHDifficulty_lte: Int
  teamHDifficulty_gt: Int
  teamHDifficulty_gte: Int
  teamHScore: Int
  teamHScore_not: Int
  teamHScore_in: [Int!]
  teamHScore_not_in: [Int!]
  teamHScore_lt: Int
  teamHScore_lte: Int
  teamHScore_gt: Int
  teamHScore_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FixtureWhereInput!]
  OR: [FixtureWhereInput!]
  NOT: [FixtureWhereInput!]
}

input FixtureWhereUniqueInput {
  id: ID
  fplCode: Int
}

type Follower {
  id: ID!
  user: User!
  blocked: Boolean!
  accepted: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FollowerConnection {
  pageInfo: PageInfo!
  edges: [FollowerEdge]!
  aggregate: AggregateFollower!
}

input FollowerCreateInput {
  id: ID
  user: UserCreateOneInput!
  blocked: Boolean
  accepted: Boolean
}

input FollowerCreateManyInput {
  create: [FollowerCreateInput!]
  connect: [FollowerWhereUniqueInput!]
}

type FollowerEdge {
  node: Follower!
  cursor: String!
}

enum FollowerOrderByInput {
  id_ASC
  id_DESC
  blocked_ASC
  blocked_DESC
  accepted_ASC
  accepted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FollowerPreviousValues {
  id: ID!
  blocked: Boolean!
  accepted: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input FollowerScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  blocked: Boolean
  blocked_not: Boolean
  accepted: Boolean
  accepted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FollowerScalarWhereInput!]
  OR: [FollowerScalarWhereInput!]
  NOT: [FollowerScalarWhereInput!]
}

type FollowerSubscriptionPayload {
  mutation: MutationType!
  node: Follower
  updatedFields: [String!]
  previousValues: FollowerPreviousValues
}

input FollowerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FollowerWhereInput
  AND: [FollowerSubscriptionWhereInput!]
  OR: [FollowerSubscriptionWhereInput!]
  NOT: [FollowerSubscriptionWhereInput!]
}

input FollowerUpdateDataInput {
  user: UserUpdateOneRequiredInput
  blocked: Boolean
  accepted: Boolean
}

input FollowerUpdateInput {
  user: UserUpdateOneRequiredInput
  blocked: Boolean
  accepted: Boolean
}

input FollowerUpdateManyDataInput {
  blocked: Boolean
  accepted: Boolean
}

input FollowerUpdateManyInput {
  create: [FollowerCreateInput!]
  update: [FollowerUpdateWithWhereUniqueNestedInput!]
  upsert: [FollowerUpsertWithWhereUniqueNestedInput!]
  delete: [FollowerWhereUniqueInput!]
  connect: [FollowerWhereUniqueInput!]
  set: [FollowerWhereUniqueInput!]
  disconnect: [FollowerWhereUniqueInput!]
  deleteMany: [FollowerScalarWhereInput!]
  updateMany: [FollowerUpdateManyWithWhereNestedInput!]
}

input FollowerUpdateManyMutationInput {
  blocked: Boolean
  accepted: Boolean
}

input FollowerUpdateManyWithWhereNestedInput {
  where: FollowerScalarWhereInput!
  data: FollowerUpdateManyDataInput!
}

input FollowerUpdateWithWhereUniqueNestedInput {
  where: FollowerWhereUniqueInput!
  data: FollowerUpdateDataInput!
}

input FollowerUpsertWithWhereUniqueNestedInput {
  where: FollowerWhereUniqueInput!
  update: FollowerUpdateDataInput!
  create: FollowerCreateInput!
}

input FollowerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  blocked: Boolean
  blocked_not: Boolean
  accepted: Boolean
  accepted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FollowerWhereInput!]
  OR: [FollowerWhereInput!]
  NOT: [FollowerWhereInput!]
}

input FollowerWhereUniqueInput {
  id: ID
}

type Gameweek {
  id: ID!
  season: Season!
  averageEntryScore: Int
  dataChecked: Boolean!
  deadlineTime: DateTime!
  deadlineTimeEpoch: Int!
  deadlineTimeGameOffset: Int!
  finished: Boolean!
  highestScore: Int
  highestScoringEntry: Int
  fplEventId: Int!
  isCurrent: Boolean!
  isNext: Boolean!
  isPrevious: Boolean!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GameweekConnection {
  pageInfo: PageInfo!
  edges: [GameweekEdge]!
  aggregate: AggregateGameweek!
}

input GameweekCreateInput {
  id: ID
  season: SeasonCreateOneInput!
  averageEntryScore: Int
  dataChecked: Boolean!
  deadlineTime: DateTime!
  deadlineTimeEpoch: Int!
  deadlineTimeGameOffset: Int!
  finished: Boolean!
  highestScore: Int
  highestScoringEntry: Int
  fplEventId: Int!
  isCurrent: Boolean!
  isNext: Boolean!
  isPrevious: Boolean!
  name: String!
}

input GameweekCreateOneInput {
  create: GameweekCreateInput
  connect: GameweekWhereUniqueInput
}

type GameweekEdge {
  node: Gameweek!
  cursor: String!
}

enum GameweekOrderByInput {
  id_ASC
  id_DESC
  averageEntryScore_ASC
  averageEntryScore_DESC
  dataChecked_ASC
  dataChecked_DESC
  deadlineTime_ASC
  deadlineTime_DESC
  deadlineTimeEpoch_ASC
  deadlineTimeEpoch_DESC
  deadlineTimeGameOffset_ASC
  deadlineTimeGameOffset_DESC
  finished_ASC
  finished_DESC
  highestScore_ASC
  highestScore_DESC
  highestScoringEntry_ASC
  highestScoringEntry_DESC
  fplEventId_ASC
  fplEventId_DESC
  isCurrent_ASC
  isCurrent_DESC
  isNext_ASC
  isNext_DESC
  isPrevious_ASC
  isPrevious_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GameweekPreviousValues {
  id: ID!
  averageEntryScore: Int
  dataChecked: Boolean!
  deadlineTime: DateTime!
  deadlineTimeEpoch: Int!
  deadlineTimeGameOffset: Int!
  finished: Boolean!
  highestScore: Int
  highestScoringEntry: Int
  fplEventId: Int!
  isCurrent: Boolean!
  isNext: Boolean!
  isPrevious: Boolean!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GameweekSubscriptionPayload {
  mutation: MutationType!
  node: Gameweek
  updatedFields: [String!]
  previousValues: GameweekPreviousValues
}

input GameweekSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GameweekWhereInput
  AND: [GameweekSubscriptionWhereInput!]
  OR: [GameweekSubscriptionWhereInput!]
  NOT: [GameweekSubscriptionWhereInput!]
}

input GameweekUpdateDataInput {
  season: SeasonUpdateOneRequiredInput
  averageEntryScore: Int
  dataChecked: Boolean
  deadlineTime: DateTime
  deadlineTimeEpoch: Int
  deadlineTimeGameOffset: Int
  finished: Boolean
  highestScore: Int
  highestScoringEntry: Int
  fplEventId: Int
  isCurrent: Boolean
  isNext: Boolean
  isPrevious: Boolean
  name: String
}

input GameweekUpdateInput {
  season: SeasonUpdateOneRequiredInput
  averageEntryScore: Int
  dataChecked: Boolean
  deadlineTime: DateTime
  deadlineTimeEpoch: Int
  deadlineTimeGameOffset: Int
  finished: Boolean
  highestScore: Int
  highestScoringEntry: Int
  fplEventId: Int
  isCurrent: Boolean
  isNext: Boolean
  isPrevious: Boolean
  name: String
}

input GameweekUpdateManyMutationInput {
  averageEntryScore: Int
  dataChecked: Boolean
  deadlineTime: DateTime
  deadlineTimeEpoch: Int
  deadlineTimeGameOffset: Int
  finished: Boolean
  highestScore: Int
  highestScoringEntry: Int
  fplEventId: Int
  isCurrent: Boolean
  isNext: Boolean
  isPrevious: Boolean
  name: String
}

input GameweekUpdateOneRequiredInput {
  create: GameweekCreateInput
  update: GameweekUpdateDataInput
  upsert: GameweekUpsertNestedInput
  connect: GameweekWhereUniqueInput
}

input GameweekUpsertNestedInput {
  update: GameweekUpdateDataInput!
  create: GameweekCreateInput!
}

input GameweekWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  season: SeasonWhereInput
  averageEntryScore: Int
  averageEntryScore_not: Int
  averageEntryScore_in: [Int!]
  averageEntryScore_not_in: [Int!]
  averageEntryScore_lt: Int
  averageEntryScore_lte: Int
  averageEntryScore_gt: Int
  averageEntryScore_gte: Int
  dataChecked: Boolean
  dataChecked_not: Boolean
  deadlineTime: DateTime
  deadlineTime_not: DateTime
  deadlineTime_in: [DateTime!]
  deadlineTime_not_in: [DateTime!]
  deadlineTime_lt: DateTime
  deadlineTime_lte: DateTime
  deadlineTime_gt: DateTime
  deadlineTime_gte: DateTime
  deadlineTimeEpoch: Int
  deadlineTimeEpoch_not: Int
  deadlineTimeEpoch_in: [Int!]
  deadlineTimeEpoch_not_in: [Int!]
  deadlineTimeEpoch_lt: Int
  deadlineTimeEpoch_lte: Int
  deadlineTimeEpoch_gt: Int
  deadlineTimeEpoch_gte: Int
  deadlineTimeGameOffset: Int
  deadlineTimeGameOffset_not: Int
  deadlineTimeGameOffset_in: [Int!]
  deadlineTimeGameOffset_not_in: [Int!]
  deadlineTimeGameOffset_lt: Int
  deadlineTimeGameOffset_lte: Int
  deadlineTimeGameOffset_gt: Int
  deadlineTimeGameOffset_gte: Int
  finished: Boolean
  finished_not: Boolean
  highestScore: Int
  highestScore_not: Int
  highestScore_in: [Int!]
  highestScore_not_in: [Int!]
  highestScore_lt: Int
  highestScore_lte: Int
  highestScore_gt: Int
  highestScore_gte: Int
  highestScoringEntry: Int
  highestScoringEntry_not: Int
  highestScoringEntry_in: [Int!]
  highestScoringEntry_not_in: [Int!]
  highestScoringEntry_lt: Int
  highestScoringEntry_lte: Int
  highestScoringEntry_gt: Int
  highestScoringEntry_gte: Int
  fplEventId: Int
  fplEventId_not: Int
  fplEventId_in: [Int!]
  fplEventId_not_in: [Int!]
  fplEventId_lt: Int
  fplEventId_lte: Int
  fplEventId_gt: Int
  fplEventId_gte: Int
  isCurrent: Boolean
  isCurrent_not: Boolean
  isNext: Boolean
  isNext_not: Boolean
  isPrevious: Boolean
  isPrevious_not: Boolean
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [GameweekWhereInput!]
  OR: [GameweekWhereInput!]
  NOT: [GameweekWhereInput!]
}

input GameweekWhereUniqueInput {
  id: ID
  fplEventId: Int
}

type HomeTeamFixture {
  id: ID!
  fixture: Fixture!
  homeTeam: Team!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type HomeTeamFixtureConnection {
  pageInfo: PageInfo!
  edges: [HomeTeamFixtureEdge]!
  aggregate: AggregateHomeTeamFixture!
}

input HomeTeamFixtureCreateInput {
  id: ID
  fixture: FixtureCreateOneWithoutTeamHInput!
  homeTeam: TeamCreateOneWithoutHomeFixturesInput!
}

input HomeTeamFixtureCreateManyWithoutHomeTeamInput {
  create: [HomeTeamFixtureCreateWithoutHomeTeamInput!]
  connect: [HomeTeamFixtureWhereUniqueInput!]
}

input HomeTeamFixtureCreateOneWithoutFixtureInput {
  create: HomeTeamFixtureCreateWithoutFixtureInput
  connect: HomeTeamFixtureWhereUniqueInput
}

input HomeTeamFixtureCreateWithoutFixtureInput {
  id: ID
  homeTeam: TeamCreateOneWithoutHomeFixturesInput!
}

input HomeTeamFixtureCreateWithoutHomeTeamInput {
  id: ID
  fixture: FixtureCreateOneWithoutTeamHInput!
}

type HomeTeamFixtureEdge {
  node: HomeTeamFixture!
  cursor: String!
}

enum HomeTeamFixtureOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type HomeTeamFixturePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input HomeTeamFixtureScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [HomeTeamFixtureScalarWhereInput!]
  OR: [HomeTeamFixtureScalarWhereInput!]
  NOT: [HomeTeamFixtureScalarWhereInput!]
}

type HomeTeamFixtureSubscriptionPayload {
  mutation: MutationType!
  node: HomeTeamFixture
  updatedFields: [String!]
  previousValues: HomeTeamFixturePreviousValues
}

input HomeTeamFixtureSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HomeTeamFixtureWhereInput
  AND: [HomeTeamFixtureSubscriptionWhereInput!]
  OR: [HomeTeamFixtureSubscriptionWhereInput!]
  NOT: [HomeTeamFixtureSubscriptionWhereInput!]
}

input HomeTeamFixtureUpdateInput {
  fixture: FixtureUpdateOneRequiredWithoutTeamHInput
  homeTeam: TeamUpdateOneRequiredWithoutHomeFixturesInput
}

input HomeTeamFixtureUpdateManyWithoutHomeTeamInput {
  create: [HomeTeamFixtureCreateWithoutHomeTeamInput!]
  delete: [HomeTeamFixtureWhereUniqueInput!]
  connect: [HomeTeamFixtureWhereUniqueInput!]
  set: [HomeTeamFixtureWhereUniqueInput!]
  disconnect: [HomeTeamFixtureWhereUniqueInput!]
  update: [HomeTeamFixtureUpdateWithWhereUniqueWithoutHomeTeamInput!]
  upsert: [HomeTeamFixtureUpsertWithWhereUniqueWithoutHomeTeamInput!]
  deleteMany: [HomeTeamFixtureScalarWhereInput!]
}

input HomeTeamFixtureUpdateOneRequiredWithoutFixtureInput {
  create: HomeTeamFixtureCreateWithoutFixtureInput
  update: HomeTeamFixtureUpdateWithoutFixtureDataInput
  upsert: HomeTeamFixtureUpsertWithoutFixtureInput
  connect: HomeTeamFixtureWhereUniqueInput
}

input HomeTeamFixtureUpdateWithoutFixtureDataInput {
  homeTeam: TeamUpdateOneRequiredWithoutHomeFixturesInput
}

input HomeTeamFixtureUpdateWithoutHomeTeamDataInput {
  fixture: FixtureUpdateOneRequiredWithoutTeamHInput
}

input HomeTeamFixtureUpdateWithWhereUniqueWithoutHomeTeamInput {
  where: HomeTeamFixtureWhereUniqueInput!
  data: HomeTeamFixtureUpdateWithoutHomeTeamDataInput!
}

input HomeTeamFixtureUpsertWithoutFixtureInput {
  update: HomeTeamFixtureUpdateWithoutFixtureDataInput!
  create: HomeTeamFixtureCreateWithoutFixtureInput!
}

input HomeTeamFixtureUpsertWithWhereUniqueWithoutHomeTeamInput {
  where: HomeTeamFixtureWhereUniqueInput!
  update: HomeTeamFixtureUpdateWithoutHomeTeamDataInput!
  create: HomeTeamFixtureCreateWithoutHomeTeamInput!
}

input HomeTeamFixtureWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fixture: FixtureWhereInput
  homeTeam: TeamWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [HomeTeamFixtureWhereInput!]
  OR: [HomeTeamFixtureWhereInput!]
  NOT: [HomeTeamFixtureWhereInput!]
}

input HomeTeamFixtureWhereUniqueInput {
  id: ID
}

type Influencer {
  id: ID!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InfluencerConnection {
  pageInfo: PageInfo!
  edges: [InfluencerEdge]!
  aggregate: AggregateInfluencer!
}

input InfluencerCreateInput {
  id: ID
  user: UserCreateOneInput!
}

input InfluencerCreateManyInput {
  create: [InfluencerCreateInput!]
  connect: [InfluencerWhereUniqueInput!]
}

type InfluencerEdge {
  node: Influencer!
  cursor: String!
}

enum InfluencerOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type InfluencerPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input InfluencerScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InfluencerScalarWhereInput!]
  OR: [InfluencerScalarWhereInput!]
  NOT: [InfluencerScalarWhereInput!]
}

type InfluencerSubscriptionPayload {
  mutation: MutationType!
  node: Influencer
  updatedFields: [String!]
  previousValues: InfluencerPreviousValues
}

input InfluencerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InfluencerWhereInput
  AND: [InfluencerSubscriptionWhereInput!]
  OR: [InfluencerSubscriptionWhereInput!]
  NOT: [InfluencerSubscriptionWhereInput!]
}

input InfluencerUpdateDataInput {
  user: UserUpdateOneRequiredInput
}

input InfluencerUpdateInput {
  user: UserUpdateOneRequiredInput
}

input InfluencerUpdateManyInput {
  create: [InfluencerCreateInput!]
  update: [InfluencerUpdateWithWhereUniqueNestedInput!]
  upsert: [InfluencerUpsertWithWhereUniqueNestedInput!]
  delete: [InfluencerWhereUniqueInput!]
  connect: [InfluencerWhereUniqueInput!]
  set: [InfluencerWhereUniqueInput!]
  disconnect: [InfluencerWhereUniqueInput!]
  deleteMany: [InfluencerScalarWhereInput!]
}

input InfluencerUpdateWithWhereUniqueNestedInput {
  where: InfluencerWhereUniqueInput!
  data: InfluencerUpdateDataInput!
}

input InfluencerUpsertWithWhereUniqueNestedInput {
  where: InfluencerWhereUniqueInput!
  update: InfluencerUpdateDataInput!
  create: InfluencerCreateInput!
}

input InfluencerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InfluencerWhereInput!]
  OR: [InfluencerWhereInput!]
  NOT: [InfluencerWhereInput!]
}

input InfluencerWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createActiveSubscriptions(data: ActiveSubscriptionsCreateInput!): ActiveSubscriptions!
  updateActiveSubscriptions(data: ActiveSubscriptionsUpdateInput!, where: ActiveSubscriptionsWhereUniqueInput!): ActiveSubscriptions
  updateManyActiveSubscriptionses(data: ActiveSubscriptionsUpdateManyMutationInput!, where: ActiveSubscriptionsWhereInput): BatchPayload!
  upsertActiveSubscriptions(where: ActiveSubscriptionsWhereUniqueInput!, create: ActiveSubscriptionsCreateInput!, update: ActiveSubscriptionsUpdateInput!): ActiveSubscriptions!
  deleteActiveSubscriptions(where: ActiveSubscriptionsWhereUniqueInput!): ActiveSubscriptions
  deleteManyActiveSubscriptionses(where: ActiveSubscriptionsWhereInput): BatchPayload!
  createAwayTeamFixture(data: AwayTeamFixtureCreateInput!): AwayTeamFixture!
  updateAwayTeamFixture(data: AwayTeamFixtureUpdateInput!, where: AwayTeamFixtureWhereUniqueInput!): AwayTeamFixture
  upsertAwayTeamFixture(where: AwayTeamFixtureWhereUniqueInput!, create: AwayTeamFixtureCreateInput!, update: AwayTeamFixtureUpdateInput!): AwayTeamFixture!
  deleteAwayTeamFixture(where: AwayTeamFixtureWhereUniqueInput!): AwayTeamFixture
  deleteManyAwayTeamFixtures(where: AwayTeamFixtureWhereInput): BatchPayload!
  createCountry(data: CountryCreateInput!): Country!
  updateCountry(data: CountryUpdateInput!, where: CountryWhereUniqueInput!): Country
  updateManyCountries(data: CountryUpdateManyMutationInput!, where: CountryWhereInput): BatchPayload!
  upsertCountry(where: CountryWhereUniqueInput!, create: CountryCreateInput!, update: CountryUpdateInput!): Country!
  deleteCountry(where: CountryWhereUniqueInput!): Country
  deleteManyCountries(where: CountryWhereInput): BatchPayload!
  createFandemSubscription(data: FandemSubscriptionCreateInput!): FandemSubscription!
  updateFandemSubscription(data: FandemSubscriptionUpdateInput!, where: FandemSubscriptionWhereUniqueInput!): FandemSubscription
  updateManyFandemSubscriptions(data: FandemSubscriptionUpdateManyMutationInput!, where: FandemSubscriptionWhereInput): BatchPayload!
  upsertFandemSubscription(where: FandemSubscriptionWhereUniqueInput!, create: FandemSubscriptionCreateInput!, update: FandemSubscriptionUpdateInput!): FandemSubscription!
  deleteFandemSubscription(where: FandemSubscriptionWhereUniqueInput!): FandemSubscription
  deleteManyFandemSubscriptions(where: FandemSubscriptionWhereInput): BatchPayload!
  createFixture(data: FixtureCreateInput!): Fixture!
  updateFixture(data: FixtureUpdateInput!, where: FixtureWhereUniqueInput!): Fixture
  updateManyFixtures(data: FixtureUpdateManyMutationInput!, where: FixtureWhereInput): BatchPayload!
  upsertFixture(where: FixtureWhereUniqueInput!, create: FixtureCreateInput!, update: FixtureUpdateInput!): Fixture!
  deleteFixture(where: FixtureWhereUniqueInput!): Fixture
  deleteManyFixtures(where: FixtureWhereInput): BatchPayload!
  createFollower(data: FollowerCreateInput!): Follower!
  updateFollower(data: FollowerUpdateInput!, where: FollowerWhereUniqueInput!): Follower
  updateManyFollowers(data: FollowerUpdateManyMutationInput!, where: FollowerWhereInput): BatchPayload!
  upsertFollower(where: FollowerWhereUniqueInput!, create: FollowerCreateInput!, update: FollowerUpdateInput!): Follower!
  deleteFollower(where: FollowerWhereUniqueInput!): Follower
  deleteManyFollowers(where: FollowerWhereInput): BatchPayload!
  createGameweek(data: GameweekCreateInput!): Gameweek!
  updateGameweek(data: GameweekUpdateInput!, where: GameweekWhereUniqueInput!): Gameweek
  updateManyGameweeks(data: GameweekUpdateManyMutationInput!, where: GameweekWhereInput): BatchPayload!
  upsertGameweek(where: GameweekWhereUniqueInput!, create: GameweekCreateInput!, update: GameweekUpdateInput!): Gameweek!
  deleteGameweek(where: GameweekWhereUniqueInput!): Gameweek
  deleteManyGameweeks(where: GameweekWhereInput): BatchPayload!
  createHomeTeamFixture(data: HomeTeamFixtureCreateInput!): HomeTeamFixture!
  updateHomeTeamFixture(data: HomeTeamFixtureUpdateInput!, where: HomeTeamFixtureWhereUniqueInput!): HomeTeamFixture
  upsertHomeTeamFixture(where: HomeTeamFixtureWhereUniqueInput!, create: HomeTeamFixtureCreateInput!, update: HomeTeamFixtureUpdateInput!): HomeTeamFixture!
  deleteHomeTeamFixture(where: HomeTeamFixtureWhereUniqueInput!): HomeTeamFixture
  deleteManyHomeTeamFixtures(where: HomeTeamFixtureWhereInput): BatchPayload!
  createInfluencer(data: InfluencerCreateInput!): Influencer!
  updateInfluencer(data: InfluencerUpdateInput!, where: InfluencerWhereUniqueInput!): Influencer
  upsertInfluencer(where: InfluencerWhereUniqueInput!, create: InfluencerCreateInput!, update: InfluencerUpdateInput!): Influencer!
  deleteInfluencer(where: InfluencerWhereUniqueInput!): Influencer
  deleteManyInfluencers(where: InfluencerWhereInput): BatchPayload!
  createPhoto(data: PhotoCreateInput!): Photo!
  updatePhoto(data: PhotoUpdateInput!, where: PhotoWhereUniqueInput!): Photo
  updateManyPhotos(data: PhotoUpdateManyMutationInput!, where: PhotoWhereInput): BatchPayload!
  upsertPhoto(where: PhotoWhereUniqueInput!, create: PhotoCreateInput!, update: PhotoUpdateInput!): Photo!
  deletePhoto(where: PhotoWhereUniqueInput!): Photo
  deleteManyPhotos(where: PhotoWhereInput): BatchPayload!
  createSeason(data: SeasonCreateInput!): Season!
  updateSeason(data: SeasonUpdateInput!, where: SeasonWhereUniqueInput!): Season
  updateManySeasons(data: SeasonUpdateManyMutationInput!, where: SeasonWhereInput): BatchPayload!
  upsertSeason(where: SeasonWhereUniqueInput!, create: SeasonCreateInput!, update: SeasonUpdateInput!): Season!
  deleteSeason(where: SeasonWhereUniqueInput!): Season
  deleteManySeasons(where: SeasonWhereInput): BatchPayload!
  createStatus(data: StatusCreateInput!): Status!
  updateStatus(data: StatusUpdateInput!, where: StatusWhereUniqueInput!): Status
  updateManyStatuses(data: StatusUpdateManyMutationInput!, where: StatusWhereInput): BatchPayload!
  upsertStatus(where: StatusWhereUniqueInput!, create: StatusCreateInput!, update: StatusUpdateInput!): Status!
  deleteStatus(where: StatusWhereUniqueInput!): Status
  deleteManyStatuses(where: StatusWhereInput): BatchPayload!
  createTeam(data: TeamCreateInput!): Team!
  updateTeam(data: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team
  updateManyTeams(data: TeamUpdateManyMutationInput!, where: TeamWhereInput): BatchPayload!
  upsertTeam(where: TeamWhereUniqueInput!, create: TeamCreateInput!, update: TeamUpdateInput!): Team!
  deleteTeam(where: TeamWhereUniqueInput!): Team
  deleteManyTeams(where: TeamWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createUserAssignedRole(data: UserAssignedRoleCreateInput!): UserAssignedRole!
  updateUserAssignedRole(data: UserAssignedRoleUpdateInput!, where: UserAssignedRoleWhereUniqueInput!): UserAssignedRole
  upsertUserAssignedRole(where: UserAssignedRoleWhereUniqueInput!, create: UserAssignedRoleCreateInput!, update: UserAssignedRoleUpdateInput!): UserAssignedRole!
  deleteUserAssignedRole(where: UserAssignedRoleWhereUniqueInput!): UserAssignedRole
  deleteManyUserAssignedRoles(where: UserAssignedRoleWhereInput): BatchPayload!
  createUserFollowers(data: UserFollowersCreateInput!): UserFollowers!
  updateUserFollowers(data: UserFollowersUpdateInput!, where: UserFollowersWhereUniqueInput!): UserFollowers
  upsertUserFollowers(where: UserFollowersWhereUniqueInput!, create: UserFollowersCreateInput!, update: UserFollowersUpdateInput!): UserFollowers!
  deleteUserFollowers(where: UserFollowersWhereUniqueInput!): UserFollowers
  deleteManyUserFollowerses(where: UserFollowersWhereInput): BatchPayload!
  createUserInfluencers(data: UserInfluencersCreateInput!): UserInfluencers!
  updateUserInfluencers(data: UserInfluencersUpdateInput!, where: UserInfluencersWhereUniqueInput!): UserInfluencers
  upsertUserInfluencers(where: UserInfluencersWhereUniqueInput!, create: UserInfluencersCreateInput!, update: UserInfluencersUpdateInput!): UserInfluencers!
  deleteUserInfluencers(where: UserInfluencersWhereUniqueInput!): UserInfluencers
  deleteManyUserInfluencerses(where: UserInfluencersWhereInput): BatchPayload!
  createUserPhoto(data: UserPhotoCreateInput!): UserPhoto!
  updateUserPhoto(data: UserPhotoUpdateInput!, where: UserPhotoWhereUniqueInput!): UserPhoto
  updateManyUserPhotos(data: UserPhotoUpdateManyMutationInput!, where: UserPhotoWhereInput): BatchPayload!
  upsertUserPhoto(where: UserPhotoWhereUniqueInput!, create: UserPhotoCreateInput!, update: UserPhotoUpdateInput!): UserPhoto!
  deleteUserPhoto(where: UserPhotoWhereUniqueInput!): UserPhoto
  deleteManyUserPhotos(where: UserPhotoWhereInput): BatchPayload!
  createUserRole(data: UserRoleCreateInput!): UserRole!
  updateUserRole(data: UserRoleUpdateInput!, where: UserRoleWhereUniqueInput!): UserRole
  updateManyUserRoles(data: UserRoleUpdateManyMutationInput!, where: UserRoleWhereInput): BatchPayload!
  upsertUserRole(where: UserRoleWhereUniqueInput!, create: UserRoleCreateInput!, update: UserRoleUpdateInput!): UserRole!
  deleteUserRole(where: UserRoleWhereUniqueInput!): UserRole
  deleteManyUserRoles(where: UserRoleWhereInput): BatchPayload!
  createUserStatus(data: UserStatusCreateInput!): UserStatus!
  updateUserStatus(data: UserStatusUpdateInput!, where: UserStatusWhereUniqueInput!): UserStatus
  updateManyUserStatuses(data: UserStatusUpdateManyMutationInput!, where: UserStatusWhereInput): BatchPayload!
  upsertUserStatus(where: UserStatusWhereUniqueInput!, create: UserStatusCreateInput!, update: UserStatusUpdateInput!): UserStatus!
  deleteUserStatus(where: UserStatusWhereUniqueInput!): UserStatus
  deleteManyUserStatuses(where: UserStatusWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Photo {
  id: ID!
  image: String!
  largeImage: String
  smallImage: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PhotoConnection {
  pageInfo: PageInfo!
  edges: [PhotoEdge]!
  aggregate: AggregatePhoto!
}

input PhotoCreateInput {
  id: ID
  image: String!
  largeImage: String
  smallImage: String
}

input PhotoCreateOneInput {
  create: PhotoCreateInput
  connect: PhotoWhereUniqueInput
}

type PhotoEdge {
  node: Photo!
  cursor: String!
}

enum PhotoOrderByInput {
  id_ASC
  id_DESC
  image_ASC
  image_DESC
  largeImage_ASC
  largeImage_DESC
  smallImage_ASC
  smallImage_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PhotoPreviousValues {
  id: ID!
  image: String!
  largeImage: String
  smallImage: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PhotoSubscriptionPayload {
  mutation: MutationType!
  node: Photo
  updatedFields: [String!]
  previousValues: PhotoPreviousValues
}

input PhotoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PhotoWhereInput
  AND: [PhotoSubscriptionWhereInput!]
  OR: [PhotoSubscriptionWhereInput!]
  NOT: [PhotoSubscriptionWhereInput!]
}

input PhotoUpdateDataInput {
  image: String
  largeImage: String
  smallImage: String
}

input PhotoUpdateInput {
  image: String
  largeImage: String
  smallImage: String
}

input PhotoUpdateManyMutationInput {
  image: String
  largeImage: String
  smallImage: String
}

input PhotoUpdateOneRequiredInput {
  create: PhotoCreateInput
  update: PhotoUpdateDataInput
  upsert: PhotoUpsertNestedInput
  connect: PhotoWhereUniqueInput
}

input PhotoUpsertNestedInput {
  update: PhotoUpdateDataInput!
  create: PhotoCreateInput!
}

input PhotoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  largeImage: String
  largeImage_not: String
  largeImage_in: [String!]
  largeImage_not_in: [String!]
  largeImage_lt: String
  largeImage_lte: String
  largeImage_gt: String
  largeImage_gte: String
  largeImage_contains: String
  largeImage_not_contains: String
  largeImage_starts_with: String
  largeImage_not_starts_with: String
  largeImage_ends_with: String
  largeImage_not_ends_with: String
  smallImage: String
  smallImage_not: String
  smallImage_in: [String!]
  smallImage_not_in: [String!]
  smallImage_lt: String
  smallImage_lte: String
  smallImage_gt: String
  smallImage_gte: String
  smallImage_contains: String
  smallImage_not_contains: String
  smallImage_starts_with: String
  smallImage_not_starts_with: String
  smallImage_ends_with: String
  smallImage_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PhotoWhereInput!]
  OR: [PhotoWhereInput!]
  NOT: [PhotoWhereInput!]
}

input PhotoWhereUniqueInput {
  id: ID
}

type Query {
  activeSubscriptions(where: ActiveSubscriptionsWhereUniqueInput!): ActiveSubscriptions
  activeSubscriptionses(where: ActiveSubscriptionsWhereInput, orderBy: ActiveSubscriptionsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ActiveSubscriptions]!
  activeSubscriptionsesConnection(where: ActiveSubscriptionsWhereInput, orderBy: ActiveSubscriptionsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ActiveSubscriptionsConnection!
  awayTeamFixture(where: AwayTeamFixtureWhereUniqueInput!): AwayTeamFixture
  awayTeamFixtures(where: AwayTeamFixtureWhereInput, orderBy: AwayTeamFixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AwayTeamFixture]!
  awayTeamFixturesConnection(where: AwayTeamFixtureWhereInput, orderBy: AwayTeamFixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AwayTeamFixtureConnection!
  country(where: CountryWhereUniqueInput!): Country
  countries(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Country]!
  countriesConnection(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CountryConnection!
  fandemSubscription(where: FandemSubscriptionWhereUniqueInput!): FandemSubscription
  fandemSubscriptions(where: FandemSubscriptionWhereInput, orderBy: FandemSubscriptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FandemSubscription]!
  fandemSubscriptionsConnection(where: FandemSubscriptionWhereInput, orderBy: FandemSubscriptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FandemSubscriptionConnection!
  fixture(where: FixtureWhereUniqueInput!): Fixture
  fixtures(where: FixtureWhereInput, orderBy: FixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Fixture]!
  fixturesConnection(where: FixtureWhereInput, orderBy: FixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FixtureConnection!
  follower(where: FollowerWhereUniqueInput!): Follower
  followers(where: FollowerWhereInput, orderBy: FollowerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Follower]!
  followersConnection(where: FollowerWhereInput, orderBy: FollowerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FollowerConnection!
  gameweek(where: GameweekWhereUniqueInput!): Gameweek
  gameweeks(where: GameweekWhereInput, orderBy: GameweekOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Gameweek]!
  gameweeksConnection(where: GameweekWhereInput, orderBy: GameweekOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GameweekConnection!
  homeTeamFixture(where: HomeTeamFixtureWhereUniqueInput!): HomeTeamFixture
  homeTeamFixtures(where: HomeTeamFixtureWhereInput, orderBy: HomeTeamFixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [HomeTeamFixture]!
  homeTeamFixturesConnection(where: HomeTeamFixtureWhereInput, orderBy: HomeTeamFixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HomeTeamFixtureConnection!
  influencer(where: InfluencerWhereUniqueInput!): Influencer
  influencers(where: InfluencerWhereInput, orderBy: InfluencerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Influencer]!
  influencersConnection(where: InfluencerWhereInput, orderBy: InfluencerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InfluencerConnection!
  photo(where: PhotoWhereUniqueInput!): Photo
  photos(where: PhotoWhereInput, orderBy: PhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Photo]!
  photosConnection(where: PhotoWhereInput, orderBy: PhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PhotoConnection!
  season(where: SeasonWhereUniqueInput!): Season
  seasons(where: SeasonWhereInput, orderBy: SeasonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Season]!
  seasonsConnection(where: SeasonWhereInput, orderBy: SeasonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SeasonConnection!
  status(where: StatusWhereUniqueInput!): Status
  statuses(where: StatusWhereInput, orderBy: StatusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Status]!
  statusesConnection(where: StatusWhereInput, orderBy: StatusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StatusConnection!
  team(where: TeamWhereUniqueInput!): Team
  teams(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team]!
  teamsConnection(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  userAssignedRole(where: UserAssignedRoleWhereUniqueInput!): UserAssignedRole
  userAssignedRoles(where: UserAssignedRoleWhereInput, orderBy: UserAssignedRoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserAssignedRole]!
  userAssignedRolesConnection(where: UserAssignedRoleWhereInput, orderBy: UserAssignedRoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserAssignedRoleConnection!
  userFollowers(where: UserFollowersWhereUniqueInput!): UserFollowers
  userFollowerses(where: UserFollowersWhereInput, orderBy: UserFollowersOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserFollowers]!
  userFollowersesConnection(where: UserFollowersWhereInput, orderBy: UserFollowersOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserFollowersConnection!
  userInfluencers(where: UserInfluencersWhereUniqueInput!): UserInfluencers
  userInfluencerses(where: UserInfluencersWhereInput, orderBy: UserInfluencersOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserInfluencers]!
  userInfluencersesConnection(where: UserInfluencersWhereInput, orderBy: UserInfluencersOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserInfluencersConnection!
  userPhoto(where: UserPhotoWhereUniqueInput!): UserPhoto
  userPhotos(where: UserPhotoWhereInput, orderBy: UserPhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserPhoto]!
  userPhotosConnection(where: UserPhotoWhereInput, orderBy: UserPhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserPhotoConnection!
  userRole(where: UserRoleWhereUniqueInput!): UserRole
  userRoles(where: UserRoleWhereInput, orderBy: UserRoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserRole]!
  userRolesConnection(where: UserRoleWhereInput, orderBy: UserRoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserRoleConnection!
  userStatus(where: UserStatusWhereUniqueInput!): UserStatus
  userStatuses(where: UserStatusWhereInput, orderBy: UserStatusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserStatus]!
  userStatusesConnection(where: UserStatusWhereInput, orderBy: UserStatusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserStatusConnection!
  node(id: ID!): Node
}

type Season {
  id: ID!
  fplId: Int!
  label: String!
  competition: String!
  startYear: Int!
  endYear: Int!
  isCurrent: Boolean!
  isPrevious: Boolean!
  isNext: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SeasonConnection {
  pageInfo: PageInfo!
  edges: [SeasonEdge]!
  aggregate: AggregateSeason!
}

input SeasonCreateInput {
  id: ID
  fplId: Int!
  label: String!
  competition: String!
  startYear: Int!
  endYear: Int!
  isCurrent: Boolean!
  isPrevious: Boolean!
  isNext: Boolean!
}

input SeasonCreateOneInput {
  create: SeasonCreateInput
  connect: SeasonWhereUniqueInput
}

type SeasonEdge {
  node: Season!
  cursor: String!
}

enum SeasonOrderByInput {
  id_ASC
  id_DESC
  fplId_ASC
  fplId_DESC
  label_ASC
  label_DESC
  competition_ASC
  competition_DESC
  startYear_ASC
  startYear_DESC
  endYear_ASC
  endYear_DESC
  isCurrent_ASC
  isCurrent_DESC
  isPrevious_ASC
  isPrevious_DESC
  isNext_ASC
  isNext_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SeasonPreviousValues {
  id: ID!
  fplId: Int!
  label: String!
  competition: String!
  startYear: Int!
  endYear: Int!
  isCurrent: Boolean!
  isPrevious: Boolean!
  isNext: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SeasonSubscriptionPayload {
  mutation: MutationType!
  node: Season
  updatedFields: [String!]
  previousValues: SeasonPreviousValues
}

input SeasonSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SeasonWhereInput
  AND: [SeasonSubscriptionWhereInput!]
  OR: [SeasonSubscriptionWhereInput!]
  NOT: [SeasonSubscriptionWhereInput!]
}

input SeasonUpdateDataInput {
  fplId: Int
  label: String
  competition: String
  startYear: Int
  endYear: Int
  isCurrent: Boolean
  isPrevious: Boolean
  isNext: Boolean
}

input SeasonUpdateInput {
  fplId: Int
  label: String
  competition: String
  startYear: Int
  endYear: Int
  isCurrent: Boolean
  isPrevious: Boolean
  isNext: Boolean
}

input SeasonUpdateManyMutationInput {
  fplId: Int
  label: String
  competition: String
  startYear: Int
  endYear: Int
  isCurrent: Boolean
  isPrevious: Boolean
  isNext: Boolean
}

input SeasonUpdateOneRequiredInput {
  create: SeasonCreateInput
  update: SeasonUpdateDataInput
  upsert: SeasonUpsertNestedInput
  connect: SeasonWhereUniqueInput
}

input SeasonUpsertNestedInput {
  update: SeasonUpdateDataInput!
  create: SeasonCreateInput!
}

input SeasonWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fplId: Int
  fplId_not: Int
  fplId_in: [Int!]
  fplId_not_in: [Int!]
  fplId_lt: Int
  fplId_lte: Int
  fplId_gt: Int
  fplId_gte: Int
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  competition: String
  competition_not: String
  competition_in: [String!]
  competition_not_in: [String!]
  competition_lt: String
  competition_lte: String
  competition_gt: String
  competition_gte: String
  competition_contains: String
  competition_not_contains: String
  competition_starts_with: String
  competition_not_starts_with: String
  competition_ends_with: String
  competition_not_ends_with: String
  startYear: Int
  startYear_not: Int
  startYear_in: [Int!]
  startYear_not_in: [Int!]
  startYear_lt: Int
  startYear_lte: Int
  startYear_gt: Int
  startYear_gte: Int
  endYear: Int
  endYear_not: Int
  endYear_in: [Int!]
  endYear_not_in: [Int!]
  endYear_lt: Int
  endYear_lte: Int
  endYear_gt: Int
  endYear_gte: Int
  isCurrent: Boolean
  isCurrent_not: Boolean
  isPrevious: Boolean
  isPrevious_not: Boolean
  isNext: Boolean
  isNext_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SeasonWhereInput!]
  OR: [SeasonWhereInput!]
  NOT: [SeasonWhereInput!]
}

input SeasonWhereUniqueInput {
  id: ID
  fplId: Int
}

type Status {
  id: ID!
  author: UserStatus
  content: String!
  likes(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StatusConnection {
  pageInfo: PageInfo!
  edges: [StatusEdge]!
  aggregate: AggregateStatus!
}

input StatusCreateInput {
  id: ID
  author: UserStatusCreateOneWithoutStatusInput
  content: String!
  likes: UserCreateManyInput
}

input StatusCreateOneWithoutAuthorInput {
  create: StatusCreateWithoutAuthorInput
  connect: StatusWhereUniqueInput
}

input StatusCreateWithoutAuthorInput {
  id: ID
  content: String!
  likes: UserCreateManyInput
}

type StatusEdge {
  node: Status!
  cursor: String!
}

enum StatusOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StatusPreviousValues {
  id: ID!
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StatusSubscriptionPayload {
  mutation: MutationType!
  node: Status
  updatedFields: [String!]
  previousValues: StatusPreviousValues
}

input StatusSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StatusWhereInput
  AND: [StatusSubscriptionWhereInput!]
  OR: [StatusSubscriptionWhereInput!]
  NOT: [StatusSubscriptionWhereInput!]
}

input StatusUpdateInput {
  author: UserStatusUpdateOneWithoutStatusInput
  content: String
  likes: UserUpdateManyInput
}

input StatusUpdateManyMutationInput {
  content: String
}

input StatusUpdateOneWithoutAuthorInput {
  create: StatusCreateWithoutAuthorInput
  update: StatusUpdateWithoutAuthorDataInput
  upsert: StatusUpsertWithoutAuthorInput
  delete: Boolean
  disconnect: Boolean
  connect: StatusWhereUniqueInput
}

input StatusUpdateWithoutAuthorDataInput {
  content: String
  likes: UserUpdateManyInput
}

input StatusUpsertWithoutAuthorInput {
  update: StatusUpdateWithoutAuthorDataInput!
  create: StatusCreateWithoutAuthorInput!
}

input StatusWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  author: UserStatusWhereInput
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  likes_every: UserWhereInput
  likes_some: UserWhereInput
  likes_none: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [StatusWhereInput!]
  OR: [StatusWhereInput!]
  NOT: [StatusWhereInput!]
}

input StatusWhereUniqueInput {
  id: ID
}

type Subscription {
  activeSubscriptions(where: ActiveSubscriptionsSubscriptionWhereInput): ActiveSubscriptionsSubscriptionPayload
  awayTeamFixture(where: AwayTeamFixtureSubscriptionWhereInput): AwayTeamFixtureSubscriptionPayload
  country(where: CountrySubscriptionWhereInput): CountrySubscriptionPayload
  fandemSubscription(where: FandemSubscriptionSubscriptionWhereInput): FandemSubscriptionSubscriptionPayload
  fixture(where: FixtureSubscriptionWhereInput): FixtureSubscriptionPayload
  follower(where: FollowerSubscriptionWhereInput): FollowerSubscriptionPayload
  gameweek(where: GameweekSubscriptionWhereInput): GameweekSubscriptionPayload
  homeTeamFixture(where: HomeTeamFixtureSubscriptionWhereInput): HomeTeamFixtureSubscriptionPayload
  influencer(where: InfluencerSubscriptionWhereInput): InfluencerSubscriptionPayload
  photo(where: PhotoSubscriptionWhereInput): PhotoSubscriptionPayload
  season(where: SeasonSubscriptionWhereInput): SeasonSubscriptionPayload
  status(where: StatusSubscriptionWhereInput): StatusSubscriptionPayload
  team(where: TeamSubscriptionWhereInput): TeamSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  userAssignedRole(where: UserAssignedRoleSubscriptionWhereInput): UserAssignedRoleSubscriptionPayload
  userFollowers(where: UserFollowersSubscriptionWhereInput): UserFollowersSubscriptionPayload
  userInfluencers(where: UserInfluencersSubscriptionWhereInput): UserInfluencersSubscriptionPayload
  userPhoto(where: UserPhotoSubscriptionWhereInput): UserPhotoSubscriptionPayload
  userRole(where: UserRoleSubscriptionWhereInput): UserRoleSubscriptionPayload
  userStatus(where: UserStatusSubscriptionWhereInput): UserStatusSubscriptionPayload
}

type Team {
  id: ID!
  code: Int!
  season: Season!
  fplTeamId: Int!
  name: String!
  shortName: String!
  strength: Int!
  strengthAttackAway: Int!
  strengthAttackHome: Int!
  strengthDefenceAway: Int!
  strengthDefenceHome: Int!
  strengthOverallAway: Int!
  strengthOverallHome: Int!
  teamDivision: Int
  homeFixtures(where: HomeTeamFixtureWhereInput, orderBy: HomeTeamFixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [HomeTeamFixture!]
  awayFixtures(where: AwayTeamFixtureWhereInput, orderBy: AwayTeamFixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AwayTeamFixture!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TeamConnection {
  pageInfo: PageInfo!
  edges: [TeamEdge]!
  aggregate: AggregateTeam!
}

input TeamCreateInput {
  id: ID
  code: Int!
  season: SeasonCreateOneInput!
  fplTeamId: Int!
  name: String!
  shortName: String!
  strength: Int!
  strengthAttackAway: Int!
  strengthAttackHome: Int!
  strengthDefenceAway: Int!
  strengthDefenceHome: Int!
  strengthOverallAway: Int!
  strengthOverallHome: Int!
  teamDivision: Int
  homeFixtures: HomeTeamFixtureCreateManyWithoutHomeTeamInput
  awayFixtures: AwayTeamFixtureCreateManyWithoutAwayTeamInput
}

input TeamCreateOneInput {
  create: TeamCreateInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutAwayFixturesInput {
  create: TeamCreateWithoutAwayFixturesInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutHomeFixturesInput {
  create: TeamCreateWithoutHomeFixturesInput
  connect: TeamWhereUniqueInput
}

input TeamCreateWithoutAwayFixturesInput {
  id: ID
  code: Int!
  season: SeasonCreateOneInput!
  fplTeamId: Int!
  name: String!
  shortName: String!
  strength: Int!
  strengthAttackAway: Int!
  strengthAttackHome: Int!
  strengthDefenceAway: Int!
  strengthDefenceHome: Int!
  strengthOverallAway: Int!
  strengthOverallHome: Int!
  teamDivision: Int
  homeFixtures: HomeTeamFixtureCreateManyWithoutHomeTeamInput
}

input TeamCreateWithoutHomeFixturesInput {
  id: ID
  code: Int!
  season: SeasonCreateOneInput!
  fplTeamId: Int!
  name: String!
  shortName: String!
  strength: Int!
  strengthAttackAway: Int!
  strengthAttackHome: Int!
  strengthDefenceAway: Int!
  strengthDefenceHome: Int!
  strengthOverallAway: Int!
  strengthOverallHome: Int!
  teamDivision: Int
  awayFixtures: AwayTeamFixtureCreateManyWithoutAwayTeamInput
}

type TeamEdge {
  node: Team!
  cursor: String!
}

enum TeamOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  fplTeamId_ASC
  fplTeamId_DESC
  name_ASC
  name_DESC
  shortName_ASC
  shortName_DESC
  strength_ASC
  strength_DESC
  strengthAttackAway_ASC
  strengthAttackAway_DESC
  strengthAttackHome_ASC
  strengthAttackHome_DESC
  strengthDefenceAway_ASC
  strengthDefenceAway_DESC
  strengthDefenceHome_ASC
  strengthDefenceHome_DESC
  strengthOverallAway_ASC
  strengthOverallAway_DESC
  strengthOverallHome_ASC
  strengthOverallHome_DESC
  teamDivision_ASC
  teamDivision_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TeamPreviousValues {
  id: ID!
  code: Int!
  fplTeamId: Int!
  name: String!
  shortName: String!
  strength: Int!
  strengthAttackAway: Int!
  strengthAttackHome: Int!
  strengthDefenceAway: Int!
  strengthDefenceHome: Int!
  strengthOverallAway: Int!
  strengthOverallHome: Int!
  teamDivision: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TeamSubscriptionPayload {
  mutation: MutationType!
  node: Team
  updatedFields: [String!]
  previousValues: TeamPreviousValues
}

input TeamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeamWhereInput
  AND: [TeamSubscriptionWhereInput!]
  OR: [TeamSubscriptionWhereInput!]
  NOT: [TeamSubscriptionWhereInput!]
}

input TeamUpdateDataInput {
  code: Int
  season: SeasonUpdateOneRequiredInput
  fplTeamId: Int
  name: String
  shortName: String
  strength: Int
  strengthAttackAway: Int
  strengthAttackHome: Int
  strengthDefenceAway: Int
  strengthDefenceHome: Int
  strengthOverallAway: Int
  strengthOverallHome: Int
  teamDivision: Int
  homeFixtures: HomeTeamFixtureUpdateManyWithoutHomeTeamInput
  awayFixtures: AwayTeamFixtureUpdateManyWithoutAwayTeamInput
}

input TeamUpdateInput {
  code: Int
  season: SeasonUpdateOneRequiredInput
  fplTeamId: Int
  name: String
  shortName: String
  strength: Int
  strengthAttackAway: Int
  strengthAttackHome: Int
  strengthDefenceAway: Int
  strengthDefenceHome: Int
  strengthOverallAway: Int
  strengthOverallHome: Int
  teamDivision: Int
  homeFixtures: HomeTeamFixtureUpdateManyWithoutHomeTeamInput
  awayFixtures: AwayTeamFixtureUpdateManyWithoutAwayTeamInput
}

input TeamUpdateManyMutationInput {
  code: Int
  fplTeamId: Int
  name: String
  shortName: String
  strength: Int
  strengthAttackAway: Int
  strengthAttackHome: Int
  strengthDefenceAway: Int
  strengthDefenceHome: Int
  strengthOverallAway: Int
  strengthOverallHome: Int
  teamDivision: Int
}

input TeamUpdateOneInput {
  create: TeamCreateInput
  update: TeamUpdateDataInput
  upsert: TeamUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneRequiredWithoutAwayFixturesInput {
  create: TeamCreateWithoutAwayFixturesInput
  update: TeamUpdateWithoutAwayFixturesDataInput
  upsert: TeamUpsertWithoutAwayFixturesInput
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneRequiredWithoutHomeFixturesInput {
  create: TeamCreateWithoutHomeFixturesInput
  update: TeamUpdateWithoutHomeFixturesDataInput
  upsert: TeamUpsertWithoutHomeFixturesInput
  connect: TeamWhereUniqueInput
}

input TeamUpdateWithoutAwayFixturesDataInput {
  code: Int
  season: SeasonUpdateOneRequiredInput
  fplTeamId: Int
  name: String
  shortName: String
  strength: Int
  strengthAttackAway: Int
  strengthAttackHome: Int
  strengthDefenceAway: Int
  strengthDefenceHome: Int
  strengthOverallAway: Int
  strengthOverallHome: Int
  teamDivision: Int
  homeFixtures: HomeTeamFixtureUpdateManyWithoutHomeTeamInput
}

input TeamUpdateWithoutHomeFixturesDataInput {
  code: Int
  season: SeasonUpdateOneRequiredInput
  fplTeamId: Int
  name: String
  shortName: String
  strength: Int
  strengthAttackAway: Int
  strengthAttackHome: Int
  strengthDefenceAway: Int
  strengthDefenceHome: Int
  strengthOverallAway: Int
  strengthOverallHome: Int
  teamDivision: Int
  awayFixtures: AwayTeamFixtureUpdateManyWithoutAwayTeamInput
}

input TeamUpsertNestedInput {
  update: TeamUpdateDataInput!
  create: TeamCreateInput!
}

input TeamUpsertWithoutAwayFixturesInput {
  update: TeamUpdateWithoutAwayFixturesDataInput!
  create: TeamCreateWithoutAwayFixturesInput!
}

input TeamUpsertWithoutHomeFixturesInput {
  update: TeamUpdateWithoutHomeFixturesDataInput!
  create: TeamCreateWithoutHomeFixturesInput!
}

input TeamWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: Int
  code_not: Int
  code_in: [Int!]
  code_not_in: [Int!]
  code_lt: Int
  code_lte: Int
  code_gt: Int
  code_gte: Int
  season: SeasonWhereInput
  fplTeamId: Int
  fplTeamId_not: Int
  fplTeamId_in: [Int!]
  fplTeamId_not_in: [Int!]
  fplTeamId_lt: Int
  fplTeamId_lte: Int
  fplTeamId_gt: Int
  fplTeamId_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  shortName: String
  shortName_not: String
  shortName_in: [String!]
  shortName_not_in: [String!]
  shortName_lt: String
  shortName_lte: String
  shortName_gt: String
  shortName_gte: String
  shortName_contains: String
  shortName_not_contains: String
  shortName_starts_with: String
  shortName_not_starts_with: String
  shortName_ends_with: String
  shortName_not_ends_with: String
  strength: Int
  strength_not: Int
  strength_in: [Int!]
  strength_not_in: [Int!]
  strength_lt: Int
  strength_lte: Int
  strength_gt: Int
  strength_gte: Int
  strengthAttackAway: Int
  strengthAttackAway_not: Int
  strengthAttackAway_in: [Int!]
  strengthAttackAway_not_in: [Int!]
  strengthAttackAway_lt: Int
  strengthAttackAway_lte: Int
  strengthAttackAway_gt: Int
  strengthAttackAway_gte: Int
  strengthAttackHome: Int
  strengthAttackHome_not: Int
  strengthAttackHome_in: [Int!]
  strengthAttackHome_not_in: [Int!]
  strengthAttackHome_lt: Int
  strengthAttackHome_lte: Int
  strengthAttackHome_gt: Int
  strengthAttackHome_gte: Int
  strengthDefenceAway: Int
  strengthDefenceAway_not: Int
  strengthDefenceAway_in: [Int!]
  strengthDefenceAway_not_in: [Int!]
  strengthDefenceAway_lt: Int
  strengthDefenceAway_lte: Int
  strengthDefenceAway_gt: Int
  strengthDefenceAway_gte: Int
  strengthDefenceHome: Int
  strengthDefenceHome_not: Int
  strengthDefenceHome_in: [Int!]
  strengthDefenceHome_not_in: [Int!]
  strengthDefenceHome_lt: Int
  strengthDefenceHome_lte: Int
  strengthDefenceHome_gt: Int
  strengthDefenceHome_gte: Int
  strengthOverallAway: Int
  strengthOverallAway_not: Int
  strengthOverallAway_in: [Int!]
  strengthOverallAway_not_in: [Int!]
  strengthOverallAway_lt: Int
  strengthOverallAway_lte: Int
  strengthOverallAway_gt: Int
  strengthOverallAway_gte: Int
  strengthOverallHome: Int
  strengthOverallHome_not: Int
  strengthOverallHome_in: [Int!]
  strengthOverallHome_not_in: [Int!]
  strengthOverallHome_lt: Int
  strengthOverallHome_lte: Int
  strengthOverallHome_gt: Int
  strengthOverallHome_gte: Int
  teamDivision: Int
  teamDivision_not: Int
  teamDivision_in: [Int!]
  teamDivision_not_in: [Int!]
  teamDivision_lt: Int
  teamDivision_lte: Int
  teamDivision_gt: Int
  teamDivision_gte: Int
  homeFixtures_every: HomeTeamFixtureWhereInput
  homeFixtures_some: HomeTeamFixtureWhereInput
  homeFixtures_none: HomeTeamFixtureWhereInput
  awayFixtures_every: AwayTeamFixtureWhereInput
  awayFixtures_some: AwayTeamFixtureWhereInput
  awayFixtures_none: AwayTeamFixtureWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  NOT: [TeamWhereInput!]
}

input TeamWhereUniqueInput {
  id: ID
  code: Int
}

type User {
  id: ID!
  email: String!
  name: String!
  countryCode: String
  phoneNumber: String
  favoriteTeam: Team
  country: Country
  displayName: String!
  isPrivate: Boolean!
  password: String!
  photos(where: UserPhotoWhereInput, orderBy: UserPhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserPhoto!]
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean!
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions(where: FandemSubscriptionWhereInput, orderBy: FandemSubscriptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FandemSubscription!]
  userRoles(where: UserRoleWhereInput, orderBy: UserRoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserRole!]
  status(where: UserStatusWhereInput, orderBy: UserStatusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserStatus!]
  followers: UserFollowers
  influencers: UserInfluencers
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserAssignedRole {
  id: ID!
  user: User!
  userRole: UserRole!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserAssignedRoleConnection {
  pageInfo: PageInfo!
  edges: [UserAssignedRoleEdge]!
  aggregate: AggregateUserAssignedRole!
}

input UserAssignedRoleCreateInput {
  id: ID
  user: UserCreateOneInput!
  userRole: UserRoleCreateOneInput!
}

type UserAssignedRoleEdge {
  node: UserAssignedRole!
  cursor: String!
}

enum UserAssignedRoleOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserAssignedRolePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserAssignedRoleSubscriptionPayload {
  mutation: MutationType!
  node: UserAssignedRole
  updatedFields: [String!]
  previousValues: UserAssignedRolePreviousValues
}

input UserAssignedRoleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserAssignedRoleWhereInput
  AND: [UserAssignedRoleSubscriptionWhereInput!]
  OR: [UserAssignedRoleSubscriptionWhereInput!]
  NOT: [UserAssignedRoleSubscriptionWhereInput!]
}

input UserAssignedRoleUpdateInput {
  user: UserUpdateOneRequiredInput
  userRole: UserRoleUpdateOneRequiredInput
}

input UserAssignedRoleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  userRole: UserRoleWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserAssignedRoleWhereInput!]
  OR: [UserAssignedRoleWhereInput!]
  NOT: [UserAssignedRoleWhereInput!]
}

input UserAssignedRoleWhereUniqueInput {
  id: ID
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  name: String!
  countryCode: String
  phoneNumber: String
  favoriteTeam: TeamCreateOneInput
  country: CountryCreateOneInput
  displayName: String!
  isPrivate: Boolean
  password: String!
  photos: UserPhotoCreateManyWithoutUserInput
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions: FandemSubscriptionCreateManyInput
  userRoles: UserRoleCreateManyInput
  status: UserStatusCreateManyInput
  followers: UserFollowersCreateOneWithoutUserInput
  influencers: UserInfluencersCreateOneWithoutUserInput
}

input UserCreateManyInput {
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutFollowersInput {
  create: UserCreateWithoutFollowersInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutInfluencersInput {
  create: UserCreateWithoutInfluencersInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPhotosInput {
  create: UserCreateWithoutPhotosInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutFollowersInput {
  id: ID
  email: String!
  name: String!
  countryCode: String
  phoneNumber: String
  favoriteTeam: TeamCreateOneInput
  country: CountryCreateOneInput
  displayName: String!
  isPrivate: Boolean
  password: String!
  photos: UserPhotoCreateManyWithoutUserInput
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions: FandemSubscriptionCreateManyInput
  userRoles: UserRoleCreateManyInput
  status: UserStatusCreateManyInput
  influencers: UserInfluencersCreateOneWithoutUserInput
}

input UserCreateWithoutInfluencersInput {
  id: ID
  email: String!
  name: String!
  countryCode: String
  phoneNumber: String
  favoriteTeam: TeamCreateOneInput
  country: CountryCreateOneInput
  displayName: String!
  isPrivate: Boolean
  password: String!
  photos: UserPhotoCreateManyWithoutUserInput
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions: FandemSubscriptionCreateManyInput
  userRoles: UserRoleCreateManyInput
  status: UserStatusCreateManyInput
  followers: UserFollowersCreateOneWithoutUserInput
}

input UserCreateWithoutPhotosInput {
  id: ID
  email: String!
  name: String!
  countryCode: String
  phoneNumber: String
  favoriteTeam: TeamCreateOneInput
  country: CountryCreateOneInput
  displayName: String!
  isPrivate: Boolean
  password: String!
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions: FandemSubscriptionCreateManyInput
  userRoles: UserRoleCreateManyInput
  status: UserStatusCreateManyInput
  followers: UserFollowersCreateOneWithoutUserInput
  influencers: UserInfluencersCreateOneWithoutUserInput
}

type UserEdge {
  node: User!
  cursor: String!
}

type UserFollowers {
  id: ID!
  followers(where: FollowerWhereInput, orderBy: FollowerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Follower!]
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserFollowersConnection {
  pageInfo: PageInfo!
  edges: [UserFollowersEdge]!
  aggregate: AggregateUserFollowers!
}

input UserFollowersCreateInput {
  id: ID
  followers: FollowerCreateManyInput
  user: UserCreateOneWithoutFollowersInput!
}

input UserFollowersCreateOneWithoutUserInput {
  create: UserFollowersCreateWithoutUserInput
  connect: UserFollowersWhereUniqueInput
}

input UserFollowersCreateWithoutUserInput {
  id: ID
  followers: FollowerCreateManyInput
}

type UserFollowersEdge {
  node: UserFollowers!
  cursor: String!
}

enum UserFollowersOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserFollowersPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserFollowersSubscriptionPayload {
  mutation: MutationType!
  node: UserFollowers
  updatedFields: [String!]
  previousValues: UserFollowersPreviousValues
}

input UserFollowersSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserFollowersWhereInput
  AND: [UserFollowersSubscriptionWhereInput!]
  OR: [UserFollowersSubscriptionWhereInput!]
  NOT: [UserFollowersSubscriptionWhereInput!]
}

input UserFollowersUpdateInput {
  followers: FollowerUpdateManyInput
  user: UserUpdateOneRequiredWithoutFollowersInput
}

input UserFollowersUpdateOneWithoutUserInput {
  create: UserFollowersCreateWithoutUserInput
  update: UserFollowersUpdateWithoutUserDataInput
  upsert: UserFollowersUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  connect: UserFollowersWhereUniqueInput
}

input UserFollowersUpdateWithoutUserDataInput {
  followers: FollowerUpdateManyInput
}

input UserFollowersUpsertWithoutUserInput {
  update: UserFollowersUpdateWithoutUserDataInput!
  create: UserFollowersCreateWithoutUserInput!
}

input UserFollowersWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  followers_every: FollowerWhereInput
  followers_some: FollowerWhereInput
  followers_none: FollowerWhereInput
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserFollowersWhereInput!]
  OR: [UserFollowersWhereInput!]
  NOT: [UserFollowersWhereInput!]
}

input UserFollowersWhereUniqueInput {
  id: ID
}

type UserInfluencers {
  id: ID!
  user: User!
  influencers(where: InfluencerWhereInput, orderBy: InfluencerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Influencer!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserInfluencersConnection {
  pageInfo: PageInfo!
  edges: [UserInfluencersEdge]!
  aggregate: AggregateUserInfluencers!
}

input UserInfluencersCreateInput {
  id: ID
  user: UserCreateOneWithoutInfluencersInput!
  influencers: InfluencerCreateManyInput
}

input UserInfluencersCreateOneWithoutUserInput {
  create: UserInfluencersCreateWithoutUserInput
  connect: UserInfluencersWhereUniqueInput
}

input UserInfluencersCreateWithoutUserInput {
  id: ID
  influencers: InfluencerCreateManyInput
}

type UserInfluencersEdge {
  node: UserInfluencers!
  cursor: String!
}

enum UserInfluencersOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserInfluencersPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserInfluencersSubscriptionPayload {
  mutation: MutationType!
  node: UserInfluencers
  updatedFields: [String!]
  previousValues: UserInfluencersPreviousValues
}

input UserInfluencersSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserInfluencersWhereInput
  AND: [UserInfluencersSubscriptionWhereInput!]
  OR: [UserInfluencersSubscriptionWhereInput!]
  NOT: [UserInfluencersSubscriptionWhereInput!]
}

input UserInfluencersUpdateInput {
  user: UserUpdateOneRequiredWithoutInfluencersInput
  influencers: InfluencerUpdateManyInput
}

input UserInfluencersUpdateOneWithoutUserInput {
  create: UserInfluencersCreateWithoutUserInput
  update: UserInfluencersUpdateWithoutUserDataInput
  upsert: UserInfluencersUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  connect: UserInfluencersWhereUniqueInput
}

input UserInfluencersUpdateWithoutUserDataInput {
  influencers: InfluencerUpdateManyInput
}

input UserInfluencersUpsertWithoutUserInput {
  update: UserInfluencersUpdateWithoutUserDataInput!
  create: UserInfluencersCreateWithoutUserInput!
}

input UserInfluencersWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  influencers_every: InfluencerWhereInput
  influencers_some: InfluencerWhereInput
  influencers_none: InfluencerWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserInfluencersWhereInput!]
  OR: [UserInfluencersWhereInput!]
  NOT: [UserInfluencersWhereInput!]
}

input UserInfluencersWhereUniqueInput {
  id: ID
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  name_ASC
  name_DESC
  countryCode_ASC
  countryCode_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  displayName_ASC
  displayName_DESC
  isPrivate_ASC
  isPrivate_DESC
  password_ASC
  password_DESC
  emailValidationToken_ASC
  emailValidationToken_DESC
  emailValidationTokenExpiry_ASC
  emailValidationTokenExpiry_DESC
  emailValidated_ASC
  emailValidated_DESC
  emailValidationDate_ASC
  emailValidationDate_DESC
  resetToken_ASC
  resetToken_DESC
  resetTokenExpiry_ASC
  resetTokenExpiry_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPhoto {
  id: ID!
  user: User!
  photo: Photo!
  isProfile: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserPhotoConnection {
  pageInfo: PageInfo!
  edges: [UserPhotoEdge]!
  aggregate: AggregateUserPhoto!
}

input UserPhotoCreateInput {
  id: ID
  user: UserCreateOneWithoutPhotosInput!
  photo: PhotoCreateOneInput!
  isProfile: Boolean
}

input UserPhotoCreateManyWithoutUserInput {
  create: [UserPhotoCreateWithoutUserInput!]
  connect: [UserPhotoWhereUniqueInput!]
}

input UserPhotoCreateWithoutUserInput {
  id: ID
  photo: PhotoCreateOneInput!
  isProfile: Boolean
}

type UserPhotoEdge {
  node: UserPhoto!
  cursor: String!
}

enum UserPhotoOrderByInput {
  id_ASC
  id_DESC
  isProfile_ASC
  isProfile_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPhotoPreviousValues {
  id: ID!
  isProfile: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input UserPhotoScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  isProfile: Boolean
  isProfile_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserPhotoScalarWhereInput!]
  OR: [UserPhotoScalarWhereInput!]
  NOT: [UserPhotoScalarWhereInput!]
}

type UserPhotoSubscriptionPayload {
  mutation: MutationType!
  node: UserPhoto
  updatedFields: [String!]
  previousValues: UserPhotoPreviousValues
}

input UserPhotoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserPhotoWhereInput
  AND: [UserPhotoSubscriptionWhereInput!]
  OR: [UserPhotoSubscriptionWhereInput!]
  NOT: [UserPhotoSubscriptionWhereInput!]
}

input UserPhotoUpdateInput {
  user: UserUpdateOneRequiredWithoutPhotosInput
  photo: PhotoUpdateOneRequiredInput
  isProfile: Boolean
}

input UserPhotoUpdateManyDataInput {
  isProfile: Boolean
}

input UserPhotoUpdateManyMutationInput {
  isProfile: Boolean
}

input UserPhotoUpdateManyWithoutUserInput {
  create: [UserPhotoCreateWithoutUserInput!]
  delete: [UserPhotoWhereUniqueInput!]
  connect: [UserPhotoWhereUniqueInput!]
  set: [UserPhotoWhereUniqueInput!]
  disconnect: [UserPhotoWhereUniqueInput!]
  update: [UserPhotoUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [UserPhotoUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [UserPhotoScalarWhereInput!]
  updateMany: [UserPhotoUpdateManyWithWhereNestedInput!]
}

input UserPhotoUpdateManyWithWhereNestedInput {
  where: UserPhotoScalarWhereInput!
  data: UserPhotoUpdateManyDataInput!
}

input UserPhotoUpdateWithoutUserDataInput {
  photo: PhotoUpdateOneRequiredInput
  isProfile: Boolean
}

input UserPhotoUpdateWithWhereUniqueWithoutUserInput {
  where: UserPhotoWhereUniqueInput!
  data: UserPhotoUpdateWithoutUserDataInput!
}

input UserPhotoUpsertWithWhereUniqueWithoutUserInput {
  where: UserPhotoWhereUniqueInput!
  update: UserPhotoUpdateWithoutUserDataInput!
  create: UserPhotoCreateWithoutUserInput!
}

input UserPhotoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  photo: PhotoWhereInput
  isProfile: Boolean
  isProfile_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserPhotoWhereInput!]
  OR: [UserPhotoWhereInput!]
  NOT: [UserPhotoWhereInput!]
}

input UserPhotoWhereUniqueInput {
  id: ID
}

type UserPreviousValues {
  id: ID!
  email: String!
  name: String!
  countryCode: String
  phoneNumber: String
  displayName: String!
  isPrivate: Boolean!
  password: String!
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean!
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserRole {
  id: ID!
  name: String!
  description: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserRoleConnection {
  pageInfo: PageInfo!
  edges: [UserRoleEdge]!
  aggregate: AggregateUserRole!
}

input UserRoleCreateInput {
  id: ID
  name: String!
  description: String!
}

input UserRoleCreateManyInput {
  create: [UserRoleCreateInput!]
  connect: [UserRoleWhereUniqueInput!]
}

input UserRoleCreateOneInput {
  create: UserRoleCreateInput
  connect: UserRoleWhereUniqueInput
}

type UserRoleEdge {
  node: UserRole!
  cursor: String!
}

enum UserRoleOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserRolePreviousValues {
  id: ID!
  name: String!
  description: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input UserRoleScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserRoleScalarWhereInput!]
  OR: [UserRoleScalarWhereInput!]
  NOT: [UserRoleScalarWhereInput!]
}

type UserRoleSubscriptionPayload {
  mutation: MutationType!
  node: UserRole
  updatedFields: [String!]
  previousValues: UserRolePreviousValues
}

input UserRoleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserRoleWhereInput
  AND: [UserRoleSubscriptionWhereInput!]
  OR: [UserRoleSubscriptionWhereInput!]
  NOT: [UserRoleSubscriptionWhereInput!]
}

input UserRoleUpdateDataInput {
  name: String
  description: String
}

input UserRoleUpdateInput {
  name: String
  description: String
}

input UserRoleUpdateManyDataInput {
  name: String
  description: String
}

input UserRoleUpdateManyInput {
  create: [UserRoleCreateInput!]
  update: [UserRoleUpdateWithWhereUniqueNestedInput!]
  upsert: [UserRoleUpsertWithWhereUniqueNestedInput!]
  delete: [UserRoleWhereUniqueInput!]
  connect: [UserRoleWhereUniqueInput!]
  set: [UserRoleWhereUniqueInput!]
  disconnect: [UserRoleWhereUniqueInput!]
  deleteMany: [UserRoleScalarWhereInput!]
  updateMany: [UserRoleUpdateManyWithWhereNestedInput!]
}

input UserRoleUpdateManyMutationInput {
  name: String
  description: String
}

input UserRoleUpdateManyWithWhereNestedInput {
  where: UserRoleScalarWhereInput!
  data: UserRoleUpdateManyDataInput!
}

input UserRoleUpdateOneRequiredInput {
  create: UserRoleCreateInput
  update: UserRoleUpdateDataInput
  upsert: UserRoleUpsertNestedInput
  connect: UserRoleWhereUniqueInput
}

input UserRoleUpdateWithWhereUniqueNestedInput {
  where: UserRoleWhereUniqueInput!
  data: UserRoleUpdateDataInput!
}

input UserRoleUpsertNestedInput {
  update: UserRoleUpdateDataInput!
  create: UserRoleCreateInput!
}

input UserRoleUpsertWithWhereUniqueNestedInput {
  where: UserRoleWhereUniqueInput!
  update: UserRoleUpdateDataInput!
  create: UserRoleCreateInput!
}

input UserRoleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserRoleWhereInput!]
  OR: [UserRoleWhereInput!]
  NOT: [UserRoleWhereInput!]
}

input UserRoleWhereUniqueInput {
  id: ID
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  countryCode: String
  countryCode_not: String
  countryCode_in: [String!]
  countryCode_not_in: [String!]
  countryCode_lt: String
  countryCode_lte: String
  countryCode_gt: String
  countryCode_gte: String
  countryCode_contains: String
  countryCode_not_contains: String
  countryCode_starts_with: String
  countryCode_not_starts_with: String
  countryCode_ends_with: String
  countryCode_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  displayName: String
  displayName_not: String
  displayName_in: [String!]
  displayName_not_in: [String!]
  displayName_lt: String
  displayName_lte: String
  displayName_gt: String
  displayName_gte: String
  displayName_contains: String
  displayName_not_contains: String
  displayName_starts_with: String
  displayName_not_starts_with: String
  displayName_ends_with: String
  displayName_not_ends_with: String
  isPrivate: Boolean
  isPrivate_not: Boolean
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  emailValidationToken: String
  emailValidationToken_not: String
  emailValidationToken_in: [String!]
  emailValidationToken_not_in: [String!]
  emailValidationToken_lt: String
  emailValidationToken_lte: String
  emailValidationToken_gt: String
  emailValidationToken_gte: String
  emailValidationToken_contains: String
  emailValidationToken_not_contains: String
  emailValidationToken_starts_with: String
  emailValidationToken_not_starts_with: String
  emailValidationToken_ends_with: String
  emailValidationToken_not_ends_with: String
  emailValidationTokenExpiry: Float
  emailValidationTokenExpiry_not: Float
  emailValidationTokenExpiry_in: [Float!]
  emailValidationTokenExpiry_not_in: [Float!]
  emailValidationTokenExpiry_lt: Float
  emailValidationTokenExpiry_lte: Float
  emailValidationTokenExpiry_gt: Float
  emailValidationTokenExpiry_gte: Float
  emailValidated: Boolean
  emailValidated_not: Boolean
  emailValidationDate: DateTime
  emailValidationDate_not: DateTime
  emailValidationDate_in: [DateTime!]
  emailValidationDate_not_in: [DateTime!]
  emailValidationDate_lt: DateTime
  emailValidationDate_lte: DateTime
  emailValidationDate_gt: DateTime
  emailValidationDate_gte: DateTime
  resetToken: String
  resetToken_not: String
  resetToken_in: [String!]
  resetToken_not_in: [String!]
  resetToken_lt: String
  resetToken_lte: String
  resetToken_gt: String
  resetToken_gte: String
  resetToken_contains: String
  resetToken_not_contains: String
  resetToken_starts_with: String
  resetToken_not_starts_with: String
  resetToken_ends_with: String
  resetToken_not_ends_with: String
  resetTokenExpiry: Float
  resetTokenExpiry_not: Float
  resetTokenExpiry_in: [Float!]
  resetTokenExpiry_not_in: [Float!]
  resetTokenExpiry_lt: Float
  resetTokenExpiry_lte: Float
  resetTokenExpiry_gt: Float
  resetTokenExpiry_gte: Float
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserStatus {
  id: ID!
  status: Status
  currentStatus: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserStatusConnection {
  pageInfo: PageInfo!
  edges: [UserStatusEdge]!
  aggregate: AggregateUserStatus!
}

input UserStatusCreateInput {
  id: ID
  status: StatusCreateOneWithoutAuthorInput
  currentStatus: Boolean
}

input UserStatusCreateManyInput {
  create: [UserStatusCreateInput!]
  connect: [UserStatusWhereUniqueInput!]
}

input UserStatusCreateOneWithoutStatusInput {
  create: UserStatusCreateWithoutStatusInput
  connect: UserStatusWhereUniqueInput
}

input UserStatusCreateWithoutStatusInput {
  id: ID
  currentStatus: Boolean
}

type UserStatusEdge {
  node: UserStatus!
  cursor: String!
}

enum UserStatusOrderByInput {
  id_ASC
  id_DESC
  currentStatus_ASC
  currentStatus_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserStatusPreviousValues {
  id: ID!
  currentStatus: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input UserStatusScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  currentStatus: Boolean
  currentStatus_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserStatusScalarWhereInput!]
  OR: [UserStatusScalarWhereInput!]
  NOT: [UserStatusScalarWhereInput!]
}

type UserStatusSubscriptionPayload {
  mutation: MutationType!
  node: UserStatus
  updatedFields: [String!]
  previousValues: UserStatusPreviousValues
}

input UserStatusSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserStatusWhereInput
  AND: [UserStatusSubscriptionWhereInput!]
  OR: [UserStatusSubscriptionWhereInput!]
  NOT: [UserStatusSubscriptionWhereInput!]
}

input UserStatusUpdateDataInput {
  status: StatusUpdateOneWithoutAuthorInput
  currentStatus: Boolean
}

input UserStatusUpdateInput {
  status: StatusUpdateOneWithoutAuthorInput
  currentStatus: Boolean
}

input UserStatusUpdateManyDataInput {
  currentStatus: Boolean
}

input UserStatusUpdateManyInput {
  create: [UserStatusCreateInput!]
  update: [UserStatusUpdateWithWhereUniqueNestedInput!]
  upsert: [UserStatusUpsertWithWhereUniqueNestedInput!]
  delete: [UserStatusWhereUniqueInput!]
  connect: [UserStatusWhereUniqueInput!]
  set: [UserStatusWhereUniqueInput!]
  disconnect: [UserStatusWhereUniqueInput!]
  deleteMany: [UserStatusScalarWhereInput!]
  updateMany: [UserStatusUpdateManyWithWhereNestedInput!]
}

input UserStatusUpdateManyMutationInput {
  currentStatus: Boolean
}

input UserStatusUpdateManyWithWhereNestedInput {
  where: UserStatusScalarWhereInput!
  data: UserStatusUpdateManyDataInput!
}

input UserStatusUpdateOneWithoutStatusInput {
  create: UserStatusCreateWithoutStatusInput
  update: UserStatusUpdateWithoutStatusDataInput
  upsert: UserStatusUpsertWithoutStatusInput
  delete: Boolean
  disconnect: Boolean
  connect: UserStatusWhereUniqueInput
}

input UserStatusUpdateWithoutStatusDataInput {
  currentStatus: Boolean
}

input UserStatusUpdateWithWhereUniqueNestedInput {
  where: UserStatusWhereUniqueInput!
  data: UserStatusUpdateDataInput!
}

input UserStatusUpsertWithoutStatusInput {
  update: UserStatusUpdateWithoutStatusDataInput!
  create: UserStatusCreateWithoutStatusInput!
}

input UserStatusUpsertWithWhereUniqueNestedInput {
  where: UserStatusWhereUniqueInput!
  update: UserStatusUpdateDataInput!
  create: UserStatusCreateInput!
}

input UserStatusWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: StatusWhereInput
  currentStatus: Boolean
  currentStatus_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserStatusWhereInput!]
  OR: [UserStatusWhereInput!]
  NOT: [UserStatusWhereInput!]
}

input UserStatusWhereUniqueInput {
  id: ID
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  email: String
  name: String
  countryCode: String
  phoneNumber: String
  favoriteTeam: TeamUpdateOneInput
  country: CountryUpdateOneInput
  displayName: String
  isPrivate: Boolean
  password: String
  photos: UserPhotoUpdateManyWithoutUserInput
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions: FandemSubscriptionUpdateManyInput
  userRoles: UserRoleUpdateManyInput
  status: UserStatusUpdateManyInput
  followers: UserFollowersUpdateOneWithoutUserInput
  influencers: UserInfluencersUpdateOneWithoutUserInput
}

input UserUpdateInput {
  email: String
  name: String
  countryCode: String
  phoneNumber: String
  favoriteTeam: TeamUpdateOneInput
  country: CountryUpdateOneInput
  displayName: String
  isPrivate: Boolean
  password: String
  photos: UserPhotoUpdateManyWithoutUserInput
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions: FandemSubscriptionUpdateManyInput
  userRoles: UserRoleUpdateManyInput
  status: UserStatusUpdateManyInput
  followers: UserFollowersUpdateOneWithoutUserInput
  influencers: UserInfluencersUpdateOneWithoutUserInput
}

input UserUpdateManyDataInput {
  email: String
  name: String
  countryCode: String
  phoneNumber: String
  displayName: String
  isPrivate: Boolean
  password: String
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
}

input UserUpdateManyInput {
  create: [UserCreateInput!]
  update: [UserUpdateWithWhereUniqueNestedInput!]
  upsert: [UserUpsertWithWhereUniqueNestedInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyMutationInput {
  email: String
  name: String
  countryCode: String
  phoneNumber: String
  displayName: String
  isPrivate: Boolean
  password: String
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutFollowersInput {
  create: UserCreateWithoutFollowersInput
  update: UserUpdateWithoutFollowersDataInput
  upsert: UserUpsertWithoutFollowersInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutInfluencersInput {
  create: UserCreateWithoutInfluencersInput
  update: UserUpdateWithoutInfluencersDataInput
  upsert: UserUpsertWithoutInfluencersInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPhotosInput {
  create: UserCreateWithoutPhotosInput
  update: UserUpdateWithoutPhotosDataInput
  upsert: UserUpsertWithoutPhotosInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutFollowersDataInput {
  email: String
  name: String
  countryCode: String
  phoneNumber: String
  favoriteTeam: TeamUpdateOneInput
  country: CountryUpdateOneInput
  displayName: String
  isPrivate: Boolean
  password: String
  photos: UserPhotoUpdateManyWithoutUserInput
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions: FandemSubscriptionUpdateManyInput
  userRoles: UserRoleUpdateManyInput
  status: UserStatusUpdateManyInput
  influencers: UserInfluencersUpdateOneWithoutUserInput
}

input UserUpdateWithoutInfluencersDataInput {
  email: String
  name: String
  countryCode: String
  phoneNumber: String
  favoriteTeam: TeamUpdateOneInput
  country: CountryUpdateOneInput
  displayName: String
  isPrivate: Boolean
  password: String
  photos: UserPhotoUpdateManyWithoutUserInput
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions: FandemSubscriptionUpdateManyInput
  userRoles: UserRoleUpdateManyInput
  status: UserStatusUpdateManyInput
  followers: UserFollowersUpdateOneWithoutUserInput
}

input UserUpdateWithoutPhotosDataInput {
  email: String
  name: String
  countryCode: String
  phoneNumber: String
  favoriteTeam: TeamUpdateOneInput
  country: CountryUpdateOneInput
  displayName: String
  isPrivate: Boolean
  password: String
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions: FandemSubscriptionUpdateManyInput
  userRoles: UserRoleUpdateManyInput
  status: UserStatusUpdateManyInput
  followers: UserFollowersUpdateOneWithoutUserInput
  influencers: UserInfluencersUpdateOneWithoutUserInput
}

input UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  data: UserUpdateDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutFollowersInput {
  update: UserUpdateWithoutFollowersDataInput!
  create: UserCreateWithoutFollowersInput!
}

input UserUpsertWithoutInfluencersInput {
  update: UserUpdateWithoutInfluencersDataInput!
  create: UserCreateWithoutInfluencersInput!
}

input UserUpsertWithoutPhotosInput {
  update: UserUpdateWithoutPhotosDataInput!
  create: UserCreateWithoutPhotosInput!
}

input UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  countryCode: String
  countryCode_not: String
  countryCode_in: [String!]
  countryCode_not_in: [String!]
  countryCode_lt: String
  countryCode_lte: String
  countryCode_gt: String
  countryCode_gte: String
  countryCode_contains: String
  countryCode_not_contains: String
  countryCode_starts_with: String
  countryCode_not_starts_with: String
  countryCode_ends_with: String
  countryCode_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  favoriteTeam: TeamWhereInput
  country: CountryWhereInput
  displayName: String
  displayName_not: String
  displayName_in: [String!]
  displayName_not_in: [String!]
  displayName_lt: String
  displayName_lte: String
  displayName_gt: String
  displayName_gte: String
  displayName_contains: String
  displayName_not_contains: String
  displayName_starts_with: String
  displayName_not_starts_with: String
  displayName_ends_with: String
  displayName_not_ends_with: String
  isPrivate: Boolean
  isPrivate_not: Boolean
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  photos_every: UserPhotoWhereInput
  photos_some: UserPhotoWhereInput
  photos_none: UserPhotoWhereInput
  emailValidationToken: String
  emailValidationToken_not: String
  emailValidationToken_in: [String!]
  emailValidationToken_not_in: [String!]
  emailValidationToken_lt: String
  emailValidationToken_lte: String
  emailValidationToken_gt: String
  emailValidationToken_gte: String
  emailValidationToken_contains: String
  emailValidationToken_not_contains: String
  emailValidationToken_starts_with: String
  emailValidationToken_not_starts_with: String
  emailValidationToken_ends_with: String
  emailValidationToken_not_ends_with: String
  emailValidationTokenExpiry: Float
  emailValidationTokenExpiry_not: Float
  emailValidationTokenExpiry_in: [Float!]
  emailValidationTokenExpiry_not_in: [Float!]
  emailValidationTokenExpiry_lt: Float
  emailValidationTokenExpiry_lte: Float
  emailValidationTokenExpiry_gt: Float
  emailValidationTokenExpiry_gte: Float
  emailValidated: Boolean
  emailValidated_not: Boolean
  emailValidationDate: DateTime
  emailValidationDate_not: DateTime
  emailValidationDate_in: [DateTime!]
  emailValidationDate_not_in: [DateTime!]
  emailValidationDate_lt: DateTime
  emailValidationDate_lte: DateTime
  emailValidationDate_gt: DateTime
  emailValidationDate_gte: DateTime
  resetToken: String
  resetToken_not: String
  resetToken_in: [String!]
  resetToken_not_in: [String!]
  resetToken_lt: String
  resetToken_lte: String
  resetToken_gt: String
  resetToken_gte: String
  resetToken_contains: String
  resetToken_not_contains: String
  resetToken_starts_with: String
  resetToken_not_starts_with: String
  resetToken_ends_with: String
  resetToken_not_ends_with: String
  resetTokenExpiry: Float
  resetTokenExpiry_not: Float
  resetTokenExpiry_in: [Float!]
  resetTokenExpiry_not_in: [Float!]
  resetTokenExpiry_lt: Float
  resetTokenExpiry_lte: Float
  resetTokenExpiry_gt: Float
  resetTokenExpiry_gte: Float
  subscriptions_every: FandemSubscriptionWhereInput
  subscriptions_some: FandemSubscriptionWhereInput
  subscriptions_none: FandemSubscriptionWhereInput
  userRoles_every: UserRoleWhereInput
  userRoles_some: UserRoleWhereInput
  userRoles_none: UserRoleWhereInput
  status_every: UserStatusWhereInput
  status_some: UserStatusWhereInput
  status_none: UserStatusWhereInput
  followers: UserFollowersWhereInput
  influencers: UserInfluencersWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
  displayName: String
}
`
      }
    