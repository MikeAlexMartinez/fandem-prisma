module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type ActiveSubscriptions {
  id: ID!
  user: User!
  subscription: UserRole!
  startDate: DateTime!
  endDate: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ActiveSubscriptionsConnection {
  pageInfo: PageInfo!
  edges: [ActiveSubscriptionsEdge]!
  aggregate: AggregateActiveSubscriptions!
}

input ActiveSubscriptionsCreateInput {
  id: ID
  user: UserCreateOneInput!
  subscription: UserRoleCreateOneInput!
  startDate: DateTime!
  endDate: DateTime!
}

type ActiveSubscriptionsEdge {
  node: ActiveSubscriptions!
  cursor: String!
}

enum ActiveSubscriptionsOrderByInput {
  id_ASC
  id_DESC
  startDate_ASC
  startDate_DESC
  endDate_ASC
  endDate_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ActiveSubscriptionsPreviousValues {
  id: ID!
  startDate: DateTime!
  endDate: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ActiveSubscriptionsSubscriptionPayload {
  mutation: MutationType!
  node: ActiveSubscriptions
  updatedFields: [String!]
  previousValues: ActiveSubscriptionsPreviousValues
}

input ActiveSubscriptionsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ActiveSubscriptionsWhereInput
  AND: [ActiveSubscriptionsSubscriptionWhereInput!]
  OR: [ActiveSubscriptionsSubscriptionWhereInput!]
  NOT: [ActiveSubscriptionsSubscriptionWhereInput!]
}

input ActiveSubscriptionsUpdateInput {
  user: UserUpdateOneRequiredInput
  subscription: UserRoleUpdateOneRequiredInput
  startDate: DateTime
  endDate: DateTime
}

input ActiveSubscriptionsUpdateManyMutationInput {
  startDate: DateTime
  endDate: DateTime
}

input ActiveSubscriptionsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  subscription: UserRoleWhereInput
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ActiveSubscriptionsWhereInput!]
  OR: [ActiveSubscriptionsWhereInput!]
  NOT: [ActiveSubscriptionsWhereInput!]
}

input ActiveSubscriptionsWhereUniqueInput {
  id: ID
}

type AggregateActiveSubscriptions {
  count: Int!
}

type AggregateAwayTeamFixture {
  count: Int!
}

type AggregateContest {
  count: Int!
}

type AggregateContestCreator {
  count: Int!
}

type AggregateContestInviter {
  count: Int!
}

type AggregateContestOwner {
  count: Int!
}

type AggregateContestPrediction {
  count: Int!
}

type AggregateContestPredictionScore {
  count: Int!
}

type AggregateContestSlate {
  count: Int!
}

type AggregateContestSlateEntry {
  count: Int!
}

type AggregateContestType {
  count: Int!
}

type AggregateContestUser {
  count: Int!
}

type AggregateContestUserType {
  count: Int!
}

type AggregateCountry {
  count: Int!
}

type AggregateDefaultScoringSystemDetail {
  count: Int!
}

type AggregateDefaultScoringSystemHeader {
  count: Int!
}

type AggregateFandemSubscription {
  count: Int!
}

type AggregateFixture {
  count: Int!
}

type AggregateFollower {
  count: Int!
}

type AggregateGameweek {
  count: Int!
}

type AggregateHomeTeamFixture {
  count: Int!
}

type AggregateInfluencer {
  count: Int!
}

type AggregatePhoto {
  count: Int!
}

type AggregateScoringSystemDetail {
  count: Int!
}

type AggregateScoringSystemHeader {
  count: Int!
}

type AggregateScoringType {
  count: Int!
}

type AggregateSeason {
  count: Int!
}

type AggregateStatus {
  count: Int!
}

type AggregateTeam {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateUserAssignedRole {
  count: Int!
}

type AggregateUserFollowers {
  count: Int!
}

type AggregateUserInfluencers {
  count: Int!
}

type AggregateUserPhoto {
  count: Int!
}

type AggregateUserRole {
  count: Int!
}

type AggregateUserStatus {
  count: Int!
}

type AwayTeamFixture {
  id: ID!
  fixture: Fixture!
  awayTeam: Team!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AwayTeamFixtureConnection {
  pageInfo: PageInfo!
  edges: [AwayTeamFixtureEdge]!
  aggregate: AggregateAwayTeamFixture!
}

input AwayTeamFixtureCreateInput {
  id: ID
  fixture: FixtureCreateOneWithoutTeamAInput!
  awayTeam: TeamCreateOneWithoutAwayFixturesInput!
}

input AwayTeamFixtureCreateManyWithoutAwayTeamInput {
  create: [AwayTeamFixtureCreateWithoutAwayTeamInput!]
  connect: [AwayTeamFixtureWhereUniqueInput!]
}

input AwayTeamFixtureCreateOneWithoutFixtureInput {
  create: AwayTeamFixtureCreateWithoutFixtureInput
  connect: AwayTeamFixtureWhereUniqueInput
}

input AwayTeamFixtureCreateWithoutAwayTeamInput {
  id: ID
  fixture: FixtureCreateOneWithoutTeamAInput!
}

input AwayTeamFixtureCreateWithoutFixtureInput {
  id: ID
  awayTeam: TeamCreateOneWithoutAwayFixturesInput!
}

type AwayTeamFixtureEdge {
  node: AwayTeamFixture!
  cursor: String!
}

enum AwayTeamFixtureOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AwayTeamFixturePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AwayTeamFixtureScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AwayTeamFixtureScalarWhereInput!]
  OR: [AwayTeamFixtureScalarWhereInput!]
  NOT: [AwayTeamFixtureScalarWhereInput!]
}

type AwayTeamFixtureSubscriptionPayload {
  mutation: MutationType!
  node: AwayTeamFixture
  updatedFields: [String!]
  previousValues: AwayTeamFixturePreviousValues
}

input AwayTeamFixtureSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AwayTeamFixtureWhereInput
  AND: [AwayTeamFixtureSubscriptionWhereInput!]
  OR: [AwayTeamFixtureSubscriptionWhereInput!]
  NOT: [AwayTeamFixtureSubscriptionWhereInput!]
}

input AwayTeamFixtureUpdateInput {
  fixture: FixtureUpdateOneRequiredWithoutTeamAInput
  awayTeam: TeamUpdateOneRequiredWithoutAwayFixturesInput
}

input AwayTeamFixtureUpdateManyWithoutAwayTeamInput {
  create: [AwayTeamFixtureCreateWithoutAwayTeamInput!]
  delete: [AwayTeamFixtureWhereUniqueInput!]
  connect: [AwayTeamFixtureWhereUniqueInput!]
  set: [AwayTeamFixtureWhereUniqueInput!]
  disconnect: [AwayTeamFixtureWhereUniqueInput!]
  update: [AwayTeamFixtureUpdateWithWhereUniqueWithoutAwayTeamInput!]
  upsert: [AwayTeamFixtureUpsertWithWhereUniqueWithoutAwayTeamInput!]
  deleteMany: [AwayTeamFixtureScalarWhereInput!]
}

input AwayTeamFixtureUpdateOneRequiredWithoutFixtureInput {
  create: AwayTeamFixtureCreateWithoutFixtureInput
  update: AwayTeamFixtureUpdateWithoutFixtureDataInput
  upsert: AwayTeamFixtureUpsertWithoutFixtureInput
  connect: AwayTeamFixtureWhereUniqueInput
}

input AwayTeamFixtureUpdateWithoutAwayTeamDataInput {
  fixture: FixtureUpdateOneRequiredWithoutTeamAInput
}

input AwayTeamFixtureUpdateWithoutFixtureDataInput {
  awayTeam: TeamUpdateOneRequiredWithoutAwayFixturesInput
}

input AwayTeamFixtureUpdateWithWhereUniqueWithoutAwayTeamInput {
  where: AwayTeamFixtureWhereUniqueInput!
  data: AwayTeamFixtureUpdateWithoutAwayTeamDataInput!
}

input AwayTeamFixtureUpsertWithoutFixtureInput {
  update: AwayTeamFixtureUpdateWithoutFixtureDataInput!
  create: AwayTeamFixtureCreateWithoutFixtureInput!
}

input AwayTeamFixtureUpsertWithWhereUniqueWithoutAwayTeamInput {
  where: AwayTeamFixtureWhereUniqueInput!
  update: AwayTeamFixtureUpdateWithoutAwayTeamDataInput!
  create: AwayTeamFixtureCreateWithoutAwayTeamInput!
}

input AwayTeamFixtureWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fixture: FixtureWhereInput
  awayTeam: TeamWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AwayTeamFixtureWhereInput!]
  OR: [AwayTeamFixtureWhereInput!]
  NOT: [AwayTeamFixtureWhereInput!]
}

input AwayTeamFixtureWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Contest {
  id: ID!
  contestName: String!
  isActive: Boolean!
  isDefault: Boolean!
  isAll: Boolean!
  isPublic: Boolean!
  invitationCode: String!
  startDate: DateTime!
  endDate: DateTime
  isPremium: Boolean!
  playerLimit: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  createdBy: ContestCreator!
  currentOwner: ContestOwner!
  contestType: ContestType!
  scoringSystem: ScoringSystemHeader!
  users(where: ContestUserWhereInput, orderBy: ContestUserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContestUser!]
  contestSlates(where: ContestSlateWhereInput, orderBy: ContestSlateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContestSlate!]
}

type ContestConnection {
  pageInfo: PageInfo!
  edges: [ContestEdge]!
  aggregate: AggregateContest!
}

input ContestCreateInput {
  id: ID
  contestName: String!
  isActive: Boolean
  isDefault: Boolean
  isAll: Boolean
  isPublic: Boolean!
  invitationCode: String!
  startDate: DateTime!
  endDate: DateTime
  isPremium: Boolean
  playerLimit: Int
  createdBy: ContestCreatorCreateOneInput!
  currentOwner: ContestOwnerCreateOneInput!
  contestType: ContestTypeCreateOneInput!
  scoringSystem: ScoringSystemHeaderCreateOneWithoutContestInput!
  users: ContestUserCreateManyWithoutContestInput
  contestSlates: ContestSlateCreateManyWithoutContestInput
}

input ContestCreateOneWithoutContestSlatesInput {
  create: ContestCreateWithoutContestSlatesInput
  connect: ContestWhereUniqueInput
}

input ContestCreateOneWithoutScoringSystemInput {
  create: ContestCreateWithoutScoringSystemInput
  connect: ContestWhereUniqueInput
}

input ContestCreateOneWithoutUsersInput {
  create: ContestCreateWithoutUsersInput
  connect: ContestWhereUniqueInput
}

input ContestCreateWithoutContestSlatesInput {
  id: ID
  contestName: String!
  isActive: Boolean
  isDefault: Boolean
  isAll: Boolean
  isPublic: Boolean!
  invitationCode: String!
  startDate: DateTime!
  endDate: DateTime
  isPremium: Boolean
  playerLimit: Int
  createdBy: ContestCreatorCreateOneInput!
  currentOwner: ContestOwnerCreateOneInput!
  contestType: ContestTypeCreateOneInput!
  scoringSystem: ScoringSystemHeaderCreateOneWithoutContestInput!
  users: ContestUserCreateManyWithoutContestInput
}

input ContestCreateWithoutScoringSystemInput {
  id: ID
  contestName: String!
  isActive: Boolean
  isDefault: Boolean
  isAll: Boolean
  isPublic: Boolean!
  invitationCode: String!
  startDate: DateTime!
  endDate: DateTime
  isPremium: Boolean
  playerLimit: Int
  createdBy: ContestCreatorCreateOneInput!
  currentOwner: ContestOwnerCreateOneInput!
  contestType: ContestTypeCreateOneInput!
  users: ContestUserCreateManyWithoutContestInput
  contestSlates: ContestSlateCreateManyWithoutContestInput
}

input ContestCreateWithoutUsersInput {
  id: ID
  contestName: String!
  isActive: Boolean
  isDefault: Boolean
  isAll: Boolean
  isPublic: Boolean!
  invitationCode: String!
  startDate: DateTime!
  endDate: DateTime
  isPremium: Boolean
  playerLimit: Int
  createdBy: ContestCreatorCreateOneInput!
  currentOwner: ContestOwnerCreateOneInput!
  contestType: ContestTypeCreateOneInput!
  scoringSystem: ScoringSystemHeaderCreateOneWithoutContestInput!
  contestSlates: ContestSlateCreateManyWithoutContestInput
}

type ContestCreator {
  id: ID!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ContestCreatorConnection {
  pageInfo: PageInfo!
  edges: [ContestCreatorEdge]!
  aggregate: AggregateContestCreator!
}

input ContestCreatorCreateInput {
  id: ID
  user: UserCreateOneInput!
}

input ContestCreatorCreateOneInput {
  create: ContestCreatorCreateInput
  connect: ContestCreatorWhereUniqueInput
}

type ContestCreatorEdge {
  node: ContestCreator!
  cursor: String!
}

enum ContestCreatorOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ContestCreatorPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ContestCreatorSubscriptionPayload {
  mutation: MutationType!
  node: ContestCreator
  updatedFields: [String!]
  previousValues: ContestCreatorPreviousValues
}

input ContestCreatorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContestCreatorWhereInput
  AND: [ContestCreatorSubscriptionWhereInput!]
  OR: [ContestCreatorSubscriptionWhereInput!]
  NOT: [ContestCreatorSubscriptionWhereInput!]
}

input ContestCreatorUpdateDataInput {
  user: UserUpdateOneRequiredInput
}

input ContestCreatorUpdateInput {
  user: UserUpdateOneRequiredInput
}

input ContestCreatorUpdateOneRequiredInput {
  create: ContestCreatorCreateInput
  update: ContestCreatorUpdateDataInput
  upsert: ContestCreatorUpsertNestedInput
  connect: ContestCreatorWhereUniqueInput
}

input ContestCreatorUpsertNestedInput {
  update: ContestCreatorUpdateDataInput!
  create: ContestCreatorCreateInput!
}

input ContestCreatorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ContestCreatorWhereInput!]
  OR: [ContestCreatorWhereInput!]
  NOT: [ContestCreatorWhereInput!]
}

input ContestCreatorWhereUniqueInput {
  id: ID
}

type ContestEdge {
  node: Contest!
  cursor: String!
}

type ContestInviter {
  id: ID!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ContestInviterConnection {
  pageInfo: PageInfo!
  edges: [ContestInviterEdge]!
  aggregate: AggregateContestInviter!
}

input ContestInviterCreateInput {
  id: ID
  user: UserCreateOneInput!
}

input ContestInviterCreateOneInput {
  create: ContestInviterCreateInput
  connect: ContestInviterWhereUniqueInput
}

type ContestInviterEdge {
  node: ContestInviter!
  cursor: String!
}

enum ContestInviterOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ContestInviterPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ContestInviterSubscriptionPayload {
  mutation: MutationType!
  node: ContestInviter
  updatedFields: [String!]
  previousValues: ContestInviterPreviousValues
}

input ContestInviterSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContestInviterWhereInput
  AND: [ContestInviterSubscriptionWhereInput!]
  OR: [ContestInviterSubscriptionWhereInput!]
  NOT: [ContestInviterSubscriptionWhereInput!]
}

input ContestInviterUpdateDataInput {
  user: UserUpdateOneRequiredInput
}

input ContestInviterUpdateInput {
  user: UserUpdateOneRequiredInput
}

input ContestInviterUpdateOneInput {
  create: ContestInviterCreateInput
  update: ContestInviterUpdateDataInput
  upsert: ContestInviterUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ContestInviterWhereUniqueInput
}

input ContestInviterUpsertNestedInput {
  update: ContestInviterUpdateDataInput!
  create: ContestInviterCreateInput!
}

input ContestInviterWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ContestInviterWhereInput!]
  OR: [ContestInviterWhereInput!]
  NOT: [ContestInviterWhereInput!]
}

input ContestInviterWhereUniqueInput {
  id: ID
}

enum ContestOrderByInput {
  id_ASC
  id_DESC
  contestName_ASC
  contestName_DESC
  isActive_ASC
  isActive_DESC
  isDefault_ASC
  isDefault_DESC
  isAll_ASC
  isAll_DESC
  isPublic_ASC
  isPublic_DESC
  invitationCode_ASC
  invitationCode_DESC
  startDate_ASC
  startDate_DESC
  endDate_ASC
  endDate_DESC
  isPremium_ASC
  isPremium_DESC
  playerLimit_ASC
  playerLimit_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ContestOwner {
  id: ID!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ContestOwnerConnection {
  pageInfo: PageInfo!
  edges: [ContestOwnerEdge]!
  aggregate: AggregateContestOwner!
}

input ContestOwnerCreateInput {
  id: ID
  user: UserCreateOneInput!
}

input ContestOwnerCreateOneInput {
  create: ContestOwnerCreateInput
  connect: ContestOwnerWhereUniqueInput
}

type ContestOwnerEdge {
  node: ContestOwner!
  cursor: String!
}

enum ContestOwnerOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ContestOwnerPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ContestOwnerSubscriptionPayload {
  mutation: MutationType!
  node: ContestOwner
  updatedFields: [String!]
  previousValues: ContestOwnerPreviousValues
}

input ContestOwnerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContestOwnerWhereInput
  AND: [ContestOwnerSubscriptionWhereInput!]
  OR: [ContestOwnerSubscriptionWhereInput!]
  NOT: [ContestOwnerSubscriptionWhereInput!]
}

input ContestOwnerUpdateDataInput {
  user: UserUpdateOneRequiredInput
}

input ContestOwnerUpdateInput {
  user: UserUpdateOneRequiredInput
}

input ContestOwnerUpdateOneRequiredInput {
  create: ContestOwnerCreateInput
  update: ContestOwnerUpdateDataInput
  upsert: ContestOwnerUpsertNestedInput
  connect: ContestOwnerWhereUniqueInput
}

input ContestOwnerUpsertNestedInput {
  update: ContestOwnerUpdateDataInput!
  create: ContestOwnerCreateInput!
}

input ContestOwnerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ContestOwnerWhereInput!]
  OR: [ContestOwnerWhereInput!]
  NOT: [ContestOwnerWhereInput!]
}

input ContestOwnerWhereUniqueInput {
  id: ID
}

type ContestPrediction {
  id: Int!
  homeScore: Int!
  awayScore: Int!
  expectedResult: String!
  homeScoreMatches: Boolean!
  awayScoreMatches: Boolean!
  scoresMatch: Boolean!
  resultMatches: Boolean!
  isBanker: Boolean!
  hasFinished: Boolean!
  deadlineTime: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
  contestSlateEntry: ContestSlateEntry!
  contestUser: ContestUser!
  predictionResult(where: ContestPredictionScoreWhereInput, orderBy: ContestPredictionScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContestPredictionScore!]
}

type ContestPredictionConnection {
  pageInfo: PageInfo!
  edges: [ContestPredictionEdge]!
  aggregate: AggregateContestPrediction!
}

input ContestPredictionCreateInput {
  id: Int
  homeScore: Int!
  awayScore: Int!
  expectedResult: String!
  homeScoreMatches: Boolean
  awayScoreMatches: Boolean
  scoresMatch: Boolean
  resultMatches: Boolean
  isBanker: Boolean
  hasFinished: Boolean
  deadlineTime: DateTime!
  contestSlateEntry: ContestSlateEntryCreateOneWithoutPredictionsInput!
  contestUser: ContestUserCreateOneInput!
  predictionResult: ContestPredictionScoreCreateManyWithoutContestPredicitonInput
}

input ContestPredictionCreateManyWithoutContestSlateEntryInput {
  create: [ContestPredictionCreateWithoutContestSlateEntryInput!]
  connect: [ContestPredictionWhereUniqueInput!]
}

input ContestPredictionCreateOneWithoutPredictionResultInput {
  create: ContestPredictionCreateWithoutPredictionResultInput
  connect: ContestPredictionWhereUniqueInput
}

input ContestPredictionCreateWithoutContestSlateEntryInput {
  id: Int
  homeScore: Int!
  awayScore: Int!
  expectedResult: String!
  homeScoreMatches: Boolean
  awayScoreMatches: Boolean
  scoresMatch: Boolean
  resultMatches: Boolean
  isBanker: Boolean
  hasFinished: Boolean
  deadlineTime: DateTime!
  contestUser: ContestUserCreateOneInput!
  predictionResult: ContestPredictionScoreCreateManyWithoutContestPredicitonInput
}

input ContestPredictionCreateWithoutPredictionResultInput {
  id: Int
  homeScore: Int!
  awayScore: Int!
  expectedResult: String!
  homeScoreMatches: Boolean
  awayScoreMatches: Boolean
  scoresMatch: Boolean
  resultMatches: Boolean
  isBanker: Boolean
  hasFinished: Boolean
  deadlineTime: DateTime!
  contestSlateEntry: ContestSlateEntryCreateOneWithoutPredictionsInput!
  contestUser: ContestUserCreateOneInput!
}

type ContestPredictionEdge {
  node: ContestPrediction!
  cursor: String!
}

enum ContestPredictionOrderByInput {
  id_ASC
  id_DESC
  homeScore_ASC
  homeScore_DESC
  awayScore_ASC
  awayScore_DESC
  expectedResult_ASC
  expectedResult_DESC
  homeScoreMatches_ASC
  homeScoreMatches_DESC
  awayScoreMatches_ASC
  awayScoreMatches_DESC
  scoresMatch_ASC
  scoresMatch_DESC
  resultMatches_ASC
  resultMatches_DESC
  isBanker_ASC
  isBanker_DESC
  hasFinished_ASC
  hasFinished_DESC
  deadlineTime_ASC
  deadlineTime_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ContestPredictionPreviousValues {
  id: Int!
  homeScore: Int!
  awayScore: Int!
  expectedResult: String!
  homeScoreMatches: Boolean!
  awayScoreMatches: Boolean!
  scoresMatch: Boolean!
  resultMatches: Boolean!
  isBanker: Boolean!
  hasFinished: Boolean!
  deadlineTime: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ContestPredictionScalarWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  homeScore: Int
  homeScore_not: Int
  homeScore_in: [Int!]
  homeScore_not_in: [Int!]
  homeScore_lt: Int
  homeScore_lte: Int
  homeScore_gt: Int
  homeScore_gte: Int
  awayScore: Int
  awayScore_not: Int
  awayScore_in: [Int!]
  awayScore_not_in: [Int!]
  awayScore_lt: Int
  awayScore_lte: Int
  awayScore_gt: Int
  awayScore_gte: Int
  expectedResult: String
  expectedResult_not: String
  expectedResult_in: [String!]
  expectedResult_not_in: [String!]
  expectedResult_lt: String
  expectedResult_lte: String
  expectedResult_gt: String
  expectedResult_gte: String
  expectedResult_contains: String
  expectedResult_not_contains: String
  expectedResult_starts_with: String
  expectedResult_not_starts_with: String
  expectedResult_ends_with: String
  expectedResult_not_ends_with: String
  homeScoreMatches: Boolean
  homeScoreMatches_not: Boolean
  awayScoreMatches: Boolean
  awayScoreMatches_not: Boolean
  scoresMatch: Boolean
  scoresMatch_not: Boolean
  resultMatches: Boolean
  resultMatches_not: Boolean
  isBanker: Boolean
  isBanker_not: Boolean
  hasFinished: Boolean
  hasFinished_not: Boolean
  deadlineTime: DateTime
  deadlineTime_not: DateTime
  deadlineTime_in: [DateTime!]
  deadlineTime_not_in: [DateTime!]
  deadlineTime_lt: DateTime
  deadlineTime_lte: DateTime
  deadlineTime_gt: DateTime
  deadlineTime_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ContestPredictionScalarWhereInput!]
  OR: [ContestPredictionScalarWhereInput!]
  NOT: [ContestPredictionScalarWhereInput!]
}

type ContestPredictionScore {
  id: ID!
  pointsAvailable: Int!
  pointsScored: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  scoringDetail: ScoringSystemDetail!
  contestPrediciton: ContestPrediction!
}

type ContestPredictionScoreConnection {
  pageInfo: PageInfo!
  edges: [ContestPredictionScoreEdge]!
  aggregate: AggregateContestPredictionScore!
}

input ContestPredictionScoreCreateInput {
  id: ID
  pointsAvailable: Int
  pointsScored: Int
  scoringDetail: ScoringSystemDetailCreateOneInput!
  contestPrediciton: ContestPredictionCreateOneWithoutPredictionResultInput!
}

input ContestPredictionScoreCreateManyWithoutContestPredicitonInput {
  create: [ContestPredictionScoreCreateWithoutContestPredicitonInput!]
  connect: [ContestPredictionScoreWhereUniqueInput!]
}

input ContestPredictionScoreCreateWithoutContestPredicitonInput {
  id: ID
  pointsAvailable: Int
  pointsScored: Int
  scoringDetail: ScoringSystemDetailCreateOneInput!
}

type ContestPredictionScoreEdge {
  node: ContestPredictionScore!
  cursor: String!
}

enum ContestPredictionScoreOrderByInput {
  id_ASC
  id_DESC
  pointsAvailable_ASC
  pointsAvailable_DESC
  pointsScored_ASC
  pointsScored_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ContestPredictionScorePreviousValues {
  id: ID!
  pointsAvailable: Int!
  pointsScored: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ContestPredictionScoreScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  pointsAvailable: Int
  pointsAvailable_not: Int
  pointsAvailable_in: [Int!]
  pointsAvailable_not_in: [Int!]
  pointsAvailable_lt: Int
  pointsAvailable_lte: Int
  pointsAvailable_gt: Int
  pointsAvailable_gte: Int
  pointsScored: Int
  pointsScored_not: Int
  pointsScored_in: [Int!]
  pointsScored_not_in: [Int!]
  pointsScored_lt: Int
  pointsScored_lte: Int
  pointsScored_gt: Int
  pointsScored_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ContestPredictionScoreScalarWhereInput!]
  OR: [ContestPredictionScoreScalarWhereInput!]
  NOT: [ContestPredictionScoreScalarWhereInput!]
}

type ContestPredictionScoreSubscriptionPayload {
  mutation: MutationType!
  node: ContestPredictionScore
  updatedFields: [String!]
  previousValues: ContestPredictionScorePreviousValues
}

input ContestPredictionScoreSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContestPredictionScoreWhereInput
  AND: [ContestPredictionScoreSubscriptionWhereInput!]
  OR: [ContestPredictionScoreSubscriptionWhereInput!]
  NOT: [ContestPredictionScoreSubscriptionWhereInput!]
}

input ContestPredictionScoreUpdateInput {
  pointsAvailable: Int
  pointsScored: Int
  scoringDetail: ScoringSystemDetailUpdateOneRequiredInput
  contestPrediciton: ContestPredictionUpdateOneRequiredWithoutPredictionResultInput
}

input ContestPredictionScoreUpdateManyDataInput {
  pointsAvailable: Int
  pointsScored: Int
}

input ContestPredictionScoreUpdateManyMutationInput {
  pointsAvailable: Int
  pointsScored: Int
}

input ContestPredictionScoreUpdateManyWithoutContestPredicitonInput {
  create: [ContestPredictionScoreCreateWithoutContestPredicitonInput!]
  delete: [ContestPredictionScoreWhereUniqueInput!]
  connect: [ContestPredictionScoreWhereUniqueInput!]
  set: [ContestPredictionScoreWhereUniqueInput!]
  disconnect: [ContestPredictionScoreWhereUniqueInput!]
  update: [ContestPredictionScoreUpdateWithWhereUniqueWithoutContestPredicitonInput!]
  upsert: [ContestPredictionScoreUpsertWithWhereUniqueWithoutContestPredicitonInput!]
  deleteMany: [ContestPredictionScoreScalarWhereInput!]
  updateMany: [ContestPredictionScoreUpdateManyWithWhereNestedInput!]
}

input ContestPredictionScoreUpdateManyWithWhereNestedInput {
  where: ContestPredictionScoreScalarWhereInput!
  data: ContestPredictionScoreUpdateManyDataInput!
}

input ContestPredictionScoreUpdateWithoutContestPredicitonDataInput {
  pointsAvailable: Int
  pointsScored: Int
  scoringDetail: ScoringSystemDetailUpdateOneRequiredInput
}

input ContestPredictionScoreUpdateWithWhereUniqueWithoutContestPredicitonInput {
  where: ContestPredictionScoreWhereUniqueInput!
  data: ContestPredictionScoreUpdateWithoutContestPredicitonDataInput!
}

input ContestPredictionScoreUpsertWithWhereUniqueWithoutContestPredicitonInput {
  where: ContestPredictionScoreWhereUniqueInput!
  update: ContestPredictionScoreUpdateWithoutContestPredicitonDataInput!
  create: ContestPredictionScoreCreateWithoutContestPredicitonInput!
}

input ContestPredictionScoreWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  pointsAvailable: Int
  pointsAvailable_not: Int
  pointsAvailable_in: [Int!]
  pointsAvailable_not_in: [Int!]
  pointsAvailable_lt: Int
  pointsAvailable_lte: Int
  pointsAvailable_gt: Int
  pointsAvailable_gte: Int
  pointsScored: Int
  pointsScored_not: Int
  pointsScored_in: [Int!]
  pointsScored_not_in: [Int!]
  pointsScored_lt: Int
  pointsScored_lte: Int
  pointsScored_gt: Int
  pointsScored_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  scoringDetail: ScoringSystemDetailWhereInput
  contestPrediciton: ContestPredictionWhereInput
  AND: [ContestPredictionScoreWhereInput!]
  OR: [ContestPredictionScoreWhereInput!]
  NOT: [ContestPredictionScoreWhereInput!]
}

input ContestPredictionScoreWhereUniqueInput {
  id: ID
}

type ContestPredictionSubscriptionPayload {
  mutation: MutationType!
  node: ContestPrediction
  updatedFields: [String!]
  previousValues: ContestPredictionPreviousValues
}

input ContestPredictionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContestPredictionWhereInput
  AND: [ContestPredictionSubscriptionWhereInput!]
  OR: [ContestPredictionSubscriptionWhereInput!]
  NOT: [ContestPredictionSubscriptionWhereInput!]
}

input ContestPredictionUpdateInput {
  homeScore: Int
  awayScore: Int
  expectedResult: String
  homeScoreMatches: Boolean
  awayScoreMatches: Boolean
  scoresMatch: Boolean
  resultMatches: Boolean
  isBanker: Boolean
  hasFinished: Boolean
  deadlineTime: DateTime
  contestSlateEntry: ContestSlateEntryUpdateOneRequiredWithoutPredictionsInput
  contestUser: ContestUserUpdateOneRequiredInput
  predictionResult: ContestPredictionScoreUpdateManyWithoutContestPredicitonInput
}

input ContestPredictionUpdateManyDataInput {
  homeScore: Int
  awayScore: Int
  expectedResult: String
  homeScoreMatches: Boolean
  awayScoreMatches: Boolean
  scoresMatch: Boolean
  resultMatches: Boolean
  isBanker: Boolean
  hasFinished: Boolean
  deadlineTime: DateTime
}

input ContestPredictionUpdateManyMutationInput {
  homeScore: Int
  awayScore: Int
  expectedResult: String
  homeScoreMatches: Boolean
  awayScoreMatches: Boolean
  scoresMatch: Boolean
  resultMatches: Boolean
  isBanker: Boolean
  hasFinished: Boolean
  deadlineTime: DateTime
}

input ContestPredictionUpdateManyWithoutContestSlateEntryInput {
  create: [ContestPredictionCreateWithoutContestSlateEntryInput!]
  delete: [ContestPredictionWhereUniqueInput!]
  connect: [ContestPredictionWhereUniqueInput!]
  set: [ContestPredictionWhereUniqueInput!]
  disconnect: [ContestPredictionWhereUniqueInput!]
  update: [ContestPredictionUpdateWithWhereUniqueWithoutContestSlateEntryInput!]
  upsert: [ContestPredictionUpsertWithWhereUniqueWithoutContestSlateEntryInput!]
  deleteMany: [ContestPredictionScalarWhereInput!]
  updateMany: [ContestPredictionUpdateManyWithWhereNestedInput!]
}

input ContestPredictionUpdateManyWithWhereNestedInput {
  where: ContestPredictionScalarWhereInput!
  data: ContestPredictionUpdateManyDataInput!
}

input ContestPredictionUpdateOneRequiredWithoutPredictionResultInput {
  create: ContestPredictionCreateWithoutPredictionResultInput
  update: ContestPredictionUpdateWithoutPredictionResultDataInput
  upsert: ContestPredictionUpsertWithoutPredictionResultInput
  connect: ContestPredictionWhereUniqueInput
}

input ContestPredictionUpdateWithoutContestSlateEntryDataInput {
  homeScore: Int
  awayScore: Int
  expectedResult: String
  homeScoreMatches: Boolean
  awayScoreMatches: Boolean
  scoresMatch: Boolean
  resultMatches: Boolean
  isBanker: Boolean
  hasFinished: Boolean
  deadlineTime: DateTime
  contestUser: ContestUserUpdateOneRequiredInput
  predictionResult: ContestPredictionScoreUpdateManyWithoutContestPredicitonInput
}

input ContestPredictionUpdateWithoutPredictionResultDataInput {
  homeScore: Int
  awayScore: Int
  expectedResult: String
  homeScoreMatches: Boolean
  awayScoreMatches: Boolean
  scoresMatch: Boolean
  resultMatches: Boolean
  isBanker: Boolean
  hasFinished: Boolean
  deadlineTime: DateTime
  contestSlateEntry: ContestSlateEntryUpdateOneRequiredWithoutPredictionsInput
  contestUser: ContestUserUpdateOneRequiredInput
}

input ContestPredictionUpdateWithWhereUniqueWithoutContestSlateEntryInput {
  where: ContestPredictionWhereUniqueInput!
  data: ContestPredictionUpdateWithoutContestSlateEntryDataInput!
}

input ContestPredictionUpsertWithoutPredictionResultInput {
  update: ContestPredictionUpdateWithoutPredictionResultDataInput!
  create: ContestPredictionCreateWithoutPredictionResultInput!
}

input ContestPredictionUpsertWithWhereUniqueWithoutContestSlateEntryInput {
  where: ContestPredictionWhereUniqueInput!
  update: ContestPredictionUpdateWithoutContestSlateEntryDataInput!
  create: ContestPredictionCreateWithoutContestSlateEntryInput!
}

input ContestPredictionWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  homeScore: Int
  homeScore_not: Int
  homeScore_in: [Int!]
  homeScore_not_in: [Int!]
  homeScore_lt: Int
  homeScore_lte: Int
  homeScore_gt: Int
  homeScore_gte: Int
  awayScore: Int
  awayScore_not: Int
  awayScore_in: [Int!]
  awayScore_not_in: [Int!]
  awayScore_lt: Int
  awayScore_lte: Int
  awayScore_gt: Int
  awayScore_gte: Int
  expectedResult: String
  expectedResult_not: String
  expectedResult_in: [String!]
  expectedResult_not_in: [String!]
  expectedResult_lt: String
  expectedResult_lte: String
  expectedResult_gt: String
  expectedResult_gte: String
  expectedResult_contains: String
  expectedResult_not_contains: String
  expectedResult_starts_with: String
  expectedResult_not_starts_with: String
  expectedResult_ends_with: String
  expectedResult_not_ends_with: String
  homeScoreMatches: Boolean
  homeScoreMatches_not: Boolean
  awayScoreMatches: Boolean
  awayScoreMatches_not: Boolean
  scoresMatch: Boolean
  scoresMatch_not: Boolean
  resultMatches: Boolean
  resultMatches_not: Boolean
  isBanker: Boolean
  isBanker_not: Boolean
  hasFinished: Boolean
  hasFinished_not: Boolean
  deadlineTime: DateTime
  deadlineTime_not: DateTime
  deadlineTime_in: [DateTime!]
  deadlineTime_not_in: [DateTime!]
  deadlineTime_lt: DateTime
  deadlineTime_lte: DateTime
  deadlineTime_gt: DateTime
  deadlineTime_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  contestSlateEntry: ContestSlateEntryWhereInput
  contestUser: ContestUserWhereInput
  predictionResult_every: ContestPredictionScoreWhereInput
  predictionResult_some: ContestPredictionScoreWhereInput
  predictionResult_none: ContestPredictionScoreWhereInput
  AND: [ContestPredictionWhereInput!]
  OR: [ContestPredictionWhereInput!]
  NOT: [ContestPredictionWhereInput!]
}

input ContestPredictionWhereUniqueInput {
  id: Int
}

type ContestPreviousValues {
  id: ID!
  contestName: String!
  isActive: Boolean!
  isDefault: Boolean!
  isAll: Boolean!
  isPublic: Boolean!
  invitationCode: String!
  startDate: DateTime!
  endDate: DateTime
  isPremium: Boolean!
  playerLimit: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ContestSlate {
  id: Int!
  fromDefault: Boolean!
  isActive: Boolean!
  startDate: DateTime!
  endDate: DateTime
  hasStarted: Boolean!
  hasFinished: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  contest: Contest!
  gameweekId: Gameweek
  entries(where: ContestSlateEntryWhereInput, orderBy: ContestSlateEntryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContestSlateEntry!]
}

type ContestSlateConnection {
  pageInfo: PageInfo!
  edges: [ContestSlateEdge]!
  aggregate: AggregateContestSlate!
}

input ContestSlateCreateInput {
  id: Int
  fromDefault: Boolean
  isActive: Boolean
  startDate: DateTime!
  endDate: DateTime
  hasStarted: Boolean
  hasFinished: Boolean
  contest: ContestCreateOneWithoutContestSlatesInput!
  gameweekId: GameweekCreateOneInput
  entries: ContestSlateEntryCreateManyWithoutSlateInput
}

input ContestSlateCreateManyWithoutContestInput {
  create: [ContestSlateCreateWithoutContestInput!]
  connect: [ContestSlateWhereUniqueInput!]
}

input ContestSlateCreateOneWithoutEntriesInput {
  create: ContestSlateCreateWithoutEntriesInput
  connect: ContestSlateWhereUniqueInput
}

input ContestSlateCreateWithoutContestInput {
  id: Int
  fromDefault: Boolean
  isActive: Boolean
  startDate: DateTime!
  endDate: DateTime
  hasStarted: Boolean
  hasFinished: Boolean
  gameweekId: GameweekCreateOneInput
  entries: ContestSlateEntryCreateManyWithoutSlateInput
}

input ContestSlateCreateWithoutEntriesInput {
  id: Int
  fromDefault: Boolean
  isActive: Boolean
  startDate: DateTime!
  endDate: DateTime
  hasStarted: Boolean
  hasFinished: Boolean
  contest: ContestCreateOneWithoutContestSlatesInput!
  gameweekId: GameweekCreateOneInput
}

type ContestSlateEdge {
  node: ContestSlate!
  cursor: String!
}

type ContestSlateEntry {
  id: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  slate: ContestSlate!
  fixture: Fixture!
  predictions(where: ContestPredictionWhereInput, orderBy: ContestPredictionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContestPrediction!]
}

type ContestSlateEntryConnection {
  pageInfo: PageInfo!
  edges: [ContestSlateEntryEdge]!
  aggregate: AggregateContestSlateEntry!
}

input ContestSlateEntryCreateInput {
  id: Int
  slate: ContestSlateCreateOneWithoutEntriesInput!
  fixture: FixtureCreateOneInput!
  predictions: ContestPredictionCreateManyWithoutContestSlateEntryInput
}

input ContestSlateEntryCreateManyWithoutSlateInput {
  create: [ContestSlateEntryCreateWithoutSlateInput!]
  connect: [ContestSlateEntryWhereUniqueInput!]
}

input ContestSlateEntryCreateOneWithoutPredictionsInput {
  create: ContestSlateEntryCreateWithoutPredictionsInput
  connect: ContestSlateEntryWhereUniqueInput
}

input ContestSlateEntryCreateWithoutPredictionsInput {
  id: Int
  slate: ContestSlateCreateOneWithoutEntriesInput!
  fixture: FixtureCreateOneInput!
}

input ContestSlateEntryCreateWithoutSlateInput {
  id: Int
  fixture: FixtureCreateOneInput!
  predictions: ContestPredictionCreateManyWithoutContestSlateEntryInput
}

type ContestSlateEntryEdge {
  node: ContestSlateEntry!
  cursor: String!
}

enum ContestSlateEntryOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ContestSlateEntryPreviousValues {
  id: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ContestSlateEntryScalarWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ContestSlateEntryScalarWhereInput!]
  OR: [ContestSlateEntryScalarWhereInput!]
  NOT: [ContestSlateEntryScalarWhereInput!]
}

type ContestSlateEntrySubscriptionPayload {
  mutation: MutationType!
  node: ContestSlateEntry
  updatedFields: [String!]
  previousValues: ContestSlateEntryPreviousValues
}

input ContestSlateEntrySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContestSlateEntryWhereInput
  AND: [ContestSlateEntrySubscriptionWhereInput!]
  OR: [ContestSlateEntrySubscriptionWhereInput!]
  NOT: [ContestSlateEntrySubscriptionWhereInput!]
}

input ContestSlateEntryUpdateInput {
  slate: ContestSlateUpdateOneRequiredWithoutEntriesInput
  fixture: FixtureUpdateOneRequiredInput
  predictions: ContestPredictionUpdateManyWithoutContestSlateEntryInput
}

input ContestSlateEntryUpdateManyWithoutSlateInput {
  create: [ContestSlateEntryCreateWithoutSlateInput!]
  delete: [ContestSlateEntryWhereUniqueInput!]
  connect: [ContestSlateEntryWhereUniqueInput!]
  set: [ContestSlateEntryWhereUniqueInput!]
  disconnect: [ContestSlateEntryWhereUniqueInput!]
  update: [ContestSlateEntryUpdateWithWhereUniqueWithoutSlateInput!]
  upsert: [ContestSlateEntryUpsertWithWhereUniqueWithoutSlateInput!]
  deleteMany: [ContestSlateEntryScalarWhereInput!]
}

input ContestSlateEntryUpdateOneRequiredWithoutPredictionsInput {
  create: ContestSlateEntryCreateWithoutPredictionsInput
  update: ContestSlateEntryUpdateWithoutPredictionsDataInput
  upsert: ContestSlateEntryUpsertWithoutPredictionsInput
  connect: ContestSlateEntryWhereUniqueInput
}

input ContestSlateEntryUpdateWithoutPredictionsDataInput {
  slate: ContestSlateUpdateOneRequiredWithoutEntriesInput
  fixture: FixtureUpdateOneRequiredInput
}

input ContestSlateEntryUpdateWithoutSlateDataInput {
  fixture: FixtureUpdateOneRequiredInput
  predictions: ContestPredictionUpdateManyWithoutContestSlateEntryInput
}

input ContestSlateEntryUpdateWithWhereUniqueWithoutSlateInput {
  where: ContestSlateEntryWhereUniqueInput!
  data: ContestSlateEntryUpdateWithoutSlateDataInput!
}

input ContestSlateEntryUpsertWithoutPredictionsInput {
  update: ContestSlateEntryUpdateWithoutPredictionsDataInput!
  create: ContestSlateEntryCreateWithoutPredictionsInput!
}

input ContestSlateEntryUpsertWithWhereUniqueWithoutSlateInput {
  where: ContestSlateEntryWhereUniqueInput!
  update: ContestSlateEntryUpdateWithoutSlateDataInput!
  create: ContestSlateEntryCreateWithoutSlateInput!
}

input ContestSlateEntryWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  slate: ContestSlateWhereInput
  fixture: FixtureWhereInput
  predictions_every: ContestPredictionWhereInput
  predictions_some: ContestPredictionWhereInput
  predictions_none: ContestPredictionWhereInput
  AND: [ContestSlateEntryWhereInput!]
  OR: [ContestSlateEntryWhereInput!]
  NOT: [ContestSlateEntryWhereInput!]
}

input ContestSlateEntryWhereUniqueInput {
  id: Int
}

enum ContestSlateOrderByInput {
  id_ASC
  id_DESC
  fromDefault_ASC
  fromDefault_DESC
  isActive_ASC
  isActive_DESC
  startDate_ASC
  startDate_DESC
  endDate_ASC
  endDate_DESC
  hasStarted_ASC
  hasStarted_DESC
  hasFinished_ASC
  hasFinished_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ContestSlatePreviousValues {
  id: Int!
  fromDefault: Boolean!
  isActive: Boolean!
  startDate: DateTime!
  endDate: DateTime
  hasStarted: Boolean!
  hasFinished: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ContestSlateScalarWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  fromDefault: Boolean
  fromDefault_not: Boolean
  isActive: Boolean
  isActive_not: Boolean
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  hasStarted: Boolean
  hasStarted_not: Boolean
  hasFinished: Boolean
  hasFinished_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ContestSlateScalarWhereInput!]
  OR: [ContestSlateScalarWhereInput!]
  NOT: [ContestSlateScalarWhereInput!]
}

type ContestSlateSubscriptionPayload {
  mutation: MutationType!
  node: ContestSlate
  updatedFields: [String!]
  previousValues: ContestSlatePreviousValues
}

input ContestSlateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContestSlateWhereInput
  AND: [ContestSlateSubscriptionWhereInput!]
  OR: [ContestSlateSubscriptionWhereInput!]
  NOT: [ContestSlateSubscriptionWhereInput!]
}

input ContestSlateUpdateInput {
  fromDefault: Boolean
  isActive: Boolean
  startDate: DateTime
  endDate: DateTime
  hasStarted: Boolean
  hasFinished: Boolean
  contest: ContestUpdateOneRequiredWithoutContestSlatesInput
  gameweekId: GameweekUpdateOneInput
  entries: ContestSlateEntryUpdateManyWithoutSlateInput
}

input ContestSlateUpdateManyDataInput {
  fromDefault: Boolean
  isActive: Boolean
  startDate: DateTime
  endDate: DateTime
  hasStarted: Boolean
  hasFinished: Boolean
}

input ContestSlateUpdateManyMutationInput {
  fromDefault: Boolean
  isActive: Boolean
  startDate: DateTime
  endDate: DateTime
  hasStarted: Boolean
  hasFinished: Boolean
}

input ContestSlateUpdateManyWithoutContestInput {
  create: [ContestSlateCreateWithoutContestInput!]
  delete: [ContestSlateWhereUniqueInput!]
  connect: [ContestSlateWhereUniqueInput!]
  set: [ContestSlateWhereUniqueInput!]
  disconnect: [ContestSlateWhereUniqueInput!]
  update: [ContestSlateUpdateWithWhereUniqueWithoutContestInput!]
  upsert: [ContestSlateUpsertWithWhereUniqueWithoutContestInput!]
  deleteMany: [ContestSlateScalarWhereInput!]
  updateMany: [ContestSlateUpdateManyWithWhereNestedInput!]
}

input ContestSlateUpdateManyWithWhereNestedInput {
  where: ContestSlateScalarWhereInput!
  data: ContestSlateUpdateManyDataInput!
}

input ContestSlateUpdateOneRequiredWithoutEntriesInput {
  create: ContestSlateCreateWithoutEntriesInput
  update: ContestSlateUpdateWithoutEntriesDataInput
  upsert: ContestSlateUpsertWithoutEntriesInput
  connect: ContestSlateWhereUniqueInput
}

input ContestSlateUpdateWithoutContestDataInput {
  fromDefault: Boolean
  isActive: Boolean
  startDate: DateTime
  endDate: DateTime
  hasStarted: Boolean
  hasFinished: Boolean
  gameweekId: GameweekUpdateOneInput
  entries: ContestSlateEntryUpdateManyWithoutSlateInput
}

input ContestSlateUpdateWithoutEntriesDataInput {
  fromDefault: Boolean
  isActive: Boolean
  startDate: DateTime
  endDate: DateTime
  hasStarted: Boolean
  hasFinished: Boolean
  contest: ContestUpdateOneRequiredWithoutContestSlatesInput
  gameweekId: GameweekUpdateOneInput
}

input ContestSlateUpdateWithWhereUniqueWithoutContestInput {
  where: ContestSlateWhereUniqueInput!
  data: ContestSlateUpdateWithoutContestDataInput!
}

input ContestSlateUpsertWithoutEntriesInput {
  update: ContestSlateUpdateWithoutEntriesDataInput!
  create: ContestSlateCreateWithoutEntriesInput!
}

input ContestSlateUpsertWithWhereUniqueWithoutContestInput {
  where: ContestSlateWhereUniqueInput!
  update: ContestSlateUpdateWithoutContestDataInput!
  create: ContestSlateCreateWithoutContestInput!
}

input ContestSlateWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  fromDefault: Boolean
  fromDefault_not: Boolean
  isActive: Boolean
  isActive_not: Boolean
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  hasStarted: Boolean
  hasStarted_not: Boolean
  hasFinished: Boolean
  hasFinished_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  contest: ContestWhereInput
  gameweekId: GameweekWhereInput
  entries_every: ContestSlateEntryWhereInput
  entries_some: ContestSlateEntryWhereInput
  entries_none: ContestSlateEntryWhereInput
  AND: [ContestSlateWhereInput!]
  OR: [ContestSlateWhereInput!]
  NOT: [ContestSlateWhereInput!]
}

input ContestSlateWhereUniqueInput {
  id: Int
}

type ContestSubscriptionPayload {
  mutation: MutationType!
  node: Contest
  updatedFields: [String!]
  previousValues: ContestPreviousValues
}

input ContestSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContestWhereInput
  AND: [ContestSubscriptionWhereInput!]
  OR: [ContestSubscriptionWhereInput!]
  NOT: [ContestSubscriptionWhereInput!]
}

type ContestType {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ContestTypeConnection {
  pageInfo: PageInfo!
  edges: [ContestTypeEdge]!
  aggregate: AggregateContestType!
}

input ContestTypeCreateInput {
  id: ID
  name: String!
}

input ContestTypeCreateOneInput {
  create: ContestTypeCreateInput
  connect: ContestTypeWhereUniqueInput
}

type ContestTypeEdge {
  node: ContestType!
  cursor: String!
}

enum ContestTypeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ContestTypePreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ContestTypeSubscriptionPayload {
  mutation: MutationType!
  node: ContestType
  updatedFields: [String!]
  previousValues: ContestTypePreviousValues
}

input ContestTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContestTypeWhereInput
  AND: [ContestTypeSubscriptionWhereInput!]
  OR: [ContestTypeSubscriptionWhereInput!]
  NOT: [ContestTypeSubscriptionWhereInput!]
}

input ContestTypeUpdateDataInput {
  name: String
}

input ContestTypeUpdateInput {
  name: String
}

input ContestTypeUpdateManyMutationInput {
  name: String
}

input ContestTypeUpdateOneRequiredInput {
  create: ContestTypeCreateInput
  update: ContestTypeUpdateDataInput
  upsert: ContestTypeUpsertNestedInput
  connect: ContestTypeWhereUniqueInput
}

input ContestTypeUpsertNestedInput {
  update: ContestTypeUpdateDataInput!
  create: ContestTypeCreateInput!
}

input ContestTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ContestTypeWhereInput!]
  OR: [ContestTypeWhereInput!]
  NOT: [ContestTypeWhereInput!]
}

input ContestTypeWhereUniqueInput {
  id: ID
  name: String
}

input ContestUpdateInput {
  contestName: String
  isActive: Boolean
  isDefault: Boolean
  isAll: Boolean
  isPublic: Boolean
  invitationCode: String
  startDate: DateTime
  endDate: DateTime
  isPremium: Boolean
  playerLimit: Int
  createdBy: ContestCreatorUpdateOneRequiredInput
  currentOwner: ContestOwnerUpdateOneRequiredInput
  contestType: ContestTypeUpdateOneRequiredInput
  scoringSystem: ScoringSystemHeaderUpdateOneRequiredWithoutContestInput
  users: ContestUserUpdateManyWithoutContestInput
  contestSlates: ContestSlateUpdateManyWithoutContestInput
}

input ContestUpdateManyMutationInput {
  contestName: String
  isActive: Boolean
  isDefault: Boolean
  isAll: Boolean
  isPublic: Boolean
  invitationCode: String
  startDate: DateTime
  endDate: DateTime
  isPremium: Boolean
  playerLimit: Int
}

input ContestUpdateOneRequiredWithoutContestSlatesInput {
  create: ContestCreateWithoutContestSlatesInput
  update: ContestUpdateWithoutContestSlatesDataInput
  upsert: ContestUpsertWithoutContestSlatesInput
  connect: ContestWhereUniqueInput
}

input ContestUpdateOneRequiredWithoutScoringSystemInput {
  create: ContestCreateWithoutScoringSystemInput
  update: ContestUpdateWithoutScoringSystemDataInput
  upsert: ContestUpsertWithoutScoringSystemInput
  connect: ContestWhereUniqueInput
}

input ContestUpdateOneRequiredWithoutUsersInput {
  create: ContestCreateWithoutUsersInput
  update: ContestUpdateWithoutUsersDataInput
  upsert: ContestUpsertWithoutUsersInput
  connect: ContestWhereUniqueInput
}

input ContestUpdateWithoutContestSlatesDataInput {
  contestName: String
  isActive: Boolean
  isDefault: Boolean
  isAll: Boolean
  isPublic: Boolean
  invitationCode: String
  startDate: DateTime
  endDate: DateTime
  isPremium: Boolean
  playerLimit: Int
  createdBy: ContestCreatorUpdateOneRequiredInput
  currentOwner: ContestOwnerUpdateOneRequiredInput
  contestType: ContestTypeUpdateOneRequiredInput
  scoringSystem: ScoringSystemHeaderUpdateOneRequiredWithoutContestInput
  users: ContestUserUpdateManyWithoutContestInput
}

input ContestUpdateWithoutScoringSystemDataInput {
  contestName: String
  isActive: Boolean
  isDefault: Boolean
  isAll: Boolean
  isPublic: Boolean
  invitationCode: String
  startDate: DateTime
  endDate: DateTime
  isPremium: Boolean
  playerLimit: Int
  createdBy: ContestCreatorUpdateOneRequiredInput
  currentOwner: ContestOwnerUpdateOneRequiredInput
  contestType: ContestTypeUpdateOneRequiredInput
  users: ContestUserUpdateManyWithoutContestInput
  contestSlates: ContestSlateUpdateManyWithoutContestInput
}

input ContestUpdateWithoutUsersDataInput {
  contestName: String
  isActive: Boolean
  isDefault: Boolean
  isAll: Boolean
  isPublic: Boolean
  invitationCode: String
  startDate: DateTime
  endDate: DateTime
  isPremium: Boolean
  playerLimit: Int
  createdBy: ContestCreatorUpdateOneRequiredInput
  currentOwner: ContestOwnerUpdateOneRequiredInput
  contestType: ContestTypeUpdateOneRequiredInput
  scoringSystem: ScoringSystemHeaderUpdateOneRequiredWithoutContestInput
  contestSlates: ContestSlateUpdateManyWithoutContestInput
}

input ContestUpsertWithoutContestSlatesInput {
  update: ContestUpdateWithoutContestSlatesDataInput!
  create: ContestCreateWithoutContestSlatesInput!
}

input ContestUpsertWithoutScoringSystemInput {
  update: ContestUpdateWithoutScoringSystemDataInput!
  create: ContestCreateWithoutScoringSystemInput!
}

input ContestUpsertWithoutUsersInput {
  update: ContestUpdateWithoutUsersDataInput!
  create: ContestCreateWithoutUsersInput!
}

type ContestUser {
  id: Int!
  isInvited: Boolean!
  isActive: Boolean!
  isBlocked: Boolean!
  balance: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User!
  contest: Contest!
  invitedBy: ContestInviter
  userType: ContestUserType!
}

type ContestUserConnection {
  pageInfo: PageInfo!
  edges: [ContestUserEdge]!
  aggregate: AggregateContestUser!
}

input ContestUserCreateInput {
  id: Int
  isInvited: Boolean
  isActive: Boolean
  isBlocked: Boolean
  balance: Int
  user: UserCreateOneInput!
  contest: ContestCreateOneWithoutUsersInput!
  invitedBy: ContestInviterCreateOneInput
  userType: ContestUserTypeCreateOneInput!
}

input ContestUserCreateManyWithoutContestInput {
  create: [ContestUserCreateWithoutContestInput!]
  connect: [ContestUserWhereUniqueInput!]
}

input ContestUserCreateOneInput {
  create: ContestUserCreateInput
  connect: ContestUserWhereUniqueInput
}

input ContestUserCreateWithoutContestInput {
  id: Int
  isInvited: Boolean
  isActive: Boolean
  isBlocked: Boolean
  balance: Int
  user: UserCreateOneInput!
  invitedBy: ContestInviterCreateOneInput
  userType: ContestUserTypeCreateOneInput!
}

type ContestUserEdge {
  node: ContestUser!
  cursor: String!
}

enum ContestUserOrderByInput {
  id_ASC
  id_DESC
  isInvited_ASC
  isInvited_DESC
  isActive_ASC
  isActive_DESC
  isBlocked_ASC
  isBlocked_DESC
  balance_ASC
  balance_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ContestUserPreviousValues {
  id: Int!
  isInvited: Boolean!
  isActive: Boolean!
  isBlocked: Boolean!
  balance: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ContestUserScalarWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  isInvited: Boolean
  isInvited_not: Boolean
  isActive: Boolean
  isActive_not: Boolean
  isBlocked: Boolean
  isBlocked_not: Boolean
  balance: Int
  balance_not: Int
  balance_in: [Int!]
  balance_not_in: [Int!]
  balance_lt: Int
  balance_lte: Int
  balance_gt: Int
  balance_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ContestUserScalarWhereInput!]
  OR: [ContestUserScalarWhereInput!]
  NOT: [ContestUserScalarWhereInput!]
}

type ContestUserSubscriptionPayload {
  mutation: MutationType!
  node: ContestUser
  updatedFields: [String!]
  previousValues: ContestUserPreviousValues
}

input ContestUserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContestUserWhereInput
  AND: [ContestUserSubscriptionWhereInput!]
  OR: [ContestUserSubscriptionWhereInput!]
  NOT: [ContestUserSubscriptionWhereInput!]
}

type ContestUserType {
  id: ID!
  name: String!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ContestUserTypeConnection {
  pageInfo: PageInfo!
  edges: [ContestUserTypeEdge]!
  aggregate: AggregateContestUserType!
}

input ContestUserTypeCreateInput {
  id: ID
  name: String!
  description: String
}

input ContestUserTypeCreateOneInput {
  create: ContestUserTypeCreateInput
  connect: ContestUserTypeWhereUniqueInput
}

type ContestUserTypeEdge {
  node: ContestUserType!
  cursor: String!
}

enum ContestUserTypeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ContestUserTypePreviousValues {
  id: ID!
  name: String!
  description: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ContestUserTypeSubscriptionPayload {
  mutation: MutationType!
  node: ContestUserType
  updatedFields: [String!]
  previousValues: ContestUserTypePreviousValues
}

input ContestUserTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContestUserTypeWhereInput
  AND: [ContestUserTypeSubscriptionWhereInput!]
  OR: [ContestUserTypeSubscriptionWhereInput!]
  NOT: [ContestUserTypeSubscriptionWhereInput!]
}

input ContestUserTypeUpdateDataInput {
  name: String
  description: String
}

input ContestUserTypeUpdateInput {
  name: String
  description: String
}

input ContestUserTypeUpdateManyMutationInput {
  name: String
  description: String
}

input ContestUserTypeUpdateOneRequiredInput {
  create: ContestUserTypeCreateInput
  update: ContestUserTypeUpdateDataInput
  upsert: ContestUserTypeUpsertNestedInput
  connect: ContestUserTypeWhereUniqueInput
}

input ContestUserTypeUpsertNestedInput {
  update: ContestUserTypeUpdateDataInput!
  create: ContestUserTypeCreateInput!
}

input ContestUserTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ContestUserTypeWhereInput!]
  OR: [ContestUserTypeWhereInput!]
  NOT: [ContestUserTypeWhereInput!]
}

input ContestUserTypeWhereUniqueInput {
  id: ID
  name: String
}

input ContestUserUpdateDataInput {
  isInvited: Boolean
  isActive: Boolean
  isBlocked: Boolean
  balance: Int
  user: UserUpdateOneRequiredInput
  contest: ContestUpdateOneRequiredWithoutUsersInput
  invitedBy: ContestInviterUpdateOneInput
  userType: ContestUserTypeUpdateOneRequiredInput
}

input ContestUserUpdateInput {
  isInvited: Boolean
  isActive: Boolean
  isBlocked: Boolean
  balance: Int
  user: UserUpdateOneRequiredInput
  contest: ContestUpdateOneRequiredWithoutUsersInput
  invitedBy: ContestInviterUpdateOneInput
  userType: ContestUserTypeUpdateOneRequiredInput
}

input ContestUserUpdateManyDataInput {
  isInvited: Boolean
  isActive: Boolean
  isBlocked: Boolean
  balance: Int
}

input ContestUserUpdateManyMutationInput {
  isInvited: Boolean
  isActive: Boolean
  isBlocked: Boolean
  balance: Int
}

input ContestUserUpdateManyWithoutContestInput {
  create: [ContestUserCreateWithoutContestInput!]
  delete: [ContestUserWhereUniqueInput!]
  connect: [ContestUserWhereUniqueInput!]
  set: [ContestUserWhereUniqueInput!]
  disconnect: [ContestUserWhereUniqueInput!]
  update: [ContestUserUpdateWithWhereUniqueWithoutContestInput!]
  upsert: [ContestUserUpsertWithWhereUniqueWithoutContestInput!]
  deleteMany: [ContestUserScalarWhereInput!]
  updateMany: [ContestUserUpdateManyWithWhereNestedInput!]
}

input ContestUserUpdateManyWithWhereNestedInput {
  where: ContestUserScalarWhereInput!
  data: ContestUserUpdateManyDataInput!
}

input ContestUserUpdateOneRequiredInput {
  create: ContestUserCreateInput
  update: ContestUserUpdateDataInput
  upsert: ContestUserUpsertNestedInput
  connect: ContestUserWhereUniqueInput
}

input ContestUserUpdateWithoutContestDataInput {
  isInvited: Boolean
  isActive: Boolean
  isBlocked: Boolean
  balance: Int
  user: UserUpdateOneRequiredInput
  invitedBy: ContestInviterUpdateOneInput
  userType: ContestUserTypeUpdateOneRequiredInput
}

input ContestUserUpdateWithWhereUniqueWithoutContestInput {
  where: ContestUserWhereUniqueInput!
  data: ContestUserUpdateWithoutContestDataInput!
}

input ContestUserUpsertNestedInput {
  update: ContestUserUpdateDataInput!
  create: ContestUserCreateInput!
}

input ContestUserUpsertWithWhereUniqueWithoutContestInput {
  where: ContestUserWhereUniqueInput!
  update: ContestUserUpdateWithoutContestDataInput!
  create: ContestUserCreateWithoutContestInput!
}

input ContestUserWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  isInvited: Boolean
  isInvited_not: Boolean
  isActive: Boolean
  isActive_not: Boolean
  isBlocked: Boolean
  isBlocked_not: Boolean
  balance: Int
  balance_not: Int
  balance_in: [Int!]
  balance_not_in: [Int!]
  balance_lt: Int
  balance_lte: Int
  balance_gt: Int
  balance_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  user: UserWhereInput
  contest: ContestWhereInput
  invitedBy: ContestInviterWhereInput
  userType: ContestUserTypeWhereInput
  AND: [ContestUserWhereInput!]
  OR: [ContestUserWhereInput!]
  NOT: [ContestUserWhereInput!]
}

input ContestUserWhereUniqueInput {
  id: Int
}

input ContestWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  contestName: String
  contestName_not: String
  contestName_in: [String!]
  contestName_not_in: [String!]
  contestName_lt: String
  contestName_lte: String
  contestName_gt: String
  contestName_gte: String
  contestName_contains: String
  contestName_not_contains: String
  contestName_starts_with: String
  contestName_not_starts_with: String
  contestName_ends_with: String
  contestName_not_ends_with: String
  isActive: Boolean
  isActive_not: Boolean
  isDefault: Boolean
  isDefault_not: Boolean
  isAll: Boolean
  isAll_not: Boolean
  isPublic: Boolean
  isPublic_not: Boolean
  invitationCode: String
  invitationCode_not: String
  invitationCode_in: [String!]
  invitationCode_not_in: [String!]
  invitationCode_lt: String
  invitationCode_lte: String
  invitationCode_gt: String
  invitationCode_gte: String
  invitationCode_contains: String
  invitationCode_not_contains: String
  invitationCode_starts_with: String
  invitationCode_not_starts_with: String
  invitationCode_ends_with: String
  invitationCode_not_ends_with: String
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  isPremium: Boolean
  isPremium_not: Boolean
  playerLimit: Int
  playerLimit_not: Int
  playerLimit_in: [Int!]
  playerLimit_not_in: [Int!]
  playerLimit_lt: Int
  playerLimit_lte: Int
  playerLimit_gt: Int
  playerLimit_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  createdBy: ContestCreatorWhereInput
  currentOwner: ContestOwnerWhereInput
  contestType: ContestTypeWhereInput
  scoringSystem: ScoringSystemHeaderWhereInput
  users_every: ContestUserWhereInput
  users_some: ContestUserWhereInput
  users_none: ContestUserWhereInput
  contestSlates_every: ContestSlateWhereInput
  contestSlates_some: ContestSlateWhereInput
  contestSlates_none: ContestSlateWhereInput
  AND: [ContestWhereInput!]
  OR: [ContestWhereInput!]
  NOT: [ContestWhereInput!]
}

input ContestWhereUniqueInput {
  id: ID
  invitationCode: String
}

type Country {
  id: ID!
  iso: String!
  name: String!
  code: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CountryConnection {
  pageInfo: PageInfo!
  edges: [CountryEdge]!
  aggregate: AggregateCountry!
}

input CountryCreateInput {
  id: ID
  iso: String!
  name: String!
  code: String!
}

input CountryCreateOneInput {
  create: CountryCreateInput
  connect: CountryWhereUniqueInput
}

type CountryEdge {
  node: Country!
  cursor: String!
}

enum CountryOrderByInput {
  id_ASC
  id_DESC
  iso_ASC
  iso_DESC
  name_ASC
  name_DESC
  code_ASC
  code_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CountryPreviousValues {
  id: ID!
  iso: String!
  name: String!
  code: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CountrySubscriptionPayload {
  mutation: MutationType!
  node: Country
  updatedFields: [String!]
  previousValues: CountryPreviousValues
}

input CountrySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CountryWhereInput
  AND: [CountrySubscriptionWhereInput!]
  OR: [CountrySubscriptionWhereInput!]
  NOT: [CountrySubscriptionWhereInput!]
}

input CountryUpdateDataInput {
  iso: String
  name: String
  code: String
}

input CountryUpdateInput {
  iso: String
  name: String
  code: String
}

input CountryUpdateManyMutationInput {
  iso: String
  name: String
  code: String
}

input CountryUpdateOneInput {
  create: CountryCreateInput
  update: CountryUpdateDataInput
  upsert: CountryUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CountryWhereUniqueInput
}

input CountryUpsertNestedInput {
  update: CountryUpdateDataInput!
  create: CountryCreateInput!
}

input CountryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  iso: String
  iso_not: String
  iso_in: [String!]
  iso_not_in: [String!]
  iso_lt: String
  iso_lte: String
  iso_gt: String
  iso_gte: String
  iso_contains: String
  iso_not_contains: String
  iso_starts_with: String
  iso_not_starts_with: String
  iso_ends_with: String
  iso_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CountryWhereInput!]
  OR: [CountryWhereInput!]
  NOT: [CountryWhereInput!]
}

input CountryWhereUniqueInput {
  id: ID
}

scalar DateTime

type DefaultScoringSystemDetail {
  id: ID!
  name: String!
  description: String!
  isActive: Boolean!
  isDefault: Boolean!
  startDate: DateTime!
  endDate: DateTime
  points: Int!
  range: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  scoringSystem: DefaultScoringSystemHeader!
  scoringType: ScoringType!
}

type DefaultScoringSystemDetailConnection {
  pageInfo: PageInfo!
  edges: [DefaultScoringSystemDetailEdge]!
  aggregate: AggregateDefaultScoringSystemDetail!
}

input DefaultScoringSystemDetailCreateInput {
  id: ID
  name: String!
  description: String!
  isActive: Boolean
  isDefault: Boolean
  startDate: DateTime
  endDate: DateTime
  points: Int
  range: Int
  scoringSystem: DefaultScoringSystemHeaderCreateOneWithoutSystemDetailInput!
  scoringType: ScoringTypeCreateOneInput!
}

input DefaultScoringSystemDetailCreateManyWithoutScoringSystemInput {
  create: [DefaultScoringSystemDetailCreateWithoutScoringSystemInput!]
  connect: [DefaultScoringSystemDetailWhereUniqueInput!]
}

input DefaultScoringSystemDetailCreateOneInput {
  create: DefaultScoringSystemDetailCreateInput
  connect: DefaultScoringSystemDetailWhereUniqueInput
}

input DefaultScoringSystemDetailCreateWithoutScoringSystemInput {
  id: ID
  name: String!
  description: String!
  isActive: Boolean
  isDefault: Boolean
  startDate: DateTime
  endDate: DateTime
  points: Int
  range: Int
  scoringType: ScoringTypeCreateOneInput!
}

type DefaultScoringSystemDetailEdge {
  node: DefaultScoringSystemDetail!
  cursor: String!
}

enum DefaultScoringSystemDetailOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  isActive_ASC
  isActive_DESC
  isDefault_ASC
  isDefault_DESC
  startDate_ASC
  startDate_DESC
  endDate_ASC
  endDate_DESC
  points_ASC
  points_DESC
  range_ASC
  range_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DefaultScoringSystemDetailPreviousValues {
  id: ID!
  name: String!
  description: String!
  isActive: Boolean!
  isDefault: Boolean!
  startDate: DateTime!
  endDate: DateTime
  points: Int!
  range: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input DefaultScoringSystemDetailScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  isActive: Boolean
  isActive_not: Boolean
  isDefault: Boolean
  isDefault_not: Boolean
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  points: Int
  points_not: Int
  points_in: [Int!]
  points_not_in: [Int!]
  points_lt: Int
  points_lte: Int
  points_gt: Int
  points_gte: Int
  range: Int
  range_not: Int
  range_in: [Int!]
  range_not_in: [Int!]
  range_lt: Int
  range_lte: Int
  range_gt: Int
  range_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [DefaultScoringSystemDetailScalarWhereInput!]
  OR: [DefaultScoringSystemDetailScalarWhereInput!]
  NOT: [DefaultScoringSystemDetailScalarWhereInput!]
}

type DefaultScoringSystemDetailSubscriptionPayload {
  mutation: MutationType!
  node: DefaultScoringSystemDetail
  updatedFields: [String!]
  previousValues: DefaultScoringSystemDetailPreviousValues
}

input DefaultScoringSystemDetailSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DefaultScoringSystemDetailWhereInput
  AND: [DefaultScoringSystemDetailSubscriptionWhereInput!]
  OR: [DefaultScoringSystemDetailSubscriptionWhereInput!]
  NOT: [DefaultScoringSystemDetailSubscriptionWhereInput!]
}

input DefaultScoringSystemDetailUpdateDataInput {
  name: String
  description: String
  isActive: Boolean
  isDefault: Boolean
  startDate: DateTime
  endDate: DateTime
  points: Int
  range: Int
  scoringSystem: DefaultScoringSystemHeaderUpdateOneRequiredWithoutSystemDetailInput
  scoringType: ScoringTypeUpdateOneRequiredInput
}

input DefaultScoringSystemDetailUpdateInput {
  name: String
  description: String
  isActive: Boolean
  isDefault: Boolean
  startDate: DateTime
  endDate: DateTime
  points: Int
  range: Int
  scoringSystem: DefaultScoringSystemHeaderUpdateOneRequiredWithoutSystemDetailInput
  scoringType: ScoringTypeUpdateOneRequiredInput
}

input DefaultScoringSystemDetailUpdateManyDataInput {
  name: String
  description: String
  isActive: Boolean
  isDefault: Boolean
  startDate: DateTime
  endDate: DateTime
  points: Int
  range: Int
}

input DefaultScoringSystemDetailUpdateManyMutationInput {
  name: String
  description: String
  isActive: Boolean
  isDefault: Boolean
  startDate: DateTime
  endDate: DateTime
  points: Int
  range: Int
}

input DefaultScoringSystemDetailUpdateManyWithoutScoringSystemInput {
  create: [DefaultScoringSystemDetailCreateWithoutScoringSystemInput!]
  delete: [DefaultScoringSystemDetailWhereUniqueInput!]
  connect: [DefaultScoringSystemDetailWhereUniqueInput!]
  set: [DefaultScoringSystemDetailWhereUniqueInput!]
  disconnect: [DefaultScoringSystemDetailWhereUniqueInput!]
  update: [DefaultScoringSystemDetailUpdateWithWhereUniqueWithoutScoringSystemInput!]
  upsert: [DefaultScoringSystemDetailUpsertWithWhereUniqueWithoutScoringSystemInput!]
  deleteMany: [DefaultScoringSystemDetailScalarWhereInput!]
  updateMany: [DefaultScoringSystemDetailUpdateManyWithWhereNestedInput!]
}

input DefaultScoringSystemDetailUpdateManyWithWhereNestedInput {
  where: DefaultScoringSystemDetailScalarWhereInput!
  data: DefaultScoringSystemDetailUpdateManyDataInput!
}

input DefaultScoringSystemDetailUpdateOneRequiredInput {
  create: DefaultScoringSystemDetailCreateInput
  update: DefaultScoringSystemDetailUpdateDataInput
  upsert: DefaultScoringSystemDetailUpsertNestedInput
  connect: DefaultScoringSystemDetailWhereUniqueInput
}

input DefaultScoringSystemDetailUpdateWithoutScoringSystemDataInput {
  name: String
  description: String
  isActive: Boolean
  isDefault: Boolean
  startDate: DateTime
  endDate: DateTime
  points: Int
  range: Int
  scoringType: ScoringTypeUpdateOneRequiredInput
}

input DefaultScoringSystemDetailUpdateWithWhereUniqueWithoutScoringSystemInput {
  where: DefaultScoringSystemDetailWhereUniqueInput!
  data: DefaultScoringSystemDetailUpdateWithoutScoringSystemDataInput!
}

input DefaultScoringSystemDetailUpsertNestedInput {
  update: DefaultScoringSystemDetailUpdateDataInput!
  create: DefaultScoringSystemDetailCreateInput!
}

input DefaultScoringSystemDetailUpsertWithWhereUniqueWithoutScoringSystemInput {
  where: DefaultScoringSystemDetailWhereUniqueInput!
  update: DefaultScoringSystemDetailUpdateWithoutScoringSystemDataInput!
  create: DefaultScoringSystemDetailCreateWithoutScoringSystemInput!
}

input DefaultScoringSystemDetailWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  isActive: Boolean
  isActive_not: Boolean
  isDefault: Boolean
  isDefault_not: Boolean
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  points: Int
  points_not: Int
  points_in: [Int!]
  points_not_in: [Int!]
  points_lt: Int
  points_lte: Int
  points_gt: Int
  points_gte: Int
  range: Int
  range_not: Int
  range_in: [Int!]
  range_not_in: [Int!]
  range_lt: Int
  range_lte: Int
  range_gt: Int
  range_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  scoringSystem: DefaultScoringSystemHeaderWhereInput
  scoringType: ScoringTypeWhereInput
  AND: [DefaultScoringSystemDetailWhereInput!]
  OR: [DefaultScoringSystemDetailWhereInput!]
  NOT: [DefaultScoringSystemDetailWhereInput!]
}

input DefaultScoringSystemDetailWhereUniqueInput {
  id: ID
}

type DefaultScoringSystemHeader {
  id: ID!
  name: String!
  description: String
  isCustom: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  systemDetail(where: DefaultScoringSystemDetailWhereInput, orderBy: DefaultScoringSystemDetailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DefaultScoringSystemDetail!]
}

type DefaultScoringSystemHeaderConnection {
  pageInfo: PageInfo!
  edges: [DefaultScoringSystemHeaderEdge]!
  aggregate: AggregateDefaultScoringSystemHeader!
}

input DefaultScoringSystemHeaderCreateInput {
  id: ID
  name: String!
  description: String
  isCustom: Boolean
  systemDetail: DefaultScoringSystemDetailCreateManyWithoutScoringSystemInput
}

input DefaultScoringSystemHeaderCreateOneInput {
  create: DefaultScoringSystemHeaderCreateInput
  connect: DefaultScoringSystemHeaderWhereUniqueInput
}

input DefaultScoringSystemHeaderCreateOneWithoutSystemDetailInput {
  create: DefaultScoringSystemHeaderCreateWithoutSystemDetailInput
  connect: DefaultScoringSystemHeaderWhereUniqueInput
}

input DefaultScoringSystemHeaderCreateWithoutSystemDetailInput {
  id: ID
  name: String!
  description: String
  isCustom: Boolean
}

type DefaultScoringSystemHeaderEdge {
  node: DefaultScoringSystemHeader!
  cursor: String!
}

enum DefaultScoringSystemHeaderOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  isCustom_ASC
  isCustom_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DefaultScoringSystemHeaderPreviousValues {
  id: ID!
  name: String!
  description: String
  isCustom: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DefaultScoringSystemHeaderSubscriptionPayload {
  mutation: MutationType!
  node: DefaultScoringSystemHeader
  updatedFields: [String!]
  previousValues: DefaultScoringSystemHeaderPreviousValues
}

input DefaultScoringSystemHeaderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DefaultScoringSystemHeaderWhereInput
  AND: [DefaultScoringSystemHeaderSubscriptionWhereInput!]
  OR: [DefaultScoringSystemHeaderSubscriptionWhereInput!]
  NOT: [DefaultScoringSystemHeaderSubscriptionWhereInput!]
}

input DefaultScoringSystemHeaderUpdateDataInput {
  name: String
  description: String
  isCustom: Boolean
  systemDetail: DefaultScoringSystemDetailUpdateManyWithoutScoringSystemInput
}

input DefaultScoringSystemHeaderUpdateInput {
  name: String
  description: String
  isCustom: Boolean
  systemDetail: DefaultScoringSystemDetailUpdateManyWithoutScoringSystemInput
}

input DefaultScoringSystemHeaderUpdateManyMutationInput {
  name: String
  description: String
  isCustom: Boolean
}

input DefaultScoringSystemHeaderUpdateOneInput {
  create: DefaultScoringSystemHeaderCreateInput
  update: DefaultScoringSystemHeaderUpdateDataInput
  upsert: DefaultScoringSystemHeaderUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: DefaultScoringSystemHeaderWhereUniqueInput
}

input DefaultScoringSystemHeaderUpdateOneRequiredWithoutSystemDetailInput {
  create: DefaultScoringSystemHeaderCreateWithoutSystemDetailInput
  update: DefaultScoringSystemHeaderUpdateWithoutSystemDetailDataInput
  upsert: DefaultScoringSystemHeaderUpsertWithoutSystemDetailInput
  connect: DefaultScoringSystemHeaderWhereUniqueInput
}

input DefaultScoringSystemHeaderUpdateWithoutSystemDetailDataInput {
  name: String
  description: String
  isCustom: Boolean
}

input DefaultScoringSystemHeaderUpsertNestedInput {
  update: DefaultScoringSystemHeaderUpdateDataInput!
  create: DefaultScoringSystemHeaderCreateInput!
}

input DefaultScoringSystemHeaderUpsertWithoutSystemDetailInput {
  update: DefaultScoringSystemHeaderUpdateWithoutSystemDetailDataInput!
  create: DefaultScoringSystemHeaderCreateWithoutSystemDetailInput!
}

input DefaultScoringSystemHeaderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  isCustom: Boolean
  isCustom_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  systemDetail_every: DefaultScoringSystemDetailWhereInput
  systemDetail_some: DefaultScoringSystemDetailWhereInput
  systemDetail_none: DefaultScoringSystemDetailWhereInput
  AND: [DefaultScoringSystemHeaderWhereInput!]
  OR: [DefaultScoringSystemHeaderWhereInput!]
  NOT: [DefaultScoringSystemHeaderWhereInput!]
}

input DefaultScoringSystemHeaderWhereUniqueInput {
  id: ID
}

type FandemSubscription {
  id: ID!
  name: String!
  description: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FandemSubscriptionConnection {
  pageInfo: PageInfo!
  edges: [FandemSubscriptionEdge]!
  aggregate: AggregateFandemSubscription!
}

input FandemSubscriptionCreateInput {
  id: ID
  name: String!
  description: String!
}

input FandemSubscriptionCreateManyInput {
  create: [FandemSubscriptionCreateInput!]
  connect: [FandemSubscriptionWhereUniqueInput!]
}

type FandemSubscriptionEdge {
  node: FandemSubscription!
  cursor: String!
}

enum FandemSubscriptionOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FandemSubscriptionPreviousValues {
  id: ID!
  name: String!
  description: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input FandemSubscriptionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FandemSubscriptionScalarWhereInput!]
  OR: [FandemSubscriptionScalarWhereInput!]
  NOT: [FandemSubscriptionScalarWhereInput!]
}

type FandemSubscriptionSubscriptionPayload {
  mutation: MutationType!
  node: FandemSubscription
  updatedFields: [String!]
  previousValues: FandemSubscriptionPreviousValues
}

input FandemSubscriptionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FandemSubscriptionWhereInput
  AND: [FandemSubscriptionSubscriptionWhereInput!]
  OR: [FandemSubscriptionSubscriptionWhereInput!]
  NOT: [FandemSubscriptionSubscriptionWhereInput!]
}

input FandemSubscriptionUpdateDataInput {
  name: String
  description: String
}

input FandemSubscriptionUpdateInput {
  name: String
  description: String
}

input FandemSubscriptionUpdateManyDataInput {
  name: String
  description: String
}

input FandemSubscriptionUpdateManyInput {
  create: [FandemSubscriptionCreateInput!]
  update: [FandemSubscriptionUpdateWithWhereUniqueNestedInput!]
  upsert: [FandemSubscriptionUpsertWithWhereUniqueNestedInput!]
  delete: [FandemSubscriptionWhereUniqueInput!]
  connect: [FandemSubscriptionWhereUniqueInput!]
  set: [FandemSubscriptionWhereUniqueInput!]
  disconnect: [FandemSubscriptionWhereUniqueInput!]
  deleteMany: [FandemSubscriptionScalarWhereInput!]
  updateMany: [FandemSubscriptionUpdateManyWithWhereNestedInput!]
}

input FandemSubscriptionUpdateManyMutationInput {
  name: String
  description: String
}

input FandemSubscriptionUpdateManyWithWhereNestedInput {
  where: FandemSubscriptionScalarWhereInput!
  data: FandemSubscriptionUpdateManyDataInput!
}

input FandemSubscriptionUpdateWithWhereUniqueNestedInput {
  where: FandemSubscriptionWhereUniqueInput!
  data: FandemSubscriptionUpdateDataInput!
}

input FandemSubscriptionUpsertWithWhereUniqueNestedInput {
  where: FandemSubscriptionWhereUniqueInput!
  update: FandemSubscriptionUpdateDataInput!
  create: FandemSubscriptionCreateInput!
}

input FandemSubscriptionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FandemSubscriptionWhereInput!]
  OR: [FandemSubscriptionWhereInput!]
  NOT: [FandemSubscriptionWhereInput!]
}

input FandemSubscriptionWhereUniqueInput {
  id: ID
}

type Fixture {
  id: ID!
  fplCode: Int!
  event: Gameweek!
  finished: Boolean!
  finishedProvisional: Boolean!
  fixtureId: Int!
  kickoffTime: DateTime
  minutes: Int!
  provisionalStartTime: Boolean!
  started: Boolean!
  teamA: AwayTeamFixture!
  teamADifficulty: Int!
  teamAScore: Int
  teamH: HomeTeamFixture!
  teamHDifficulty: Int!
  teamHScore: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FixtureConnection {
  pageInfo: PageInfo!
  edges: [FixtureEdge]!
  aggregate: AggregateFixture!
}

input FixtureCreateInput {
  id: ID
  fplCode: Int!
  event: GameweekCreateOneWithoutFixturesInput!
  finished: Boolean!
  finishedProvisional: Boolean!
  fixtureId: Int!
  kickoffTime: DateTime
  minutes: Int!
  provisionalStartTime: Boolean!
  started: Boolean!
  teamA: AwayTeamFixtureCreateOneWithoutFixtureInput!
  teamADifficulty: Int!
  teamAScore: Int
  teamH: HomeTeamFixtureCreateOneWithoutFixtureInput!
  teamHDifficulty: Int!
  teamHScore: Int
}

input FixtureCreateManyWithoutEventInput {
  create: [FixtureCreateWithoutEventInput!]
  connect: [FixtureWhereUniqueInput!]
}

input FixtureCreateOneInput {
  create: FixtureCreateInput
  connect: FixtureWhereUniqueInput
}

input FixtureCreateOneWithoutTeamAInput {
  create: FixtureCreateWithoutTeamAInput
  connect: FixtureWhereUniqueInput
}

input FixtureCreateOneWithoutTeamHInput {
  create: FixtureCreateWithoutTeamHInput
  connect: FixtureWhereUniqueInput
}

input FixtureCreateWithoutEventInput {
  id: ID
  fplCode: Int!
  finished: Boolean!
  finishedProvisional: Boolean!
  fixtureId: Int!
  kickoffTime: DateTime
  minutes: Int!
  provisionalStartTime: Boolean!
  started: Boolean!
  teamA: AwayTeamFixtureCreateOneWithoutFixtureInput!
  teamADifficulty: Int!
  teamAScore: Int
  teamH: HomeTeamFixtureCreateOneWithoutFixtureInput!
  teamHDifficulty: Int!
  teamHScore: Int
}

input FixtureCreateWithoutTeamAInput {
  id: ID
  fplCode: Int!
  event: GameweekCreateOneWithoutFixturesInput!
  finished: Boolean!
  finishedProvisional: Boolean!
  fixtureId: Int!
  kickoffTime: DateTime
  minutes: Int!
  provisionalStartTime: Boolean!
  started: Boolean!
  teamADifficulty: Int!
  teamAScore: Int
  teamH: HomeTeamFixtureCreateOneWithoutFixtureInput!
  teamHDifficulty: Int!
  teamHScore: Int
}

input FixtureCreateWithoutTeamHInput {
  id: ID
  fplCode: Int!
  event: GameweekCreateOneWithoutFixturesInput!
  finished: Boolean!
  finishedProvisional: Boolean!
  fixtureId: Int!
  kickoffTime: DateTime
  minutes: Int!
  provisionalStartTime: Boolean!
  started: Boolean!
  teamA: AwayTeamFixtureCreateOneWithoutFixtureInput!
  teamADifficulty: Int!
  teamAScore: Int
  teamHDifficulty: Int!
  teamHScore: Int
}

type FixtureEdge {
  node: Fixture!
  cursor: String!
}

enum FixtureOrderByInput {
  id_ASC
  id_DESC
  fplCode_ASC
  fplCode_DESC
  finished_ASC
  finished_DESC
  finishedProvisional_ASC
  finishedProvisional_DESC
  fixtureId_ASC
  fixtureId_DESC
  kickoffTime_ASC
  kickoffTime_DESC
  minutes_ASC
  minutes_DESC
  provisionalStartTime_ASC
  provisionalStartTime_DESC
  started_ASC
  started_DESC
  teamADifficulty_ASC
  teamADifficulty_DESC
  teamAScore_ASC
  teamAScore_DESC
  teamHDifficulty_ASC
  teamHDifficulty_DESC
  teamHScore_ASC
  teamHScore_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FixturePreviousValues {
  id: ID!
  fplCode: Int!
  finished: Boolean!
  finishedProvisional: Boolean!
  fixtureId: Int!
  kickoffTime: DateTime
  minutes: Int!
  provisionalStartTime: Boolean!
  started: Boolean!
  teamADifficulty: Int!
  teamAScore: Int
  teamHDifficulty: Int!
  teamHScore: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

input FixtureScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fplCode: Int
  fplCode_not: Int
  fplCode_in: [Int!]
  fplCode_not_in: [Int!]
  fplCode_lt: Int
  fplCode_lte: Int
  fplCode_gt: Int
  fplCode_gte: Int
  finished: Boolean
  finished_not: Boolean
  finishedProvisional: Boolean
  finishedProvisional_not: Boolean
  fixtureId: Int
  fixtureId_not: Int
  fixtureId_in: [Int!]
  fixtureId_not_in: [Int!]
  fixtureId_lt: Int
  fixtureId_lte: Int
  fixtureId_gt: Int
  fixtureId_gte: Int
  kickoffTime: DateTime
  kickoffTime_not: DateTime
  kickoffTime_in: [DateTime!]
  kickoffTime_not_in: [DateTime!]
  kickoffTime_lt: DateTime
  kickoffTime_lte: DateTime
  kickoffTime_gt: DateTime
  kickoffTime_gte: DateTime
  minutes: Int
  minutes_not: Int
  minutes_in: [Int!]
  minutes_not_in: [Int!]
  minutes_lt: Int
  minutes_lte: Int
  minutes_gt: Int
  minutes_gte: Int
  provisionalStartTime: Boolean
  provisionalStartTime_not: Boolean
  started: Boolean
  started_not: Boolean
  teamADifficulty: Int
  teamADifficulty_not: Int
  teamADifficulty_in: [Int!]
  teamADifficulty_not_in: [Int!]
  teamADifficulty_lt: Int
  teamADifficulty_lte: Int
  teamADifficulty_gt: Int
  teamADifficulty_gte: Int
  teamAScore: Int
  teamAScore_not: Int
  teamAScore_in: [Int!]
  teamAScore_not_in: [Int!]
  teamAScore_lt: Int
  teamAScore_lte: Int
  teamAScore_gt: Int
  teamAScore_gte: Int
  teamHDifficulty: Int
  teamHDifficulty_not: Int
  teamHDifficulty_in: [Int!]
  teamHDifficulty_not_in: [Int!]
  teamHDifficulty_lt: Int
  teamHDifficulty_lte: Int
  teamHDifficulty_gt: Int
  teamHDifficulty_gte: Int
  teamHScore: Int
  teamHScore_not: Int
  teamHScore_in: [Int!]
  teamHScore_not_in: [Int!]
  teamHScore_lt: Int
  teamHScore_lte: Int
  teamHScore_gt: Int
  teamHScore_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FixtureScalarWhereInput!]
  OR: [FixtureScalarWhereInput!]
  NOT: [FixtureScalarWhereInput!]
}

type FixtureSubscriptionPayload {
  mutation: MutationType!
  node: Fixture
  updatedFields: [String!]
  previousValues: FixturePreviousValues
}

input FixtureSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FixtureWhereInput
  AND: [FixtureSubscriptionWhereInput!]
  OR: [FixtureSubscriptionWhereInput!]
  NOT: [FixtureSubscriptionWhereInput!]
}

input FixtureUpdateDataInput {
  fplCode: Int
  event: GameweekUpdateOneRequiredWithoutFixturesInput
  finished: Boolean
  finishedProvisional: Boolean
  fixtureId: Int
  kickoffTime: DateTime
  minutes: Int
  provisionalStartTime: Boolean
  started: Boolean
  teamA: AwayTeamFixtureUpdateOneRequiredWithoutFixtureInput
  teamADifficulty: Int
  teamAScore: Int
  teamH: HomeTeamFixtureUpdateOneRequiredWithoutFixtureInput
  teamHDifficulty: Int
  teamHScore: Int
}

input FixtureUpdateInput {
  fplCode: Int
  event: GameweekUpdateOneRequiredWithoutFixturesInput
  finished: Boolean
  finishedProvisional: Boolean
  fixtureId: Int
  kickoffTime: DateTime
  minutes: Int
  provisionalStartTime: Boolean
  started: Boolean
  teamA: AwayTeamFixtureUpdateOneRequiredWithoutFixtureInput
  teamADifficulty: Int
  teamAScore: Int
  teamH: HomeTeamFixtureUpdateOneRequiredWithoutFixtureInput
  teamHDifficulty: Int
  teamHScore: Int
}

input FixtureUpdateManyDataInput {
  fplCode: Int
  finished: Boolean
  finishedProvisional: Boolean
  fixtureId: Int
  kickoffTime: DateTime
  minutes: Int
  provisionalStartTime: Boolean
  started: Boolean
  teamADifficulty: Int
  teamAScore: Int
  teamHDifficulty: Int
  teamHScore: Int
}

input FixtureUpdateManyMutationInput {
  fplCode: Int
  finished: Boolean
  finishedProvisional: Boolean
  fixtureId: Int
  kickoffTime: DateTime
  minutes: Int
  provisionalStartTime: Boolean
  started: Boolean
  teamADifficulty: Int
  teamAScore: Int
  teamHDifficulty: Int
  teamHScore: Int
}

input FixtureUpdateManyWithoutEventInput {
  create: [FixtureCreateWithoutEventInput!]
  delete: [FixtureWhereUniqueInput!]
  connect: [FixtureWhereUniqueInput!]
  set: [FixtureWhereUniqueInput!]
  disconnect: [FixtureWhereUniqueInput!]
  update: [FixtureUpdateWithWhereUniqueWithoutEventInput!]
  upsert: [FixtureUpsertWithWhereUniqueWithoutEventInput!]
  deleteMany: [FixtureScalarWhereInput!]
  updateMany: [FixtureUpdateManyWithWhereNestedInput!]
}

input FixtureUpdateManyWithWhereNestedInput {
  where: FixtureScalarWhereInput!
  data: FixtureUpdateManyDataInput!
}

input FixtureUpdateOneRequiredInput {
  create: FixtureCreateInput
  update: FixtureUpdateDataInput
  upsert: FixtureUpsertNestedInput
  connect: FixtureWhereUniqueInput
}

input FixtureUpdateOneRequiredWithoutTeamAInput {
  create: FixtureCreateWithoutTeamAInput
  update: FixtureUpdateWithoutTeamADataInput
  upsert: FixtureUpsertWithoutTeamAInput
  connect: FixtureWhereUniqueInput
}

input FixtureUpdateOneRequiredWithoutTeamHInput {
  create: FixtureCreateWithoutTeamHInput
  update: FixtureUpdateWithoutTeamHDataInput
  upsert: FixtureUpsertWithoutTeamHInput
  connect: FixtureWhereUniqueInput
}

input FixtureUpdateWithoutEventDataInput {
  fplCode: Int
  finished: Boolean
  finishedProvisional: Boolean
  fixtureId: Int
  kickoffTime: DateTime
  minutes: Int
  provisionalStartTime: Boolean
  started: Boolean
  teamA: AwayTeamFixtureUpdateOneRequiredWithoutFixtureInput
  teamADifficulty: Int
  teamAScore: Int
  teamH: HomeTeamFixtureUpdateOneRequiredWithoutFixtureInput
  teamHDifficulty: Int
  teamHScore: Int
}

input FixtureUpdateWithoutTeamADataInput {
  fplCode: Int
  event: GameweekUpdateOneRequiredWithoutFixturesInput
  finished: Boolean
  finishedProvisional: Boolean
  fixtureId: Int
  kickoffTime: DateTime
  minutes: Int
  provisionalStartTime: Boolean
  started: Boolean
  teamADifficulty: Int
  teamAScore: Int
  teamH: HomeTeamFixtureUpdateOneRequiredWithoutFixtureInput
  teamHDifficulty: Int
  teamHScore: Int
}

input FixtureUpdateWithoutTeamHDataInput {
  fplCode: Int
  event: GameweekUpdateOneRequiredWithoutFixturesInput
  finished: Boolean
  finishedProvisional: Boolean
  fixtureId: Int
  kickoffTime: DateTime
  minutes: Int
  provisionalStartTime: Boolean
  started: Boolean
  teamA: AwayTeamFixtureUpdateOneRequiredWithoutFixtureInput
  teamADifficulty: Int
  teamAScore: Int
  teamHDifficulty: Int
  teamHScore: Int
}

input FixtureUpdateWithWhereUniqueWithoutEventInput {
  where: FixtureWhereUniqueInput!
  data: FixtureUpdateWithoutEventDataInput!
}

input FixtureUpsertNestedInput {
  update: FixtureUpdateDataInput!
  create: FixtureCreateInput!
}

input FixtureUpsertWithoutTeamAInput {
  update: FixtureUpdateWithoutTeamADataInput!
  create: FixtureCreateWithoutTeamAInput!
}

input FixtureUpsertWithoutTeamHInput {
  update: FixtureUpdateWithoutTeamHDataInput!
  create: FixtureCreateWithoutTeamHInput!
}

input FixtureUpsertWithWhereUniqueWithoutEventInput {
  where: FixtureWhereUniqueInput!
  update: FixtureUpdateWithoutEventDataInput!
  create: FixtureCreateWithoutEventInput!
}

input FixtureWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fplCode: Int
  fplCode_not: Int
  fplCode_in: [Int!]
  fplCode_not_in: [Int!]
  fplCode_lt: Int
  fplCode_lte: Int
  fplCode_gt: Int
  fplCode_gte: Int
  event: GameweekWhereInput
  finished: Boolean
  finished_not: Boolean
  finishedProvisional: Boolean
  finishedProvisional_not: Boolean
  fixtureId: Int
  fixtureId_not: Int
  fixtureId_in: [Int!]
  fixtureId_not_in: [Int!]
  fixtureId_lt: Int
  fixtureId_lte: Int
  fixtureId_gt: Int
  fixtureId_gte: Int
  kickoffTime: DateTime
  kickoffTime_not: DateTime
  kickoffTime_in: [DateTime!]
  kickoffTime_not_in: [DateTime!]
  kickoffTime_lt: DateTime
  kickoffTime_lte: DateTime
  kickoffTime_gt: DateTime
  kickoffTime_gte: DateTime
  minutes: Int
  minutes_not: Int
  minutes_in: [Int!]
  minutes_not_in: [Int!]
  minutes_lt: Int
  minutes_lte: Int
  minutes_gt: Int
  minutes_gte: Int
  provisionalStartTime: Boolean
  provisionalStartTime_not: Boolean
  started: Boolean
  started_not: Boolean
  teamA: AwayTeamFixtureWhereInput
  teamADifficulty: Int
  teamADifficulty_not: Int
  teamADifficulty_in: [Int!]
  teamADifficulty_not_in: [Int!]
  teamADifficulty_lt: Int
  teamADifficulty_lte: Int
  teamADifficulty_gt: Int
  teamADifficulty_gte: Int
  teamAScore: Int
  teamAScore_not: Int
  teamAScore_in: [Int!]
  teamAScore_not_in: [Int!]
  teamAScore_lt: Int
  teamAScore_lte: Int
  teamAScore_gt: Int
  teamAScore_gte: Int
  teamH: HomeTeamFixtureWhereInput
  teamHDifficulty: Int
  teamHDifficulty_not: Int
  teamHDifficulty_in: [Int!]
  teamHDifficulty_not_in: [Int!]
  teamHDifficulty_lt: Int
  teamHDifficulty_lte: Int
  teamHDifficulty_gt: Int
  teamHDifficulty_gte: Int
  teamHScore: Int
  teamHScore_not: Int
  teamHScore_in: [Int!]
  teamHScore_not_in: [Int!]
  teamHScore_lt: Int
  teamHScore_lte: Int
  teamHScore_gt: Int
  teamHScore_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FixtureWhereInput!]
  OR: [FixtureWhereInput!]
  NOT: [FixtureWhereInput!]
}

input FixtureWhereUniqueInput {
  id: ID
  fplCode: Int
}

type Follower {
  id: ID!
  user: User!
  blocked: Boolean!
  accepted: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type FollowerConnection {
  pageInfo: PageInfo!
  edges: [FollowerEdge]!
  aggregate: AggregateFollower!
}

input FollowerCreateInput {
  id: ID
  user: UserCreateOneInput!
  blocked: Boolean
  accepted: Boolean
}

input FollowerCreateManyInput {
  create: [FollowerCreateInput!]
  connect: [FollowerWhereUniqueInput!]
}

type FollowerEdge {
  node: Follower!
  cursor: String!
}

enum FollowerOrderByInput {
  id_ASC
  id_DESC
  blocked_ASC
  blocked_DESC
  accepted_ASC
  accepted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FollowerPreviousValues {
  id: ID!
  blocked: Boolean!
  accepted: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input FollowerScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  blocked: Boolean
  blocked_not: Boolean
  accepted: Boolean
  accepted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FollowerScalarWhereInput!]
  OR: [FollowerScalarWhereInput!]
  NOT: [FollowerScalarWhereInput!]
}

type FollowerSubscriptionPayload {
  mutation: MutationType!
  node: Follower
  updatedFields: [String!]
  previousValues: FollowerPreviousValues
}

input FollowerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FollowerWhereInput
  AND: [FollowerSubscriptionWhereInput!]
  OR: [FollowerSubscriptionWhereInput!]
  NOT: [FollowerSubscriptionWhereInput!]
}

input FollowerUpdateDataInput {
  user: UserUpdateOneRequiredInput
  blocked: Boolean
  accepted: Boolean
}

input FollowerUpdateInput {
  user: UserUpdateOneRequiredInput
  blocked: Boolean
  accepted: Boolean
}

input FollowerUpdateManyDataInput {
  blocked: Boolean
  accepted: Boolean
}

input FollowerUpdateManyInput {
  create: [FollowerCreateInput!]
  update: [FollowerUpdateWithWhereUniqueNestedInput!]
  upsert: [FollowerUpsertWithWhereUniqueNestedInput!]
  delete: [FollowerWhereUniqueInput!]
  connect: [FollowerWhereUniqueInput!]
  set: [FollowerWhereUniqueInput!]
  disconnect: [FollowerWhereUniqueInput!]
  deleteMany: [FollowerScalarWhereInput!]
  updateMany: [FollowerUpdateManyWithWhereNestedInput!]
}

input FollowerUpdateManyMutationInput {
  blocked: Boolean
  accepted: Boolean
}

input FollowerUpdateManyWithWhereNestedInput {
  where: FollowerScalarWhereInput!
  data: FollowerUpdateManyDataInput!
}

input FollowerUpdateWithWhereUniqueNestedInput {
  where: FollowerWhereUniqueInput!
  data: FollowerUpdateDataInput!
}

input FollowerUpsertWithWhereUniqueNestedInput {
  where: FollowerWhereUniqueInput!
  update: FollowerUpdateDataInput!
  create: FollowerCreateInput!
}

input FollowerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  blocked: Boolean
  blocked_not: Boolean
  accepted: Boolean
  accepted_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FollowerWhereInput!]
  OR: [FollowerWhereInput!]
  NOT: [FollowerWhereInput!]
}

input FollowerWhereUniqueInput {
  id: ID
}

type Gameweek {
  id: ID!
  season: Season!
  averageEntryScore: Int
  dataChecked: Boolean!
  deadlineTime: DateTime!
  deadlineTimeEpoch: Int!
  deadlineTimeGameOffset: Int!
  finished: Boolean!
  highestScore: Int
  highestScoringEntry: Int
  fplEventId: Int!
  isCurrent: Boolean!
  isNext: Boolean!
  isPrevious: Boolean!
  name: String!
  fixtures(where: FixtureWhereInput, orderBy: FixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Fixture!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GameweekConnection {
  pageInfo: PageInfo!
  edges: [GameweekEdge]!
  aggregate: AggregateGameweek!
}

input GameweekCreateInput {
  id: ID
  season: SeasonCreateOneWithoutEventsInput!
  averageEntryScore: Int
  dataChecked: Boolean!
  deadlineTime: DateTime!
  deadlineTimeEpoch: Int!
  deadlineTimeGameOffset: Int!
  finished: Boolean!
  highestScore: Int
  highestScoringEntry: Int
  fplEventId: Int!
  isCurrent: Boolean!
  isNext: Boolean!
  isPrevious: Boolean!
  name: String!
  fixtures: FixtureCreateManyWithoutEventInput
}

input GameweekCreateManyWithoutSeasonInput {
  create: [GameweekCreateWithoutSeasonInput!]
  connect: [GameweekWhereUniqueInput!]
}

input GameweekCreateOneInput {
  create: GameweekCreateInput
  connect: GameweekWhereUniqueInput
}

input GameweekCreateOneWithoutFixturesInput {
  create: GameweekCreateWithoutFixturesInput
  connect: GameweekWhereUniqueInput
}

input GameweekCreateWithoutFixturesInput {
  id: ID
  season: SeasonCreateOneWithoutEventsInput!
  averageEntryScore: Int
  dataChecked: Boolean!
  deadlineTime: DateTime!
  deadlineTimeEpoch: Int!
  deadlineTimeGameOffset: Int!
  finished: Boolean!
  highestScore: Int
  highestScoringEntry: Int
  fplEventId: Int!
  isCurrent: Boolean!
  isNext: Boolean!
  isPrevious: Boolean!
  name: String!
}

input GameweekCreateWithoutSeasonInput {
  id: ID
  averageEntryScore: Int
  dataChecked: Boolean!
  deadlineTime: DateTime!
  deadlineTimeEpoch: Int!
  deadlineTimeGameOffset: Int!
  finished: Boolean!
  highestScore: Int
  highestScoringEntry: Int
  fplEventId: Int!
  isCurrent: Boolean!
  isNext: Boolean!
  isPrevious: Boolean!
  name: String!
  fixtures: FixtureCreateManyWithoutEventInput
}

type GameweekEdge {
  node: Gameweek!
  cursor: String!
}

enum GameweekOrderByInput {
  id_ASC
  id_DESC
  averageEntryScore_ASC
  averageEntryScore_DESC
  dataChecked_ASC
  dataChecked_DESC
  deadlineTime_ASC
  deadlineTime_DESC
  deadlineTimeEpoch_ASC
  deadlineTimeEpoch_DESC
  deadlineTimeGameOffset_ASC
  deadlineTimeGameOffset_DESC
  finished_ASC
  finished_DESC
  highestScore_ASC
  highestScore_DESC
  highestScoringEntry_ASC
  highestScoringEntry_DESC
  fplEventId_ASC
  fplEventId_DESC
  isCurrent_ASC
  isCurrent_DESC
  isNext_ASC
  isNext_DESC
  isPrevious_ASC
  isPrevious_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GameweekPreviousValues {
  id: ID!
  averageEntryScore: Int
  dataChecked: Boolean!
  deadlineTime: DateTime!
  deadlineTimeEpoch: Int!
  deadlineTimeGameOffset: Int!
  finished: Boolean!
  highestScore: Int
  highestScoringEntry: Int
  fplEventId: Int!
  isCurrent: Boolean!
  isNext: Boolean!
  isPrevious: Boolean!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input GameweekScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  averageEntryScore: Int
  averageEntryScore_not: Int
  averageEntryScore_in: [Int!]
  averageEntryScore_not_in: [Int!]
  averageEntryScore_lt: Int
  averageEntryScore_lte: Int
  averageEntryScore_gt: Int
  averageEntryScore_gte: Int
  dataChecked: Boolean
  dataChecked_not: Boolean
  deadlineTime: DateTime
  deadlineTime_not: DateTime
  deadlineTime_in: [DateTime!]
  deadlineTime_not_in: [DateTime!]
  deadlineTime_lt: DateTime
  deadlineTime_lte: DateTime
  deadlineTime_gt: DateTime
  deadlineTime_gte: DateTime
  deadlineTimeEpoch: Int
  deadlineTimeEpoch_not: Int
  deadlineTimeEpoch_in: [Int!]
  deadlineTimeEpoch_not_in: [Int!]
  deadlineTimeEpoch_lt: Int
  deadlineTimeEpoch_lte: Int
  deadlineTimeEpoch_gt: Int
  deadlineTimeEpoch_gte: Int
  deadlineTimeGameOffset: Int
  deadlineTimeGameOffset_not: Int
  deadlineTimeGameOffset_in: [Int!]
  deadlineTimeGameOffset_not_in: [Int!]
  deadlineTimeGameOffset_lt: Int
  deadlineTimeGameOffset_lte: Int
  deadlineTimeGameOffset_gt: Int
  deadlineTimeGameOffset_gte: Int
  finished: Boolean
  finished_not: Boolean
  highestScore: Int
  highestScore_not: Int
  highestScore_in: [Int!]
  highestScore_not_in: [Int!]
  highestScore_lt: Int
  highestScore_lte: Int
  highestScore_gt: Int
  highestScore_gte: Int
  highestScoringEntry: Int
  highestScoringEntry_not: Int
  highestScoringEntry_in: [Int!]
  highestScoringEntry_not_in: [Int!]
  highestScoringEntry_lt: Int
  highestScoringEntry_lte: Int
  highestScoringEntry_gt: Int
  highestScoringEntry_gte: Int
  fplEventId: Int
  fplEventId_not: Int
  fplEventId_in: [Int!]
  fplEventId_not_in: [Int!]
  fplEventId_lt: Int
  fplEventId_lte: Int
  fplEventId_gt: Int
  fplEventId_gte: Int
  isCurrent: Boolean
  isCurrent_not: Boolean
  isNext: Boolean
  isNext_not: Boolean
  isPrevious: Boolean
  isPrevious_not: Boolean
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [GameweekScalarWhereInput!]
  OR: [GameweekScalarWhereInput!]
  NOT: [GameweekScalarWhereInput!]
}

type GameweekSubscriptionPayload {
  mutation: MutationType!
  node: Gameweek
  updatedFields: [String!]
  previousValues: GameweekPreviousValues
}

input GameweekSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GameweekWhereInput
  AND: [GameweekSubscriptionWhereInput!]
  OR: [GameweekSubscriptionWhereInput!]
  NOT: [GameweekSubscriptionWhereInput!]
}

input GameweekUpdateDataInput {
  season: SeasonUpdateOneRequiredWithoutEventsInput
  averageEntryScore: Int
  dataChecked: Boolean
  deadlineTime: DateTime
  deadlineTimeEpoch: Int
  deadlineTimeGameOffset: Int
  finished: Boolean
  highestScore: Int
  highestScoringEntry: Int
  fplEventId: Int
  isCurrent: Boolean
  isNext: Boolean
  isPrevious: Boolean
  name: String
  fixtures: FixtureUpdateManyWithoutEventInput
}

input GameweekUpdateInput {
  season: SeasonUpdateOneRequiredWithoutEventsInput
  averageEntryScore: Int
  dataChecked: Boolean
  deadlineTime: DateTime
  deadlineTimeEpoch: Int
  deadlineTimeGameOffset: Int
  finished: Boolean
  highestScore: Int
  highestScoringEntry: Int
  fplEventId: Int
  isCurrent: Boolean
  isNext: Boolean
  isPrevious: Boolean
  name: String
  fixtures: FixtureUpdateManyWithoutEventInput
}

input GameweekUpdateManyDataInput {
  averageEntryScore: Int
  dataChecked: Boolean
  deadlineTime: DateTime
  deadlineTimeEpoch: Int
  deadlineTimeGameOffset: Int
  finished: Boolean
  highestScore: Int
  highestScoringEntry: Int
  fplEventId: Int
  isCurrent: Boolean
  isNext: Boolean
  isPrevious: Boolean
  name: String
}

input GameweekUpdateManyMutationInput {
  averageEntryScore: Int
  dataChecked: Boolean
  deadlineTime: DateTime
  deadlineTimeEpoch: Int
  deadlineTimeGameOffset: Int
  finished: Boolean
  highestScore: Int
  highestScoringEntry: Int
  fplEventId: Int
  isCurrent: Boolean
  isNext: Boolean
  isPrevious: Boolean
  name: String
}

input GameweekUpdateManyWithoutSeasonInput {
  create: [GameweekCreateWithoutSeasonInput!]
  delete: [GameweekWhereUniqueInput!]
  connect: [GameweekWhereUniqueInput!]
  set: [GameweekWhereUniqueInput!]
  disconnect: [GameweekWhereUniqueInput!]
  update: [GameweekUpdateWithWhereUniqueWithoutSeasonInput!]
  upsert: [GameweekUpsertWithWhereUniqueWithoutSeasonInput!]
  deleteMany: [GameweekScalarWhereInput!]
  updateMany: [GameweekUpdateManyWithWhereNestedInput!]
}

input GameweekUpdateManyWithWhereNestedInput {
  where: GameweekScalarWhereInput!
  data: GameweekUpdateManyDataInput!
}

input GameweekUpdateOneInput {
  create: GameweekCreateInput
  update: GameweekUpdateDataInput
  upsert: GameweekUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: GameweekWhereUniqueInput
}

input GameweekUpdateOneRequiredWithoutFixturesInput {
  create: GameweekCreateWithoutFixturesInput
  update: GameweekUpdateWithoutFixturesDataInput
  upsert: GameweekUpsertWithoutFixturesInput
  connect: GameweekWhereUniqueInput
}

input GameweekUpdateWithoutFixturesDataInput {
  season: SeasonUpdateOneRequiredWithoutEventsInput
  averageEntryScore: Int
  dataChecked: Boolean
  deadlineTime: DateTime
  deadlineTimeEpoch: Int
  deadlineTimeGameOffset: Int
  finished: Boolean
  highestScore: Int
  highestScoringEntry: Int
  fplEventId: Int
  isCurrent: Boolean
  isNext: Boolean
  isPrevious: Boolean
  name: String
}

input GameweekUpdateWithoutSeasonDataInput {
  averageEntryScore: Int
  dataChecked: Boolean
  deadlineTime: DateTime
  deadlineTimeEpoch: Int
  deadlineTimeGameOffset: Int
  finished: Boolean
  highestScore: Int
  highestScoringEntry: Int
  fplEventId: Int
  isCurrent: Boolean
  isNext: Boolean
  isPrevious: Boolean
  name: String
  fixtures: FixtureUpdateManyWithoutEventInput
}

input GameweekUpdateWithWhereUniqueWithoutSeasonInput {
  where: GameweekWhereUniqueInput!
  data: GameweekUpdateWithoutSeasonDataInput!
}

input GameweekUpsertNestedInput {
  update: GameweekUpdateDataInput!
  create: GameweekCreateInput!
}

input GameweekUpsertWithoutFixturesInput {
  update: GameweekUpdateWithoutFixturesDataInput!
  create: GameweekCreateWithoutFixturesInput!
}

input GameweekUpsertWithWhereUniqueWithoutSeasonInput {
  where: GameweekWhereUniqueInput!
  update: GameweekUpdateWithoutSeasonDataInput!
  create: GameweekCreateWithoutSeasonInput!
}

input GameweekWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  season: SeasonWhereInput
  averageEntryScore: Int
  averageEntryScore_not: Int
  averageEntryScore_in: [Int!]
  averageEntryScore_not_in: [Int!]
  averageEntryScore_lt: Int
  averageEntryScore_lte: Int
  averageEntryScore_gt: Int
  averageEntryScore_gte: Int
  dataChecked: Boolean
  dataChecked_not: Boolean
  deadlineTime: DateTime
  deadlineTime_not: DateTime
  deadlineTime_in: [DateTime!]
  deadlineTime_not_in: [DateTime!]
  deadlineTime_lt: DateTime
  deadlineTime_lte: DateTime
  deadlineTime_gt: DateTime
  deadlineTime_gte: DateTime
  deadlineTimeEpoch: Int
  deadlineTimeEpoch_not: Int
  deadlineTimeEpoch_in: [Int!]
  deadlineTimeEpoch_not_in: [Int!]
  deadlineTimeEpoch_lt: Int
  deadlineTimeEpoch_lte: Int
  deadlineTimeEpoch_gt: Int
  deadlineTimeEpoch_gte: Int
  deadlineTimeGameOffset: Int
  deadlineTimeGameOffset_not: Int
  deadlineTimeGameOffset_in: [Int!]
  deadlineTimeGameOffset_not_in: [Int!]
  deadlineTimeGameOffset_lt: Int
  deadlineTimeGameOffset_lte: Int
  deadlineTimeGameOffset_gt: Int
  deadlineTimeGameOffset_gte: Int
  finished: Boolean
  finished_not: Boolean
  highestScore: Int
  highestScore_not: Int
  highestScore_in: [Int!]
  highestScore_not_in: [Int!]
  highestScore_lt: Int
  highestScore_lte: Int
  highestScore_gt: Int
  highestScore_gte: Int
  highestScoringEntry: Int
  highestScoringEntry_not: Int
  highestScoringEntry_in: [Int!]
  highestScoringEntry_not_in: [Int!]
  highestScoringEntry_lt: Int
  highestScoringEntry_lte: Int
  highestScoringEntry_gt: Int
  highestScoringEntry_gte: Int
  fplEventId: Int
  fplEventId_not: Int
  fplEventId_in: [Int!]
  fplEventId_not_in: [Int!]
  fplEventId_lt: Int
  fplEventId_lte: Int
  fplEventId_gt: Int
  fplEventId_gte: Int
  isCurrent: Boolean
  isCurrent_not: Boolean
  isNext: Boolean
  isNext_not: Boolean
  isPrevious: Boolean
  isPrevious_not: Boolean
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  fixtures_every: FixtureWhereInput
  fixtures_some: FixtureWhereInput
  fixtures_none: FixtureWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [GameweekWhereInput!]
  OR: [GameweekWhereInput!]
  NOT: [GameweekWhereInput!]
}

input GameweekWhereUniqueInput {
  id: ID
  fplEventId: Int
}

type HomeTeamFixture {
  id: ID!
  fixture: Fixture!
  homeTeam: Team!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type HomeTeamFixtureConnection {
  pageInfo: PageInfo!
  edges: [HomeTeamFixtureEdge]!
  aggregate: AggregateHomeTeamFixture!
}

input HomeTeamFixtureCreateInput {
  id: ID
  fixture: FixtureCreateOneWithoutTeamHInput!
  homeTeam: TeamCreateOneWithoutHomeFixturesInput!
}

input HomeTeamFixtureCreateManyWithoutHomeTeamInput {
  create: [HomeTeamFixtureCreateWithoutHomeTeamInput!]
  connect: [HomeTeamFixtureWhereUniqueInput!]
}

input HomeTeamFixtureCreateOneWithoutFixtureInput {
  create: HomeTeamFixtureCreateWithoutFixtureInput
  connect: HomeTeamFixtureWhereUniqueInput
}

input HomeTeamFixtureCreateWithoutFixtureInput {
  id: ID
  homeTeam: TeamCreateOneWithoutHomeFixturesInput!
}

input HomeTeamFixtureCreateWithoutHomeTeamInput {
  id: ID
  fixture: FixtureCreateOneWithoutTeamHInput!
}

type HomeTeamFixtureEdge {
  node: HomeTeamFixture!
  cursor: String!
}

enum HomeTeamFixtureOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type HomeTeamFixturePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input HomeTeamFixtureScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [HomeTeamFixtureScalarWhereInput!]
  OR: [HomeTeamFixtureScalarWhereInput!]
  NOT: [HomeTeamFixtureScalarWhereInput!]
}

type HomeTeamFixtureSubscriptionPayload {
  mutation: MutationType!
  node: HomeTeamFixture
  updatedFields: [String!]
  previousValues: HomeTeamFixturePreviousValues
}

input HomeTeamFixtureSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HomeTeamFixtureWhereInput
  AND: [HomeTeamFixtureSubscriptionWhereInput!]
  OR: [HomeTeamFixtureSubscriptionWhereInput!]
  NOT: [HomeTeamFixtureSubscriptionWhereInput!]
}

input HomeTeamFixtureUpdateInput {
  fixture: FixtureUpdateOneRequiredWithoutTeamHInput
  homeTeam: TeamUpdateOneRequiredWithoutHomeFixturesInput
}

input HomeTeamFixtureUpdateManyWithoutHomeTeamInput {
  create: [HomeTeamFixtureCreateWithoutHomeTeamInput!]
  delete: [HomeTeamFixtureWhereUniqueInput!]
  connect: [HomeTeamFixtureWhereUniqueInput!]
  set: [HomeTeamFixtureWhereUniqueInput!]
  disconnect: [HomeTeamFixtureWhereUniqueInput!]
  update: [HomeTeamFixtureUpdateWithWhereUniqueWithoutHomeTeamInput!]
  upsert: [HomeTeamFixtureUpsertWithWhereUniqueWithoutHomeTeamInput!]
  deleteMany: [HomeTeamFixtureScalarWhereInput!]
}

input HomeTeamFixtureUpdateOneRequiredWithoutFixtureInput {
  create: HomeTeamFixtureCreateWithoutFixtureInput
  update: HomeTeamFixtureUpdateWithoutFixtureDataInput
  upsert: HomeTeamFixtureUpsertWithoutFixtureInput
  connect: HomeTeamFixtureWhereUniqueInput
}

input HomeTeamFixtureUpdateWithoutFixtureDataInput {
  homeTeam: TeamUpdateOneRequiredWithoutHomeFixturesInput
}

input HomeTeamFixtureUpdateWithoutHomeTeamDataInput {
  fixture: FixtureUpdateOneRequiredWithoutTeamHInput
}

input HomeTeamFixtureUpdateWithWhereUniqueWithoutHomeTeamInput {
  where: HomeTeamFixtureWhereUniqueInput!
  data: HomeTeamFixtureUpdateWithoutHomeTeamDataInput!
}

input HomeTeamFixtureUpsertWithoutFixtureInput {
  update: HomeTeamFixtureUpdateWithoutFixtureDataInput!
  create: HomeTeamFixtureCreateWithoutFixtureInput!
}

input HomeTeamFixtureUpsertWithWhereUniqueWithoutHomeTeamInput {
  where: HomeTeamFixtureWhereUniqueInput!
  update: HomeTeamFixtureUpdateWithoutHomeTeamDataInput!
  create: HomeTeamFixtureCreateWithoutHomeTeamInput!
}

input HomeTeamFixtureWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fixture: FixtureWhereInput
  homeTeam: TeamWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [HomeTeamFixtureWhereInput!]
  OR: [HomeTeamFixtureWhereInput!]
  NOT: [HomeTeamFixtureWhereInput!]
}

input HomeTeamFixtureWhereUniqueInput {
  id: ID
}

type Influencer {
  id: ID!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InfluencerConnection {
  pageInfo: PageInfo!
  edges: [InfluencerEdge]!
  aggregate: AggregateInfluencer!
}

input InfluencerCreateInput {
  id: ID
  user: UserCreateOneInput!
}

input InfluencerCreateManyInput {
  create: [InfluencerCreateInput!]
  connect: [InfluencerWhereUniqueInput!]
}

type InfluencerEdge {
  node: Influencer!
  cursor: String!
}

enum InfluencerOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type InfluencerPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input InfluencerScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InfluencerScalarWhereInput!]
  OR: [InfluencerScalarWhereInput!]
  NOT: [InfluencerScalarWhereInput!]
}

type InfluencerSubscriptionPayload {
  mutation: MutationType!
  node: Influencer
  updatedFields: [String!]
  previousValues: InfluencerPreviousValues
}

input InfluencerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InfluencerWhereInput
  AND: [InfluencerSubscriptionWhereInput!]
  OR: [InfluencerSubscriptionWhereInput!]
  NOT: [InfluencerSubscriptionWhereInput!]
}

input InfluencerUpdateDataInput {
  user: UserUpdateOneRequiredInput
}

input InfluencerUpdateInput {
  user: UserUpdateOneRequiredInput
}

input InfluencerUpdateManyInput {
  create: [InfluencerCreateInput!]
  update: [InfluencerUpdateWithWhereUniqueNestedInput!]
  upsert: [InfluencerUpsertWithWhereUniqueNestedInput!]
  delete: [InfluencerWhereUniqueInput!]
  connect: [InfluencerWhereUniqueInput!]
  set: [InfluencerWhereUniqueInput!]
  disconnect: [InfluencerWhereUniqueInput!]
  deleteMany: [InfluencerScalarWhereInput!]
}

input InfluencerUpdateWithWhereUniqueNestedInput {
  where: InfluencerWhereUniqueInput!
  data: InfluencerUpdateDataInput!
}

input InfluencerUpsertWithWhereUniqueNestedInput {
  where: InfluencerWhereUniqueInput!
  update: InfluencerUpdateDataInput!
  create: InfluencerCreateInput!
}

input InfluencerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [InfluencerWhereInput!]
  OR: [InfluencerWhereInput!]
  NOT: [InfluencerWhereInput!]
}

input InfluencerWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createActiveSubscriptions(data: ActiveSubscriptionsCreateInput!): ActiveSubscriptions!
  updateActiveSubscriptions(data: ActiveSubscriptionsUpdateInput!, where: ActiveSubscriptionsWhereUniqueInput!): ActiveSubscriptions
  updateManyActiveSubscriptionses(data: ActiveSubscriptionsUpdateManyMutationInput!, where: ActiveSubscriptionsWhereInput): BatchPayload!
  upsertActiveSubscriptions(where: ActiveSubscriptionsWhereUniqueInput!, create: ActiveSubscriptionsCreateInput!, update: ActiveSubscriptionsUpdateInput!): ActiveSubscriptions!
  deleteActiveSubscriptions(where: ActiveSubscriptionsWhereUniqueInput!): ActiveSubscriptions
  deleteManyActiveSubscriptionses(where: ActiveSubscriptionsWhereInput): BatchPayload!
  createAwayTeamFixture(data: AwayTeamFixtureCreateInput!): AwayTeamFixture!
  updateAwayTeamFixture(data: AwayTeamFixtureUpdateInput!, where: AwayTeamFixtureWhereUniqueInput!): AwayTeamFixture
  upsertAwayTeamFixture(where: AwayTeamFixtureWhereUniqueInput!, create: AwayTeamFixtureCreateInput!, update: AwayTeamFixtureUpdateInput!): AwayTeamFixture!
  deleteAwayTeamFixture(where: AwayTeamFixtureWhereUniqueInput!): AwayTeamFixture
  deleteManyAwayTeamFixtures(where: AwayTeamFixtureWhereInput): BatchPayload!
  createContest(data: ContestCreateInput!): Contest!
  updateContest(data: ContestUpdateInput!, where: ContestWhereUniqueInput!): Contest
  updateManyContests(data: ContestUpdateManyMutationInput!, where: ContestWhereInput): BatchPayload!
  upsertContest(where: ContestWhereUniqueInput!, create: ContestCreateInput!, update: ContestUpdateInput!): Contest!
  deleteContest(where: ContestWhereUniqueInput!): Contest
  deleteManyContests(where: ContestWhereInput): BatchPayload!
  createContestCreator(data: ContestCreatorCreateInput!): ContestCreator!
  updateContestCreator(data: ContestCreatorUpdateInput!, where: ContestCreatorWhereUniqueInput!): ContestCreator
  upsertContestCreator(where: ContestCreatorWhereUniqueInput!, create: ContestCreatorCreateInput!, update: ContestCreatorUpdateInput!): ContestCreator!
  deleteContestCreator(where: ContestCreatorWhereUniqueInput!): ContestCreator
  deleteManyContestCreators(where: ContestCreatorWhereInput): BatchPayload!
  createContestInviter(data: ContestInviterCreateInput!): ContestInviter!
  updateContestInviter(data: ContestInviterUpdateInput!, where: ContestInviterWhereUniqueInput!): ContestInviter
  upsertContestInviter(where: ContestInviterWhereUniqueInput!, create: ContestInviterCreateInput!, update: ContestInviterUpdateInput!): ContestInviter!
  deleteContestInviter(where: ContestInviterWhereUniqueInput!): ContestInviter
  deleteManyContestInviters(where: ContestInviterWhereInput): BatchPayload!
  createContestOwner(data: ContestOwnerCreateInput!): ContestOwner!
  updateContestOwner(data: ContestOwnerUpdateInput!, where: ContestOwnerWhereUniqueInput!): ContestOwner
  upsertContestOwner(where: ContestOwnerWhereUniqueInput!, create: ContestOwnerCreateInput!, update: ContestOwnerUpdateInput!): ContestOwner!
  deleteContestOwner(where: ContestOwnerWhereUniqueInput!): ContestOwner
  deleteManyContestOwners(where: ContestOwnerWhereInput): BatchPayload!
  createContestPrediction(data: ContestPredictionCreateInput!): ContestPrediction!
  updateContestPrediction(data: ContestPredictionUpdateInput!, where: ContestPredictionWhereUniqueInput!): ContestPrediction
  updateManyContestPredictions(data: ContestPredictionUpdateManyMutationInput!, where: ContestPredictionWhereInput): BatchPayload!
  upsertContestPrediction(where: ContestPredictionWhereUniqueInput!, create: ContestPredictionCreateInput!, update: ContestPredictionUpdateInput!): ContestPrediction!
  deleteContestPrediction(where: ContestPredictionWhereUniqueInput!): ContestPrediction
  deleteManyContestPredictions(where: ContestPredictionWhereInput): BatchPayload!
  createContestPredictionScore(data: ContestPredictionScoreCreateInput!): ContestPredictionScore!
  updateContestPredictionScore(data: ContestPredictionScoreUpdateInput!, where: ContestPredictionScoreWhereUniqueInput!): ContestPredictionScore
  updateManyContestPredictionScores(data: ContestPredictionScoreUpdateManyMutationInput!, where: ContestPredictionScoreWhereInput): BatchPayload!
  upsertContestPredictionScore(where: ContestPredictionScoreWhereUniqueInput!, create: ContestPredictionScoreCreateInput!, update: ContestPredictionScoreUpdateInput!): ContestPredictionScore!
  deleteContestPredictionScore(where: ContestPredictionScoreWhereUniqueInput!): ContestPredictionScore
  deleteManyContestPredictionScores(where: ContestPredictionScoreWhereInput): BatchPayload!
  createContestSlate(data: ContestSlateCreateInput!): ContestSlate!
  updateContestSlate(data: ContestSlateUpdateInput!, where: ContestSlateWhereUniqueInput!): ContestSlate
  updateManyContestSlates(data: ContestSlateUpdateManyMutationInput!, where: ContestSlateWhereInput): BatchPayload!
  upsertContestSlate(where: ContestSlateWhereUniqueInput!, create: ContestSlateCreateInput!, update: ContestSlateUpdateInput!): ContestSlate!
  deleteContestSlate(where: ContestSlateWhereUniqueInput!): ContestSlate
  deleteManyContestSlates(where: ContestSlateWhereInput): BatchPayload!
  createContestSlateEntry(data: ContestSlateEntryCreateInput!): ContestSlateEntry!
  updateContestSlateEntry(data: ContestSlateEntryUpdateInput!, where: ContestSlateEntryWhereUniqueInput!): ContestSlateEntry
  upsertContestSlateEntry(where: ContestSlateEntryWhereUniqueInput!, create: ContestSlateEntryCreateInput!, update: ContestSlateEntryUpdateInput!): ContestSlateEntry!
  deleteContestSlateEntry(where: ContestSlateEntryWhereUniqueInput!): ContestSlateEntry
  deleteManyContestSlateEntries(where: ContestSlateEntryWhereInput): BatchPayload!
  createContestType(data: ContestTypeCreateInput!): ContestType!
  updateContestType(data: ContestTypeUpdateInput!, where: ContestTypeWhereUniqueInput!): ContestType
  updateManyContestTypes(data: ContestTypeUpdateManyMutationInput!, where: ContestTypeWhereInput): BatchPayload!
  upsertContestType(where: ContestTypeWhereUniqueInput!, create: ContestTypeCreateInput!, update: ContestTypeUpdateInput!): ContestType!
  deleteContestType(where: ContestTypeWhereUniqueInput!): ContestType
  deleteManyContestTypes(where: ContestTypeWhereInput): BatchPayload!
  createContestUser(data: ContestUserCreateInput!): ContestUser!
  updateContestUser(data: ContestUserUpdateInput!, where: ContestUserWhereUniqueInput!): ContestUser
  updateManyContestUsers(data: ContestUserUpdateManyMutationInput!, where: ContestUserWhereInput): BatchPayload!
  upsertContestUser(where: ContestUserWhereUniqueInput!, create: ContestUserCreateInput!, update: ContestUserUpdateInput!): ContestUser!
  deleteContestUser(where: ContestUserWhereUniqueInput!): ContestUser
  deleteManyContestUsers(where: ContestUserWhereInput): BatchPayload!
  createContestUserType(data: ContestUserTypeCreateInput!): ContestUserType!
  updateContestUserType(data: ContestUserTypeUpdateInput!, where: ContestUserTypeWhereUniqueInput!): ContestUserType
  updateManyContestUserTypes(data: ContestUserTypeUpdateManyMutationInput!, where: ContestUserTypeWhereInput): BatchPayload!
  upsertContestUserType(where: ContestUserTypeWhereUniqueInput!, create: ContestUserTypeCreateInput!, update: ContestUserTypeUpdateInput!): ContestUserType!
  deleteContestUserType(where: ContestUserTypeWhereUniqueInput!): ContestUserType
  deleteManyContestUserTypes(where: ContestUserTypeWhereInput): BatchPayload!
  createCountry(data: CountryCreateInput!): Country!
  updateCountry(data: CountryUpdateInput!, where: CountryWhereUniqueInput!): Country
  updateManyCountries(data: CountryUpdateManyMutationInput!, where: CountryWhereInput): BatchPayload!
  upsertCountry(where: CountryWhereUniqueInput!, create: CountryCreateInput!, update: CountryUpdateInput!): Country!
  deleteCountry(where: CountryWhereUniqueInput!): Country
  deleteManyCountries(where: CountryWhereInput): BatchPayload!
  createDefaultScoringSystemDetail(data: DefaultScoringSystemDetailCreateInput!): DefaultScoringSystemDetail!
  updateDefaultScoringSystemDetail(data: DefaultScoringSystemDetailUpdateInput!, where: DefaultScoringSystemDetailWhereUniqueInput!): DefaultScoringSystemDetail
  updateManyDefaultScoringSystemDetails(data: DefaultScoringSystemDetailUpdateManyMutationInput!, where: DefaultScoringSystemDetailWhereInput): BatchPayload!
  upsertDefaultScoringSystemDetail(where: DefaultScoringSystemDetailWhereUniqueInput!, create: DefaultScoringSystemDetailCreateInput!, update: DefaultScoringSystemDetailUpdateInput!): DefaultScoringSystemDetail!
  deleteDefaultScoringSystemDetail(where: DefaultScoringSystemDetailWhereUniqueInput!): DefaultScoringSystemDetail
  deleteManyDefaultScoringSystemDetails(where: DefaultScoringSystemDetailWhereInput): BatchPayload!
  createDefaultScoringSystemHeader(data: DefaultScoringSystemHeaderCreateInput!): DefaultScoringSystemHeader!
  updateDefaultScoringSystemHeader(data: DefaultScoringSystemHeaderUpdateInput!, where: DefaultScoringSystemHeaderWhereUniqueInput!): DefaultScoringSystemHeader
  updateManyDefaultScoringSystemHeaders(data: DefaultScoringSystemHeaderUpdateManyMutationInput!, where: DefaultScoringSystemHeaderWhereInput): BatchPayload!
  upsertDefaultScoringSystemHeader(where: DefaultScoringSystemHeaderWhereUniqueInput!, create: DefaultScoringSystemHeaderCreateInput!, update: DefaultScoringSystemHeaderUpdateInput!): DefaultScoringSystemHeader!
  deleteDefaultScoringSystemHeader(where: DefaultScoringSystemHeaderWhereUniqueInput!): DefaultScoringSystemHeader
  deleteManyDefaultScoringSystemHeaders(where: DefaultScoringSystemHeaderWhereInput): BatchPayload!
  createFandemSubscription(data: FandemSubscriptionCreateInput!): FandemSubscription!
  updateFandemSubscription(data: FandemSubscriptionUpdateInput!, where: FandemSubscriptionWhereUniqueInput!): FandemSubscription
  updateManyFandemSubscriptions(data: FandemSubscriptionUpdateManyMutationInput!, where: FandemSubscriptionWhereInput): BatchPayload!
  upsertFandemSubscription(where: FandemSubscriptionWhereUniqueInput!, create: FandemSubscriptionCreateInput!, update: FandemSubscriptionUpdateInput!): FandemSubscription!
  deleteFandemSubscription(where: FandemSubscriptionWhereUniqueInput!): FandemSubscription
  deleteManyFandemSubscriptions(where: FandemSubscriptionWhereInput): BatchPayload!
  createFixture(data: FixtureCreateInput!): Fixture!
  updateFixture(data: FixtureUpdateInput!, where: FixtureWhereUniqueInput!): Fixture
  updateManyFixtures(data: FixtureUpdateManyMutationInput!, where: FixtureWhereInput): BatchPayload!
  upsertFixture(where: FixtureWhereUniqueInput!, create: FixtureCreateInput!, update: FixtureUpdateInput!): Fixture!
  deleteFixture(where: FixtureWhereUniqueInput!): Fixture
  deleteManyFixtures(where: FixtureWhereInput): BatchPayload!
  createFollower(data: FollowerCreateInput!): Follower!
  updateFollower(data: FollowerUpdateInput!, where: FollowerWhereUniqueInput!): Follower
  updateManyFollowers(data: FollowerUpdateManyMutationInput!, where: FollowerWhereInput): BatchPayload!
  upsertFollower(where: FollowerWhereUniqueInput!, create: FollowerCreateInput!, update: FollowerUpdateInput!): Follower!
  deleteFollower(where: FollowerWhereUniqueInput!): Follower
  deleteManyFollowers(where: FollowerWhereInput): BatchPayload!
  createGameweek(data: GameweekCreateInput!): Gameweek!
  updateGameweek(data: GameweekUpdateInput!, where: GameweekWhereUniqueInput!): Gameweek
  updateManyGameweeks(data: GameweekUpdateManyMutationInput!, where: GameweekWhereInput): BatchPayload!
  upsertGameweek(where: GameweekWhereUniqueInput!, create: GameweekCreateInput!, update: GameweekUpdateInput!): Gameweek!
  deleteGameweek(where: GameweekWhereUniqueInput!): Gameweek
  deleteManyGameweeks(where: GameweekWhereInput): BatchPayload!
  createHomeTeamFixture(data: HomeTeamFixtureCreateInput!): HomeTeamFixture!
  updateHomeTeamFixture(data: HomeTeamFixtureUpdateInput!, where: HomeTeamFixtureWhereUniqueInput!): HomeTeamFixture
  upsertHomeTeamFixture(where: HomeTeamFixtureWhereUniqueInput!, create: HomeTeamFixtureCreateInput!, update: HomeTeamFixtureUpdateInput!): HomeTeamFixture!
  deleteHomeTeamFixture(where: HomeTeamFixtureWhereUniqueInput!): HomeTeamFixture
  deleteManyHomeTeamFixtures(where: HomeTeamFixtureWhereInput): BatchPayload!
  createInfluencer(data: InfluencerCreateInput!): Influencer!
  updateInfluencer(data: InfluencerUpdateInput!, where: InfluencerWhereUniqueInput!): Influencer
  upsertInfluencer(where: InfluencerWhereUniqueInput!, create: InfluencerCreateInput!, update: InfluencerUpdateInput!): Influencer!
  deleteInfluencer(where: InfluencerWhereUniqueInput!): Influencer
  deleteManyInfluencers(where: InfluencerWhereInput): BatchPayload!
  createPhoto(data: PhotoCreateInput!): Photo!
  updatePhoto(data: PhotoUpdateInput!, where: PhotoWhereUniqueInput!): Photo
  updateManyPhotos(data: PhotoUpdateManyMutationInput!, where: PhotoWhereInput): BatchPayload!
  upsertPhoto(where: PhotoWhereUniqueInput!, create: PhotoCreateInput!, update: PhotoUpdateInput!): Photo!
  deletePhoto(where: PhotoWhereUniqueInput!): Photo
  deleteManyPhotos(where: PhotoWhereInput): BatchPayload!
  createScoringSystemDetail(data: ScoringSystemDetailCreateInput!): ScoringSystemDetail!
  updateScoringSystemDetail(data: ScoringSystemDetailUpdateInput!, where: ScoringSystemDetailWhereUniqueInput!): ScoringSystemDetail
  updateManyScoringSystemDetails(data: ScoringSystemDetailUpdateManyMutationInput!, where: ScoringSystemDetailWhereInput): BatchPayload!
  upsertScoringSystemDetail(where: ScoringSystemDetailWhereUniqueInput!, create: ScoringSystemDetailCreateInput!, update: ScoringSystemDetailUpdateInput!): ScoringSystemDetail!
  deleteScoringSystemDetail(where: ScoringSystemDetailWhereUniqueInput!): ScoringSystemDetail
  deleteManyScoringSystemDetails(where: ScoringSystemDetailWhereInput): BatchPayload!
  createScoringSystemHeader(data: ScoringSystemHeaderCreateInput!): ScoringSystemHeader!
  updateScoringSystemHeader(data: ScoringSystemHeaderUpdateInput!, where: ScoringSystemHeaderWhereUniqueInput!): ScoringSystemHeader
  updateManyScoringSystemHeaders(data: ScoringSystemHeaderUpdateManyMutationInput!, where: ScoringSystemHeaderWhereInput): BatchPayload!
  upsertScoringSystemHeader(where: ScoringSystemHeaderWhereUniqueInput!, create: ScoringSystemHeaderCreateInput!, update: ScoringSystemHeaderUpdateInput!): ScoringSystemHeader!
  deleteScoringSystemHeader(where: ScoringSystemHeaderWhereUniqueInput!): ScoringSystemHeader
  deleteManyScoringSystemHeaders(where: ScoringSystemHeaderWhereInput): BatchPayload!
  createScoringType(data: ScoringTypeCreateInput!): ScoringType!
  updateScoringType(data: ScoringTypeUpdateInput!, where: ScoringTypeWhereUniqueInput!): ScoringType
  updateManyScoringTypes(data: ScoringTypeUpdateManyMutationInput!, where: ScoringTypeWhereInput): BatchPayload!
  upsertScoringType(where: ScoringTypeWhereUniqueInput!, create: ScoringTypeCreateInput!, update: ScoringTypeUpdateInput!): ScoringType!
  deleteScoringType(where: ScoringTypeWhereUniqueInput!): ScoringType
  deleteManyScoringTypes(where: ScoringTypeWhereInput): BatchPayload!
  createSeason(data: SeasonCreateInput!): Season!
  updateSeason(data: SeasonUpdateInput!, where: SeasonWhereUniqueInput!): Season
  updateManySeasons(data: SeasonUpdateManyMutationInput!, where: SeasonWhereInput): BatchPayload!
  upsertSeason(where: SeasonWhereUniqueInput!, create: SeasonCreateInput!, update: SeasonUpdateInput!): Season!
  deleteSeason(where: SeasonWhereUniqueInput!): Season
  deleteManySeasons(where: SeasonWhereInput): BatchPayload!
  createStatus(data: StatusCreateInput!): Status!
  updateStatus(data: StatusUpdateInput!, where: StatusWhereUniqueInput!): Status
  updateManyStatuses(data: StatusUpdateManyMutationInput!, where: StatusWhereInput): BatchPayload!
  upsertStatus(where: StatusWhereUniqueInput!, create: StatusCreateInput!, update: StatusUpdateInput!): Status!
  deleteStatus(where: StatusWhereUniqueInput!): Status
  deleteManyStatuses(where: StatusWhereInput): BatchPayload!
  createTeam(data: TeamCreateInput!): Team!
  updateTeam(data: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team
  updateManyTeams(data: TeamUpdateManyMutationInput!, where: TeamWhereInput): BatchPayload!
  upsertTeam(where: TeamWhereUniqueInput!, create: TeamCreateInput!, update: TeamUpdateInput!): Team!
  deleteTeam(where: TeamWhereUniqueInput!): Team
  deleteManyTeams(where: TeamWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createUserAssignedRole(data: UserAssignedRoleCreateInput!): UserAssignedRole!
  updateUserAssignedRole(data: UserAssignedRoleUpdateInput!, where: UserAssignedRoleWhereUniqueInput!): UserAssignedRole
  upsertUserAssignedRole(where: UserAssignedRoleWhereUniqueInput!, create: UserAssignedRoleCreateInput!, update: UserAssignedRoleUpdateInput!): UserAssignedRole!
  deleteUserAssignedRole(where: UserAssignedRoleWhereUniqueInput!): UserAssignedRole
  deleteManyUserAssignedRoles(where: UserAssignedRoleWhereInput): BatchPayload!
  createUserFollowers(data: UserFollowersCreateInput!): UserFollowers!
  updateUserFollowers(data: UserFollowersUpdateInput!, where: UserFollowersWhereUniqueInput!): UserFollowers
  upsertUserFollowers(where: UserFollowersWhereUniqueInput!, create: UserFollowersCreateInput!, update: UserFollowersUpdateInput!): UserFollowers!
  deleteUserFollowers(where: UserFollowersWhereUniqueInput!): UserFollowers
  deleteManyUserFollowerses(where: UserFollowersWhereInput): BatchPayload!
  createUserInfluencers(data: UserInfluencersCreateInput!): UserInfluencers!
  updateUserInfluencers(data: UserInfluencersUpdateInput!, where: UserInfluencersWhereUniqueInput!): UserInfluencers
  upsertUserInfluencers(where: UserInfluencersWhereUniqueInput!, create: UserInfluencersCreateInput!, update: UserInfluencersUpdateInput!): UserInfluencers!
  deleteUserInfluencers(where: UserInfluencersWhereUniqueInput!): UserInfluencers
  deleteManyUserInfluencerses(where: UserInfluencersWhereInput): BatchPayload!
  createUserPhoto(data: UserPhotoCreateInput!): UserPhoto!
  updateUserPhoto(data: UserPhotoUpdateInput!, where: UserPhotoWhereUniqueInput!): UserPhoto
  updateManyUserPhotos(data: UserPhotoUpdateManyMutationInput!, where: UserPhotoWhereInput): BatchPayload!
  upsertUserPhoto(where: UserPhotoWhereUniqueInput!, create: UserPhotoCreateInput!, update: UserPhotoUpdateInput!): UserPhoto!
  deleteUserPhoto(where: UserPhotoWhereUniqueInput!): UserPhoto
  deleteManyUserPhotos(where: UserPhotoWhereInput): BatchPayload!
  createUserRole(data: UserRoleCreateInput!): UserRole!
  updateUserRole(data: UserRoleUpdateInput!, where: UserRoleWhereUniqueInput!): UserRole
  updateManyUserRoles(data: UserRoleUpdateManyMutationInput!, where: UserRoleWhereInput): BatchPayload!
  upsertUserRole(where: UserRoleWhereUniqueInput!, create: UserRoleCreateInput!, update: UserRoleUpdateInput!): UserRole!
  deleteUserRole(where: UserRoleWhereUniqueInput!): UserRole
  deleteManyUserRoles(where: UserRoleWhereInput): BatchPayload!
  createUserStatus(data: UserStatusCreateInput!): UserStatus!
  updateUserStatus(data: UserStatusUpdateInput!, where: UserStatusWhereUniqueInput!): UserStatus
  updateManyUserStatuses(data: UserStatusUpdateManyMutationInput!, where: UserStatusWhereInput): BatchPayload!
  upsertUserStatus(where: UserStatusWhereUniqueInput!, create: UserStatusCreateInput!, update: UserStatusUpdateInput!): UserStatus!
  deleteUserStatus(where: UserStatusWhereUniqueInput!): UserStatus
  deleteManyUserStatuses(where: UserStatusWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Photo {
  id: ID!
  image: String!
  largeImage: String
  smallImage: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PhotoConnection {
  pageInfo: PageInfo!
  edges: [PhotoEdge]!
  aggregate: AggregatePhoto!
}

input PhotoCreateInput {
  id: ID
  image: String!
  largeImage: String
  smallImage: String
}

input PhotoCreateOneInput {
  create: PhotoCreateInput
  connect: PhotoWhereUniqueInput
}

type PhotoEdge {
  node: Photo!
  cursor: String!
}

enum PhotoOrderByInput {
  id_ASC
  id_DESC
  image_ASC
  image_DESC
  largeImage_ASC
  largeImage_DESC
  smallImage_ASC
  smallImage_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PhotoPreviousValues {
  id: ID!
  image: String!
  largeImage: String
  smallImage: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PhotoSubscriptionPayload {
  mutation: MutationType!
  node: Photo
  updatedFields: [String!]
  previousValues: PhotoPreviousValues
}

input PhotoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PhotoWhereInput
  AND: [PhotoSubscriptionWhereInput!]
  OR: [PhotoSubscriptionWhereInput!]
  NOT: [PhotoSubscriptionWhereInput!]
}

input PhotoUpdateDataInput {
  image: String
  largeImage: String
  smallImage: String
}

input PhotoUpdateInput {
  image: String
  largeImage: String
  smallImage: String
}

input PhotoUpdateManyMutationInput {
  image: String
  largeImage: String
  smallImage: String
}

input PhotoUpdateOneRequiredInput {
  create: PhotoCreateInput
  update: PhotoUpdateDataInput
  upsert: PhotoUpsertNestedInput
  connect: PhotoWhereUniqueInput
}

input PhotoUpsertNestedInput {
  update: PhotoUpdateDataInput!
  create: PhotoCreateInput!
}

input PhotoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  largeImage: String
  largeImage_not: String
  largeImage_in: [String!]
  largeImage_not_in: [String!]
  largeImage_lt: String
  largeImage_lte: String
  largeImage_gt: String
  largeImage_gte: String
  largeImage_contains: String
  largeImage_not_contains: String
  largeImage_starts_with: String
  largeImage_not_starts_with: String
  largeImage_ends_with: String
  largeImage_not_ends_with: String
  smallImage: String
  smallImage_not: String
  smallImage_in: [String!]
  smallImage_not_in: [String!]
  smallImage_lt: String
  smallImage_lte: String
  smallImage_gt: String
  smallImage_gte: String
  smallImage_contains: String
  smallImage_not_contains: String
  smallImage_starts_with: String
  smallImage_not_starts_with: String
  smallImage_ends_with: String
  smallImage_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PhotoWhereInput!]
  OR: [PhotoWhereInput!]
  NOT: [PhotoWhereInput!]
}

input PhotoWhereUniqueInput {
  id: ID
}

type Query {
  activeSubscriptions(where: ActiveSubscriptionsWhereUniqueInput!): ActiveSubscriptions
  activeSubscriptionses(where: ActiveSubscriptionsWhereInput, orderBy: ActiveSubscriptionsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ActiveSubscriptions]!
  activeSubscriptionsesConnection(where: ActiveSubscriptionsWhereInput, orderBy: ActiveSubscriptionsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ActiveSubscriptionsConnection!
  awayTeamFixture(where: AwayTeamFixtureWhereUniqueInput!): AwayTeamFixture
  awayTeamFixtures(where: AwayTeamFixtureWhereInput, orderBy: AwayTeamFixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AwayTeamFixture]!
  awayTeamFixturesConnection(where: AwayTeamFixtureWhereInput, orderBy: AwayTeamFixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AwayTeamFixtureConnection!
  contest(where: ContestWhereUniqueInput!): Contest
  contests(where: ContestWhereInput, orderBy: ContestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Contest]!
  contestsConnection(where: ContestWhereInput, orderBy: ContestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContestConnection!
  contestCreator(where: ContestCreatorWhereUniqueInput!): ContestCreator
  contestCreators(where: ContestCreatorWhereInput, orderBy: ContestCreatorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContestCreator]!
  contestCreatorsConnection(where: ContestCreatorWhereInput, orderBy: ContestCreatorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContestCreatorConnection!
  contestInviter(where: ContestInviterWhereUniqueInput!): ContestInviter
  contestInviters(where: ContestInviterWhereInput, orderBy: ContestInviterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContestInviter]!
  contestInvitersConnection(where: ContestInviterWhereInput, orderBy: ContestInviterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContestInviterConnection!
  contestOwner(where: ContestOwnerWhereUniqueInput!): ContestOwner
  contestOwners(where: ContestOwnerWhereInput, orderBy: ContestOwnerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContestOwner]!
  contestOwnersConnection(where: ContestOwnerWhereInput, orderBy: ContestOwnerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContestOwnerConnection!
  contestPrediction(where: ContestPredictionWhereUniqueInput!): ContestPrediction
  contestPredictions(where: ContestPredictionWhereInput, orderBy: ContestPredictionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContestPrediction]!
  contestPredictionsConnection(where: ContestPredictionWhereInput, orderBy: ContestPredictionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContestPredictionConnection!
  contestPredictionScore(where: ContestPredictionScoreWhereUniqueInput!): ContestPredictionScore
  contestPredictionScores(where: ContestPredictionScoreWhereInput, orderBy: ContestPredictionScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContestPredictionScore]!
  contestPredictionScoresConnection(where: ContestPredictionScoreWhereInput, orderBy: ContestPredictionScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContestPredictionScoreConnection!
  contestSlate(where: ContestSlateWhereUniqueInput!): ContestSlate
  contestSlates(where: ContestSlateWhereInput, orderBy: ContestSlateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContestSlate]!
  contestSlatesConnection(where: ContestSlateWhereInput, orderBy: ContestSlateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContestSlateConnection!
  contestSlateEntry(where: ContestSlateEntryWhereUniqueInput!): ContestSlateEntry
  contestSlateEntries(where: ContestSlateEntryWhereInput, orderBy: ContestSlateEntryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContestSlateEntry]!
  contestSlateEntriesConnection(where: ContestSlateEntryWhereInput, orderBy: ContestSlateEntryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContestSlateEntryConnection!
  contestType(where: ContestTypeWhereUniqueInput!): ContestType
  contestTypes(where: ContestTypeWhereInput, orderBy: ContestTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContestType]!
  contestTypesConnection(where: ContestTypeWhereInput, orderBy: ContestTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContestTypeConnection!
  contestUser(where: ContestUserWhereUniqueInput!): ContestUser
  contestUsers(where: ContestUserWhereInput, orderBy: ContestUserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContestUser]!
  contestUsersConnection(where: ContestUserWhereInput, orderBy: ContestUserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContestUserConnection!
  contestUserType(where: ContestUserTypeWhereUniqueInput!): ContestUserType
  contestUserTypes(where: ContestUserTypeWhereInput, orderBy: ContestUserTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContestUserType]!
  contestUserTypesConnection(where: ContestUserTypeWhereInput, orderBy: ContestUserTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContestUserTypeConnection!
  country(where: CountryWhereUniqueInput!): Country
  countries(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Country]!
  countriesConnection(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CountryConnection!
  defaultScoringSystemDetail(where: DefaultScoringSystemDetailWhereUniqueInput!): DefaultScoringSystemDetail
  defaultScoringSystemDetails(where: DefaultScoringSystemDetailWhereInput, orderBy: DefaultScoringSystemDetailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DefaultScoringSystemDetail]!
  defaultScoringSystemDetailsConnection(where: DefaultScoringSystemDetailWhereInput, orderBy: DefaultScoringSystemDetailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DefaultScoringSystemDetailConnection!
  defaultScoringSystemHeader(where: DefaultScoringSystemHeaderWhereUniqueInput!): DefaultScoringSystemHeader
  defaultScoringSystemHeaders(where: DefaultScoringSystemHeaderWhereInput, orderBy: DefaultScoringSystemHeaderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [DefaultScoringSystemHeader]!
  defaultScoringSystemHeadersConnection(where: DefaultScoringSystemHeaderWhereInput, orderBy: DefaultScoringSystemHeaderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DefaultScoringSystemHeaderConnection!
  fandemSubscription(where: FandemSubscriptionWhereUniqueInput!): FandemSubscription
  fandemSubscriptions(where: FandemSubscriptionWhereInput, orderBy: FandemSubscriptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FandemSubscription]!
  fandemSubscriptionsConnection(where: FandemSubscriptionWhereInput, orderBy: FandemSubscriptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FandemSubscriptionConnection!
  fixture(where: FixtureWhereUniqueInput!): Fixture
  fixtures(where: FixtureWhereInput, orderBy: FixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Fixture]!
  fixturesConnection(where: FixtureWhereInput, orderBy: FixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FixtureConnection!
  follower(where: FollowerWhereUniqueInput!): Follower
  followers(where: FollowerWhereInput, orderBy: FollowerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Follower]!
  followersConnection(where: FollowerWhereInput, orderBy: FollowerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FollowerConnection!
  gameweek(where: GameweekWhereUniqueInput!): Gameweek
  gameweeks(where: GameweekWhereInput, orderBy: GameweekOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Gameweek]!
  gameweeksConnection(where: GameweekWhereInput, orderBy: GameweekOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GameweekConnection!
  homeTeamFixture(where: HomeTeamFixtureWhereUniqueInput!): HomeTeamFixture
  homeTeamFixtures(where: HomeTeamFixtureWhereInput, orderBy: HomeTeamFixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [HomeTeamFixture]!
  homeTeamFixturesConnection(where: HomeTeamFixtureWhereInput, orderBy: HomeTeamFixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HomeTeamFixtureConnection!
  influencer(where: InfluencerWhereUniqueInput!): Influencer
  influencers(where: InfluencerWhereInput, orderBy: InfluencerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Influencer]!
  influencersConnection(where: InfluencerWhereInput, orderBy: InfluencerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InfluencerConnection!
  photo(where: PhotoWhereUniqueInput!): Photo
  photos(where: PhotoWhereInput, orderBy: PhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Photo]!
  photosConnection(where: PhotoWhereInput, orderBy: PhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PhotoConnection!
  scoringSystemDetail(where: ScoringSystemDetailWhereUniqueInput!): ScoringSystemDetail
  scoringSystemDetails(where: ScoringSystemDetailWhereInput, orderBy: ScoringSystemDetailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ScoringSystemDetail]!
  scoringSystemDetailsConnection(where: ScoringSystemDetailWhereInput, orderBy: ScoringSystemDetailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ScoringSystemDetailConnection!
  scoringSystemHeader(where: ScoringSystemHeaderWhereUniqueInput!): ScoringSystemHeader
  scoringSystemHeaders(where: ScoringSystemHeaderWhereInput, orderBy: ScoringSystemHeaderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ScoringSystemHeader]!
  scoringSystemHeadersConnection(where: ScoringSystemHeaderWhereInput, orderBy: ScoringSystemHeaderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ScoringSystemHeaderConnection!
  scoringType(where: ScoringTypeWhereUniqueInput!): ScoringType
  scoringTypes(where: ScoringTypeWhereInput, orderBy: ScoringTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ScoringType]!
  scoringTypesConnection(where: ScoringTypeWhereInput, orderBy: ScoringTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ScoringTypeConnection!
  season(where: SeasonWhereUniqueInput!): Season
  seasons(where: SeasonWhereInput, orderBy: SeasonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Season]!
  seasonsConnection(where: SeasonWhereInput, orderBy: SeasonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SeasonConnection!
  status(where: StatusWhereUniqueInput!): Status
  statuses(where: StatusWhereInput, orderBy: StatusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Status]!
  statusesConnection(where: StatusWhereInput, orderBy: StatusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StatusConnection!
  team(where: TeamWhereUniqueInput!): Team
  teams(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team]!
  teamsConnection(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  userAssignedRole(where: UserAssignedRoleWhereUniqueInput!): UserAssignedRole
  userAssignedRoles(where: UserAssignedRoleWhereInput, orderBy: UserAssignedRoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserAssignedRole]!
  userAssignedRolesConnection(where: UserAssignedRoleWhereInput, orderBy: UserAssignedRoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserAssignedRoleConnection!
  userFollowers(where: UserFollowersWhereUniqueInput!): UserFollowers
  userFollowerses(where: UserFollowersWhereInput, orderBy: UserFollowersOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserFollowers]!
  userFollowersesConnection(where: UserFollowersWhereInput, orderBy: UserFollowersOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserFollowersConnection!
  userInfluencers(where: UserInfluencersWhereUniqueInput!): UserInfluencers
  userInfluencerses(where: UserInfluencersWhereInput, orderBy: UserInfluencersOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserInfluencers]!
  userInfluencersesConnection(where: UserInfluencersWhereInput, orderBy: UserInfluencersOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserInfluencersConnection!
  userPhoto(where: UserPhotoWhereUniqueInput!): UserPhoto
  userPhotos(where: UserPhotoWhereInput, orderBy: UserPhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserPhoto]!
  userPhotosConnection(where: UserPhotoWhereInput, orderBy: UserPhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserPhotoConnection!
  userRole(where: UserRoleWhereUniqueInput!): UserRole
  userRoles(where: UserRoleWhereInput, orderBy: UserRoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserRole]!
  userRolesConnection(where: UserRoleWhereInput, orderBy: UserRoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserRoleConnection!
  userStatus(where: UserStatusWhereUniqueInput!): UserStatus
  userStatuses(where: UserStatusWhereInput, orderBy: UserStatusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserStatus]!
  userStatusesConnection(where: UserStatusWhereInput, orderBy: UserStatusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserStatusConnection!
  node(id: ID!): Node
}

type ScoringSystemDetail {
  id: ID!
  name: String!
  description: String
  isActive: Boolean!
  isDefault: Boolean!
  startDate: DateTime!
  endDate: DateTime
  points: Int!
  range: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  scoringType: ScoringType!
  lastModifiedBy: User!
  system: ScoringSystemHeader!
  inheritedFrom: DefaultScoringSystemDetail!
}

type ScoringSystemDetailConnection {
  pageInfo: PageInfo!
  edges: [ScoringSystemDetailEdge]!
  aggregate: AggregateScoringSystemDetail!
}

input ScoringSystemDetailCreateInput {
  id: ID
  name: String!
  description: String
  isActive: Boolean
  isDefault: Boolean
  startDate: DateTime!
  endDate: DateTime
  points: Int!
  range: Int!
  scoringType: ScoringTypeCreateOneInput!
  lastModifiedBy: UserCreateOneInput!
  system: ScoringSystemHeaderCreateOneWithoutDetailInput!
  inheritedFrom: DefaultScoringSystemDetailCreateOneInput!
}

input ScoringSystemDetailCreateManyWithoutSystemInput {
  create: [ScoringSystemDetailCreateWithoutSystemInput!]
  connect: [ScoringSystemDetailWhereUniqueInput!]
}

input ScoringSystemDetailCreateOneInput {
  create: ScoringSystemDetailCreateInput
  connect: ScoringSystemDetailWhereUniqueInput
}

input ScoringSystemDetailCreateWithoutSystemInput {
  id: ID
  name: String!
  description: String
  isActive: Boolean
  isDefault: Boolean
  startDate: DateTime!
  endDate: DateTime
  points: Int!
  range: Int!
  scoringType: ScoringTypeCreateOneInput!
  lastModifiedBy: UserCreateOneInput!
  inheritedFrom: DefaultScoringSystemDetailCreateOneInput!
}

type ScoringSystemDetailEdge {
  node: ScoringSystemDetail!
  cursor: String!
}

enum ScoringSystemDetailOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  isActive_ASC
  isActive_DESC
  isDefault_ASC
  isDefault_DESC
  startDate_ASC
  startDate_DESC
  endDate_ASC
  endDate_DESC
  points_ASC
  points_DESC
  range_ASC
  range_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ScoringSystemDetailPreviousValues {
  id: ID!
  name: String!
  description: String
  isActive: Boolean!
  isDefault: Boolean!
  startDate: DateTime!
  endDate: DateTime
  points: Int!
  range: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ScoringSystemDetailScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  isActive: Boolean
  isActive_not: Boolean
  isDefault: Boolean
  isDefault_not: Boolean
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  points: Int
  points_not: Int
  points_in: [Int!]
  points_not_in: [Int!]
  points_lt: Int
  points_lte: Int
  points_gt: Int
  points_gte: Int
  range: Int
  range_not: Int
  range_in: [Int!]
  range_not_in: [Int!]
  range_lt: Int
  range_lte: Int
  range_gt: Int
  range_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ScoringSystemDetailScalarWhereInput!]
  OR: [ScoringSystemDetailScalarWhereInput!]
  NOT: [ScoringSystemDetailScalarWhereInput!]
}

type ScoringSystemDetailSubscriptionPayload {
  mutation: MutationType!
  node: ScoringSystemDetail
  updatedFields: [String!]
  previousValues: ScoringSystemDetailPreviousValues
}

input ScoringSystemDetailSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ScoringSystemDetailWhereInput
  AND: [ScoringSystemDetailSubscriptionWhereInput!]
  OR: [ScoringSystemDetailSubscriptionWhereInput!]
  NOT: [ScoringSystemDetailSubscriptionWhereInput!]
}

input ScoringSystemDetailUpdateDataInput {
  name: String
  description: String
  isActive: Boolean
  isDefault: Boolean
  startDate: DateTime
  endDate: DateTime
  points: Int
  range: Int
  scoringType: ScoringTypeUpdateOneRequiredInput
  lastModifiedBy: UserUpdateOneRequiredInput
  system: ScoringSystemHeaderUpdateOneRequiredWithoutDetailInput
  inheritedFrom: DefaultScoringSystemDetailUpdateOneRequiredInput
}

input ScoringSystemDetailUpdateInput {
  name: String
  description: String
  isActive: Boolean
  isDefault: Boolean
  startDate: DateTime
  endDate: DateTime
  points: Int
  range: Int
  scoringType: ScoringTypeUpdateOneRequiredInput
  lastModifiedBy: UserUpdateOneRequiredInput
  system: ScoringSystemHeaderUpdateOneRequiredWithoutDetailInput
  inheritedFrom: DefaultScoringSystemDetailUpdateOneRequiredInput
}

input ScoringSystemDetailUpdateManyDataInput {
  name: String
  description: String
  isActive: Boolean
  isDefault: Boolean
  startDate: DateTime
  endDate: DateTime
  points: Int
  range: Int
}

input ScoringSystemDetailUpdateManyMutationInput {
  name: String
  description: String
  isActive: Boolean
  isDefault: Boolean
  startDate: DateTime
  endDate: DateTime
  points: Int
  range: Int
}

input ScoringSystemDetailUpdateManyWithoutSystemInput {
  create: [ScoringSystemDetailCreateWithoutSystemInput!]
  delete: [ScoringSystemDetailWhereUniqueInput!]
  connect: [ScoringSystemDetailWhereUniqueInput!]
  set: [ScoringSystemDetailWhereUniqueInput!]
  disconnect: [ScoringSystemDetailWhereUniqueInput!]
  update: [ScoringSystemDetailUpdateWithWhereUniqueWithoutSystemInput!]
  upsert: [ScoringSystemDetailUpsertWithWhereUniqueWithoutSystemInput!]
  deleteMany: [ScoringSystemDetailScalarWhereInput!]
  updateMany: [ScoringSystemDetailUpdateManyWithWhereNestedInput!]
}

input ScoringSystemDetailUpdateManyWithWhereNestedInput {
  where: ScoringSystemDetailScalarWhereInput!
  data: ScoringSystemDetailUpdateManyDataInput!
}

input ScoringSystemDetailUpdateOneRequiredInput {
  create: ScoringSystemDetailCreateInput
  update: ScoringSystemDetailUpdateDataInput
  upsert: ScoringSystemDetailUpsertNestedInput
  connect: ScoringSystemDetailWhereUniqueInput
}

input ScoringSystemDetailUpdateWithoutSystemDataInput {
  name: String
  description: String
  isActive: Boolean
  isDefault: Boolean
  startDate: DateTime
  endDate: DateTime
  points: Int
  range: Int
  scoringType: ScoringTypeUpdateOneRequiredInput
  lastModifiedBy: UserUpdateOneRequiredInput
  inheritedFrom: DefaultScoringSystemDetailUpdateOneRequiredInput
}

input ScoringSystemDetailUpdateWithWhereUniqueWithoutSystemInput {
  where: ScoringSystemDetailWhereUniqueInput!
  data: ScoringSystemDetailUpdateWithoutSystemDataInput!
}

input ScoringSystemDetailUpsertNestedInput {
  update: ScoringSystemDetailUpdateDataInput!
  create: ScoringSystemDetailCreateInput!
}

input ScoringSystemDetailUpsertWithWhereUniqueWithoutSystemInput {
  where: ScoringSystemDetailWhereUniqueInput!
  update: ScoringSystemDetailUpdateWithoutSystemDataInput!
  create: ScoringSystemDetailCreateWithoutSystemInput!
}

input ScoringSystemDetailWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  isActive: Boolean
  isActive_not: Boolean
  isDefault: Boolean
  isDefault_not: Boolean
  startDate: DateTime
  startDate_not: DateTime
  startDate_in: [DateTime!]
  startDate_not_in: [DateTime!]
  startDate_lt: DateTime
  startDate_lte: DateTime
  startDate_gt: DateTime
  startDate_gte: DateTime
  endDate: DateTime
  endDate_not: DateTime
  endDate_in: [DateTime!]
  endDate_not_in: [DateTime!]
  endDate_lt: DateTime
  endDate_lte: DateTime
  endDate_gt: DateTime
  endDate_gte: DateTime
  points: Int
  points_not: Int
  points_in: [Int!]
  points_not_in: [Int!]
  points_lt: Int
  points_lte: Int
  points_gt: Int
  points_gte: Int
  range: Int
  range_not: Int
  range_in: [Int!]
  range_not_in: [Int!]
  range_lt: Int
  range_lte: Int
  range_gt: Int
  range_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  scoringType: ScoringTypeWhereInput
  lastModifiedBy: UserWhereInput
  system: ScoringSystemHeaderWhereInput
  inheritedFrom: DefaultScoringSystemDetailWhereInput
  AND: [ScoringSystemDetailWhereInput!]
  OR: [ScoringSystemDetailWhereInput!]
  NOT: [ScoringSystemDetailWhereInput!]
}

input ScoringSystemDetailWhereUniqueInput {
  id: ID
}

type ScoringSystemHeader {
  id: ID!
  isCustom: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  contest: Contest!
  inheritedFrom: DefaultScoringSystemHeader
  detail(where: ScoringSystemDetailWhereInput, orderBy: ScoringSystemDetailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ScoringSystemDetail!]
}

type ScoringSystemHeaderConnection {
  pageInfo: PageInfo!
  edges: [ScoringSystemHeaderEdge]!
  aggregate: AggregateScoringSystemHeader!
}

input ScoringSystemHeaderCreateInput {
  id: ID
  isCustom: Boolean!
  contest: ContestCreateOneWithoutScoringSystemInput!
  inheritedFrom: DefaultScoringSystemHeaderCreateOneInput
  detail: ScoringSystemDetailCreateManyWithoutSystemInput
}

input ScoringSystemHeaderCreateOneWithoutContestInput {
  create: ScoringSystemHeaderCreateWithoutContestInput
  connect: ScoringSystemHeaderWhereUniqueInput
}

input ScoringSystemHeaderCreateOneWithoutDetailInput {
  create: ScoringSystemHeaderCreateWithoutDetailInput
  connect: ScoringSystemHeaderWhereUniqueInput
}

input ScoringSystemHeaderCreateWithoutContestInput {
  id: ID
  isCustom: Boolean!
  inheritedFrom: DefaultScoringSystemHeaderCreateOneInput
  detail: ScoringSystemDetailCreateManyWithoutSystemInput
}

input ScoringSystemHeaderCreateWithoutDetailInput {
  id: ID
  isCustom: Boolean!
  contest: ContestCreateOneWithoutScoringSystemInput!
  inheritedFrom: DefaultScoringSystemHeaderCreateOneInput
}

type ScoringSystemHeaderEdge {
  node: ScoringSystemHeader!
  cursor: String!
}

enum ScoringSystemHeaderOrderByInput {
  id_ASC
  id_DESC
  isCustom_ASC
  isCustom_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ScoringSystemHeaderPreviousValues {
  id: ID!
  isCustom: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ScoringSystemHeaderSubscriptionPayload {
  mutation: MutationType!
  node: ScoringSystemHeader
  updatedFields: [String!]
  previousValues: ScoringSystemHeaderPreviousValues
}

input ScoringSystemHeaderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ScoringSystemHeaderWhereInput
  AND: [ScoringSystemHeaderSubscriptionWhereInput!]
  OR: [ScoringSystemHeaderSubscriptionWhereInput!]
  NOT: [ScoringSystemHeaderSubscriptionWhereInput!]
}

input ScoringSystemHeaderUpdateInput {
  isCustom: Boolean
  contest: ContestUpdateOneRequiredWithoutScoringSystemInput
  inheritedFrom: DefaultScoringSystemHeaderUpdateOneInput
  detail: ScoringSystemDetailUpdateManyWithoutSystemInput
}

input ScoringSystemHeaderUpdateManyMutationInput {
  isCustom: Boolean
}

input ScoringSystemHeaderUpdateOneRequiredWithoutContestInput {
  create: ScoringSystemHeaderCreateWithoutContestInput
  update: ScoringSystemHeaderUpdateWithoutContestDataInput
  upsert: ScoringSystemHeaderUpsertWithoutContestInput
  connect: ScoringSystemHeaderWhereUniqueInput
}

input ScoringSystemHeaderUpdateOneRequiredWithoutDetailInput {
  create: ScoringSystemHeaderCreateWithoutDetailInput
  update: ScoringSystemHeaderUpdateWithoutDetailDataInput
  upsert: ScoringSystemHeaderUpsertWithoutDetailInput
  connect: ScoringSystemHeaderWhereUniqueInput
}

input ScoringSystemHeaderUpdateWithoutContestDataInput {
  isCustom: Boolean
  inheritedFrom: DefaultScoringSystemHeaderUpdateOneInput
  detail: ScoringSystemDetailUpdateManyWithoutSystemInput
}

input ScoringSystemHeaderUpdateWithoutDetailDataInput {
  isCustom: Boolean
  contest: ContestUpdateOneRequiredWithoutScoringSystemInput
  inheritedFrom: DefaultScoringSystemHeaderUpdateOneInput
}

input ScoringSystemHeaderUpsertWithoutContestInput {
  update: ScoringSystemHeaderUpdateWithoutContestDataInput!
  create: ScoringSystemHeaderCreateWithoutContestInput!
}

input ScoringSystemHeaderUpsertWithoutDetailInput {
  update: ScoringSystemHeaderUpdateWithoutDetailDataInput!
  create: ScoringSystemHeaderCreateWithoutDetailInput!
}

input ScoringSystemHeaderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  isCustom: Boolean
  isCustom_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  contest: ContestWhereInput
  inheritedFrom: DefaultScoringSystemHeaderWhereInput
  detail_every: ScoringSystemDetailWhereInput
  detail_some: ScoringSystemDetailWhereInput
  detail_none: ScoringSystemDetailWhereInput
  AND: [ScoringSystemHeaderWhereInput!]
  OR: [ScoringSystemHeaderWhereInput!]
  NOT: [ScoringSystemHeaderWhereInput!]
}

input ScoringSystemHeaderWhereUniqueInput {
  id: ID
}

type ScoringType {
  id: ID!
  name: String!
  description: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ScoringTypeConnection {
  pageInfo: PageInfo!
  edges: [ScoringTypeEdge]!
  aggregate: AggregateScoringType!
}

input ScoringTypeCreateInput {
  id: ID
  name: String!
  description: String!
}

input ScoringTypeCreateOneInput {
  create: ScoringTypeCreateInput
  connect: ScoringTypeWhereUniqueInput
}

type ScoringTypeEdge {
  node: ScoringType!
  cursor: String!
}

enum ScoringTypeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ScoringTypePreviousValues {
  id: ID!
  name: String!
  description: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ScoringTypeSubscriptionPayload {
  mutation: MutationType!
  node: ScoringType
  updatedFields: [String!]
  previousValues: ScoringTypePreviousValues
}

input ScoringTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ScoringTypeWhereInput
  AND: [ScoringTypeSubscriptionWhereInput!]
  OR: [ScoringTypeSubscriptionWhereInput!]
  NOT: [ScoringTypeSubscriptionWhereInput!]
}

input ScoringTypeUpdateDataInput {
  name: String
  description: String
}

input ScoringTypeUpdateInput {
  name: String
  description: String
}

input ScoringTypeUpdateManyMutationInput {
  name: String
  description: String
}

input ScoringTypeUpdateOneRequiredInput {
  create: ScoringTypeCreateInput
  update: ScoringTypeUpdateDataInput
  upsert: ScoringTypeUpsertNestedInput
  connect: ScoringTypeWhereUniqueInput
}

input ScoringTypeUpsertNestedInput {
  update: ScoringTypeUpdateDataInput!
  create: ScoringTypeCreateInput!
}

input ScoringTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ScoringTypeWhereInput!]
  OR: [ScoringTypeWhereInput!]
  NOT: [ScoringTypeWhereInput!]
}

input ScoringTypeWhereUniqueInput {
  id: ID
  name: String
}

type Season {
  id: ID!
  fplId: Int!
  label: String!
  competition: String!
  startYear: Int!
  endYear: Int!
  isCurrent: Boolean!
  isPrevious: Boolean!
  isNext: Boolean!
  events(where: GameweekWhereInput, orderBy: GameweekOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Gameweek!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SeasonConnection {
  pageInfo: PageInfo!
  edges: [SeasonEdge]!
  aggregate: AggregateSeason!
}

input SeasonCreateInput {
  id: ID
  fplId: Int!
  label: String!
  competition: String!
  startYear: Int!
  endYear: Int!
  isCurrent: Boolean!
  isPrevious: Boolean!
  isNext: Boolean!
  events: GameweekCreateManyWithoutSeasonInput
}

input SeasonCreateOneInput {
  create: SeasonCreateInput
  connect: SeasonWhereUniqueInput
}

input SeasonCreateOneWithoutEventsInput {
  create: SeasonCreateWithoutEventsInput
  connect: SeasonWhereUniqueInput
}

input SeasonCreateWithoutEventsInput {
  id: ID
  fplId: Int!
  label: String!
  competition: String!
  startYear: Int!
  endYear: Int!
  isCurrent: Boolean!
  isPrevious: Boolean!
  isNext: Boolean!
}

type SeasonEdge {
  node: Season!
  cursor: String!
}

enum SeasonOrderByInput {
  id_ASC
  id_DESC
  fplId_ASC
  fplId_DESC
  label_ASC
  label_DESC
  competition_ASC
  competition_DESC
  startYear_ASC
  startYear_DESC
  endYear_ASC
  endYear_DESC
  isCurrent_ASC
  isCurrent_DESC
  isPrevious_ASC
  isPrevious_DESC
  isNext_ASC
  isNext_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SeasonPreviousValues {
  id: ID!
  fplId: Int!
  label: String!
  competition: String!
  startYear: Int!
  endYear: Int!
  isCurrent: Boolean!
  isPrevious: Boolean!
  isNext: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SeasonSubscriptionPayload {
  mutation: MutationType!
  node: Season
  updatedFields: [String!]
  previousValues: SeasonPreviousValues
}

input SeasonSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SeasonWhereInput
  AND: [SeasonSubscriptionWhereInput!]
  OR: [SeasonSubscriptionWhereInput!]
  NOT: [SeasonSubscriptionWhereInput!]
}

input SeasonUpdateDataInput {
  fplId: Int
  label: String
  competition: String
  startYear: Int
  endYear: Int
  isCurrent: Boolean
  isPrevious: Boolean
  isNext: Boolean
  events: GameweekUpdateManyWithoutSeasonInput
}

input SeasonUpdateInput {
  fplId: Int
  label: String
  competition: String
  startYear: Int
  endYear: Int
  isCurrent: Boolean
  isPrevious: Boolean
  isNext: Boolean
  events: GameweekUpdateManyWithoutSeasonInput
}

input SeasonUpdateManyMutationInput {
  fplId: Int
  label: String
  competition: String
  startYear: Int
  endYear: Int
  isCurrent: Boolean
  isPrevious: Boolean
  isNext: Boolean
}

input SeasonUpdateOneRequiredInput {
  create: SeasonCreateInput
  update: SeasonUpdateDataInput
  upsert: SeasonUpsertNestedInput
  connect: SeasonWhereUniqueInput
}

input SeasonUpdateOneRequiredWithoutEventsInput {
  create: SeasonCreateWithoutEventsInput
  update: SeasonUpdateWithoutEventsDataInput
  upsert: SeasonUpsertWithoutEventsInput
  connect: SeasonWhereUniqueInput
}

input SeasonUpdateWithoutEventsDataInput {
  fplId: Int
  label: String
  competition: String
  startYear: Int
  endYear: Int
  isCurrent: Boolean
  isPrevious: Boolean
  isNext: Boolean
}

input SeasonUpsertNestedInput {
  update: SeasonUpdateDataInput!
  create: SeasonCreateInput!
}

input SeasonUpsertWithoutEventsInput {
  update: SeasonUpdateWithoutEventsDataInput!
  create: SeasonCreateWithoutEventsInput!
}

input SeasonWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fplId: Int
  fplId_not: Int
  fplId_in: [Int!]
  fplId_not_in: [Int!]
  fplId_lt: Int
  fplId_lte: Int
  fplId_gt: Int
  fplId_gte: Int
  label: String
  label_not: String
  label_in: [String!]
  label_not_in: [String!]
  label_lt: String
  label_lte: String
  label_gt: String
  label_gte: String
  label_contains: String
  label_not_contains: String
  label_starts_with: String
  label_not_starts_with: String
  label_ends_with: String
  label_not_ends_with: String
  competition: String
  competition_not: String
  competition_in: [String!]
  competition_not_in: [String!]
  competition_lt: String
  competition_lte: String
  competition_gt: String
  competition_gte: String
  competition_contains: String
  competition_not_contains: String
  competition_starts_with: String
  competition_not_starts_with: String
  competition_ends_with: String
  competition_not_ends_with: String
  startYear: Int
  startYear_not: Int
  startYear_in: [Int!]
  startYear_not_in: [Int!]
  startYear_lt: Int
  startYear_lte: Int
  startYear_gt: Int
  startYear_gte: Int
  endYear: Int
  endYear_not: Int
  endYear_in: [Int!]
  endYear_not_in: [Int!]
  endYear_lt: Int
  endYear_lte: Int
  endYear_gt: Int
  endYear_gte: Int
  isCurrent: Boolean
  isCurrent_not: Boolean
  isPrevious: Boolean
  isPrevious_not: Boolean
  isNext: Boolean
  isNext_not: Boolean
  events_every: GameweekWhereInput
  events_some: GameweekWhereInput
  events_none: GameweekWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SeasonWhereInput!]
  OR: [SeasonWhereInput!]
  NOT: [SeasonWhereInput!]
}

input SeasonWhereUniqueInput {
  id: ID
  fplId: Int
}

type Status {
  id: ID!
  author: UserStatus
  content: String!
  likes(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StatusConnection {
  pageInfo: PageInfo!
  edges: [StatusEdge]!
  aggregate: AggregateStatus!
}

input StatusCreateInput {
  id: ID
  author: UserStatusCreateOneWithoutStatusInput
  content: String!
  likes: UserCreateManyInput
}

input StatusCreateOneWithoutAuthorInput {
  create: StatusCreateWithoutAuthorInput
  connect: StatusWhereUniqueInput
}

input StatusCreateWithoutAuthorInput {
  id: ID
  content: String!
  likes: UserCreateManyInput
}

type StatusEdge {
  node: Status!
  cursor: String!
}

enum StatusOrderByInput {
  id_ASC
  id_DESC
  content_ASC
  content_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StatusPreviousValues {
  id: ID!
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type StatusSubscriptionPayload {
  mutation: MutationType!
  node: Status
  updatedFields: [String!]
  previousValues: StatusPreviousValues
}

input StatusSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StatusWhereInput
  AND: [StatusSubscriptionWhereInput!]
  OR: [StatusSubscriptionWhereInput!]
  NOT: [StatusSubscriptionWhereInput!]
}

input StatusUpdateInput {
  author: UserStatusUpdateOneWithoutStatusInput
  content: String
  likes: UserUpdateManyInput
}

input StatusUpdateManyMutationInput {
  content: String
}

input StatusUpdateOneWithoutAuthorInput {
  create: StatusCreateWithoutAuthorInput
  update: StatusUpdateWithoutAuthorDataInput
  upsert: StatusUpsertWithoutAuthorInput
  delete: Boolean
  disconnect: Boolean
  connect: StatusWhereUniqueInput
}

input StatusUpdateWithoutAuthorDataInput {
  content: String
  likes: UserUpdateManyInput
}

input StatusUpsertWithoutAuthorInput {
  update: StatusUpdateWithoutAuthorDataInput!
  create: StatusCreateWithoutAuthorInput!
}

input StatusWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  author: UserStatusWhereInput
  content: String
  content_not: String
  content_in: [String!]
  content_not_in: [String!]
  content_lt: String
  content_lte: String
  content_gt: String
  content_gte: String
  content_contains: String
  content_not_contains: String
  content_starts_with: String
  content_not_starts_with: String
  content_ends_with: String
  content_not_ends_with: String
  likes_every: UserWhereInput
  likes_some: UserWhereInput
  likes_none: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [StatusWhereInput!]
  OR: [StatusWhereInput!]
  NOT: [StatusWhereInput!]
}

input StatusWhereUniqueInput {
  id: ID
}

type Subscription {
  activeSubscriptions(where: ActiveSubscriptionsSubscriptionWhereInput): ActiveSubscriptionsSubscriptionPayload
  awayTeamFixture(where: AwayTeamFixtureSubscriptionWhereInput): AwayTeamFixtureSubscriptionPayload
  contest(where: ContestSubscriptionWhereInput): ContestSubscriptionPayload
  contestCreator(where: ContestCreatorSubscriptionWhereInput): ContestCreatorSubscriptionPayload
  contestInviter(where: ContestInviterSubscriptionWhereInput): ContestInviterSubscriptionPayload
  contestOwner(where: ContestOwnerSubscriptionWhereInput): ContestOwnerSubscriptionPayload
  contestPrediction(where: ContestPredictionSubscriptionWhereInput): ContestPredictionSubscriptionPayload
  contestPredictionScore(where: ContestPredictionScoreSubscriptionWhereInput): ContestPredictionScoreSubscriptionPayload
  contestSlate(where: ContestSlateSubscriptionWhereInput): ContestSlateSubscriptionPayload
  contestSlateEntry(where: ContestSlateEntrySubscriptionWhereInput): ContestSlateEntrySubscriptionPayload
  contestType(where: ContestTypeSubscriptionWhereInput): ContestTypeSubscriptionPayload
  contestUser(where: ContestUserSubscriptionWhereInput): ContestUserSubscriptionPayload
  contestUserType(where: ContestUserTypeSubscriptionWhereInput): ContestUserTypeSubscriptionPayload
  country(where: CountrySubscriptionWhereInput): CountrySubscriptionPayload
  defaultScoringSystemDetail(where: DefaultScoringSystemDetailSubscriptionWhereInput): DefaultScoringSystemDetailSubscriptionPayload
  defaultScoringSystemHeader(where: DefaultScoringSystemHeaderSubscriptionWhereInput): DefaultScoringSystemHeaderSubscriptionPayload
  fandemSubscription(where: FandemSubscriptionSubscriptionWhereInput): FandemSubscriptionSubscriptionPayload
  fixture(where: FixtureSubscriptionWhereInput): FixtureSubscriptionPayload
  follower(where: FollowerSubscriptionWhereInput): FollowerSubscriptionPayload
  gameweek(where: GameweekSubscriptionWhereInput): GameweekSubscriptionPayload
  homeTeamFixture(where: HomeTeamFixtureSubscriptionWhereInput): HomeTeamFixtureSubscriptionPayload
  influencer(where: InfluencerSubscriptionWhereInput): InfluencerSubscriptionPayload
  photo(where: PhotoSubscriptionWhereInput): PhotoSubscriptionPayload
  scoringSystemDetail(where: ScoringSystemDetailSubscriptionWhereInput): ScoringSystemDetailSubscriptionPayload
  scoringSystemHeader(where: ScoringSystemHeaderSubscriptionWhereInput): ScoringSystemHeaderSubscriptionPayload
  scoringType(where: ScoringTypeSubscriptionWhereInput): ScoringTypeSubscriptionPayload
  season(where: SeasonSubscriptionWhereInput): SeasonSubscriptionPayload
  status(where: StatusSubscriptionWhereInput): StatusSubscriptionPayload
  team(where: TeamSubscriptionWhereInput): TeamSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  userAssignedRole(where: UserAssignedRoleSubscriptionWhereInput): UserAssignedRoleSubscriptionPayload
  userFollowers(where: UserFollowersSubscriptionWhereInput): UserFollowersSubscriptionPayload
  userInfluencers(where: UserInfluencersSubscriptionWhereInput): UserInfluencersSubscriptionPayload
  userPhoto(where: UserPhotoSubscriptionWhereInput): UserPhotoSubscriptionPayload
  userRole(where: UserRoleSubscriptionWhereInput): UserRoleSubscriptionPayload
  userStatus(where: UserStatusSubscriptionWhereInput): UserStatusSubscriptionPayload
}

type Team {
  id: ID!
  code: Int!
  season: Season!
  fplTeamId: Int!
  name: String!
  shortName: String!
  strength: Int!
  strengthAttackAway: Int!
  strengthAttackHome: Int!
  strengthDefenceAway: Int!
  strengthDefenceHome: Int!
  strengthOverallAway: Int!
  strengthOverallHome: Int!
  teamDivision: Int
  homeFixtures(where: HomeTeamFixtureWhereInput, orderBy: HomeTeamFixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [HomeTeamFixture!]
  awayFixtures(where: AwayTeamFixtureWhereInput, orderBy: AwayTeamFixtureOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AwayTeamFixture!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TeamConnection {
  pageInfo: PageInfo!
  edges: [TeamEdge]!
  aggregate: AggregateTeam!
}

input TeamCreateInput {
  id: ID
  code: Int!
  season: SeasonCreateOneInput!
  fplTeamId: Int!
  name: String!
  shortName: String!
  strength: Int!
  strengthAttackAway: Int!
  strengthAttackHome: Int!
  strengthDefenceAway: Int!
  strengthDefenceHome: Int!
  strengthOverallAway: Int!
  strengthOverallHome: Int!
  teamDivision: Int
  homeFixtures: HomeTeamFixtureCreateManyWithoutHomeTeamInput
  awayFixtures: AwayTeamFixtureCreateManyWithoutAwayTeamInput
}

input TeamCreateOneInput {
  create: TeamCreateInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutAwayFixturesInput {
  create: TeamCreateWithoutAwayFixturesInput
  connect: TeamWhereUniqueInput
}

input TeamCreateOneWithoutHomeFixturesInput {
  create: TeamCreateWithoutHomeFixturesInput
  connect: TeamWhereUniqueInput
}

input TeamCreateWithoutAwayFixturesInput {
  id: ID
  code: Int!
  season: SeasonCreateOneInput!
  fplTeamId: Int!
  name: String!
  shortName: String!
  strength: Int!
  strengthAttackAway: Int!
  strengthAttackHome: Int!
  strengthDefenceAway: Int!
  strengthDefenceHome: Int!
  strengthOverallAway: Int!
  strengthOverallHome: Int!
  teamDivision: Int
  homeFixtures: HomeTeamFixtureCreateManyWithoutHomeTeamInput
}

input TeamCreateWithoutHomeFixturesInput {
  id: ID
  code: Int!
  season: SeasonCreateOneInput!
  fplTeamId: Int!
  name: String!
  shortName: String!
  strength: Int!
  strengthAttackAway: Int!
  strengthAttackHome: Int!
  strengthDefenceAway: Int!
  strengthDefenceHome: Int!
  strengthOverallAway: Int!
  strengthOverallHome: Int!
  teamDivision: Int
  awayFixtures: AwayTeamFixtureCreateManyWithoutAwayTeamInput
}

type TeamEdge {
  node: Team!
  cursor: String!
}

enum TeamOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  fplTeamId_ASC
  fplTeamId_DESC
  name_ASC
  name_DESC
  shortName_ASC
  shortName_DESC
  strength_ASC
  strength_DESC
  strengthAttackAway_ASC
  strengthAttackAway_DESC
  strengthAttackHome_ASC
  strengthAttackHome_DESC
  strengthDefenceAway_ASC
  strengthDefenceAway_DESC
  strengthDefenceHome_ASC
  strengthDefenceHome_DESC
  strengthOverallAway_ASC
  strengthOverallAway_DESC
  strengthOverallHome_ASC
  strengthOverallHome_DESC
  teamDivision_ASC
  teamDivision_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TeamPreviousValues {
  id: ID!
  code: Int!
  fplTeamId: Int!
  name: String!
  shortName: String!
  strength: Int!
  strengthAttackAway: Int!
  strengthAttackHome: Int!
  strengthDefenceAway: Int!
  strengthDefenceHome: Int!
  strengthOverallAway: Int!
  strengthOverallHome: Int!
  teamDivision: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TeamSubscriptionPayload {
  mutation: MutationType!
  node: Team
  updatedFields: [String!]
  previousValues: TeamPreviousValues
}

input TeamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeamWhereInput
  AND: [TeamSubscriptionWhereInput!]
  OR: [TeamSubscriptionWhereInput!]
  NOT: [TeamSubscriptionWhereInput!]
}

input TeamUpdateDataInput {
  code: Int
  season: SeasonUpdateOneRequiredInput
  fplTeamId: Int
  name: String
  shortName: String
  strength: Int
  strengthAttackAway: Int
  strengthAttackHome: Int
  strengthDefenceAway: Int
  strengthDefenceHome: Int
  strengthOverallAway: Int
  strengthOverallHome: Int
  teamDivision: Int
  homeFixtures: HomeTeamFixtureUpdateManyWithoutHomeTeamInput
  awayFixtures: AwayTeamFixtureUpdateManyWithoutAwayTeamInput
}

input TeamUpdateInput {
  code: Int
  season: SeasonUpdateOneRequiredInput
  fplTeamId: Int
  name: String
  shortName: String
  strength: Int
  strengthAttackAway: Int
  strengthAttackHome: Int
  strengthDefenceAway: Int
  strengthDefenceHome: Int
  strengthOverallAway: Int
  strengthOverallHome: Int
  teamDivision: Int
  homeFixtures: HomeTeamFixtureUpdateManyWithoutHomeTeamInput
  awayFixtures: AwayTeamFixtureUpdateManyWithoutAwayTeamInput
}

input TeamUpdateManyMutationInput {
  code: Int
  fplTeamId: Int
  name: String
  shortName: String
  strength: Int
  strengthAttackAway: Int
  strengthAttackHome: Int
  strengthDefenceAway: Int
  strengthDefenceHome: Int
  strengthOverallAway: Int
  strengthOverallHome: Int
  teamDivision: Int
}

input TeamUpdateOneInput {
  create: TeamCreateInput
  update: TeamUpdateDataInput
  upsert: TeamUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneRequiredWithoutAwayFixturesInput {
  create: TeamCreateWithoutAwayFixturesInput
  update: TeamUpdateWithoutAwayFixturesDataInput
  upsert: TeamUpsertWithoutAwayFixturesInput
  connect: TeamWhereUniqueInput
}

input TeamUpdateOneRequiredWithoutHomeFixturesInput {
  create: TeamCreateWithoutHomeFixturesInput
  update: TeamUpdateWithoutHomeFixturesDataInput
  upsert: TeamUpsertWithoutHomeFixturesInput
  connect: TeamWhereUniqueInput
}

input TeamUpdateWithoutAwayFixturesDataInput {
  code: Int
  season: SeasonUpdateOneRequiredInput
  fplTeamId: Int
  name: String
  shortName: String
  strength: Int
  strengthAttackAway: Int
  strengthAttackHome: Int
  strengthDefenceAway: Int
  strengthDefenceHome: Int
  strengthOverallAway: Int
  strengthOverallHome: Int
  teamDivision: Int
  homeFixtures: HomeTeamFixtureUpdateManyWithoutHomeTeamInput
}

input TeamUpdateWithoutHomeFixturesDataInput {
  code: Int
  season: SeasonUpdateOneRequiredInput
  fplTeamId: Int
  name: String
  shortName: String
  strength: Int
  strengthAttackAway: Int
  strengthAttackHome: Int
  strengthDefenceAway: Int
  strengthDefenceHome: Int
  strengthOverallAway: Int
  strengthOverallHome: Int
  teamDivision: Int
  awayFixtures: AwayTeamFixtureUpdateManyWithoutAwayTeamInput
}

input TeamUpsertNestedInput {
  update: TeamUpdateDataInput!
  create: TeamCreateInput!
}

input TeamUpsertWithoutAwayFixturesInput {
  update: TeamUpdateWithoutAwayFixturesDataInput!
  create: TeamCreateWithoutAwayFixturesInput!
}

input TeamUpsertWithoutHomeFixturesInput {
  update: TeamUpdateWithoutHomeFixturesDataInput!
  create: TeamCreateWithoutHomeFixturesInput!
}

input TeamWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: Int
  code_not: Int
  code_in: [Int!]
  code_not_in: [Int!]
  code_lt: Int
  code_lte: Int
  code_gt: Int
  code_gte: Int
  season: SeasonWhereInput
  fplTeamId: Int
  fplTeamId_not: Int
  fplTeamId_in: [Int!]
  fplTeamId_not_in: [Int!]
  fplTeamId_lt: Int
  fplTeamId_lte: Int
  fplTeamId_gt: Int
  fplTeamId_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  shortName: String
  shortName_not: String
  shortName_in: [String!]
  shortName_not_in: [String!]
  shortName_lt: String
  shortName_lte: String
  shortName_gt: String
  shortName_gte: String
  shortName_contains: String
  shortName_not_contains: String
  shortName_starts_with: String
  shortName_not_starts_with: String
  shortName_ends_with: String
  shortName_not_ends_with: String
  strength: Int
  strength_not: Int
  strength_in: [Int!]
  strength_not_in: [Int!]
  strength_lt: Int
  strength_lte: Int
  strength_gt: Int
  strength_gte: Int
  strengthAttackAway: Int
  strengthAttackAway_not: Int
  strengthAttackAway_in: [Int!]
  strengthAttackAway_not_in: [Int!]
  strengthAttackAway_lt: Int
  strengthAttackAway_lte: Int
  strengthAttackAway_gt: Int
  strengthAttackAway_gte: Int
  strengthAttackHome: Int
  strengthAttackHome_not: Int
  strengthAttackHome_in: [Int!]
  strengthAttackHome_not_in: [Int!]
  strengthAttackHome_lt: Int
  strengthAttackHome_lte: Int
  strengthAttackHome_gt: Int
  strengthAttackHome_gte: Int
  strengthDefenceAway: Int
  strengthDefenceAway_not: Int
  strengthDefenceAway_in: [Int!]
  strengthDefenceAway_not_in: [Int!]
  strengthDefenceAway_lt: Int
  strengthDefenceAway_lte: Int
  strengthDefenceAway_gt: Int
  strengthDefenceAway_gte: Int
  strengthDefenceHome: Int
  strengthDefenceHome_not: Int
  strengthDefenceHome_in: [Int!]
  strengthDefenceHome_not_in: [Int!]
  strengthDefenceHome_lt: Int
  strengthDefenceHome_lte: Int
  strengthDefenceHome_gt: Int
  strengthDefenceHome_gte: Int
  strengthOverallAway: Int
  strengthOverallAway_not: Int
  strengthOverallAway_in: [Int!]
  strengthOverallAway_not_in: [Int!]
  strengthOverallAway_lt: Int
  strengthOverallAway_lte: Int
  strengthOverallAway_gt: Int
  strengthOverallAway_gte: Int
  strengthOverallHome: Int
  strengthOverallHome_not: Int
  strengthOverallHome_in: [Int!]
  strengthOverallHome_not_in: [Int!]
  strengthOverallHome_lt: Int
  strengthOverallHome_lte: Int
  strengthOverallHome_gt: Int
  strengthOverallHome_gte: Int
  teamDivision: Int
  teamDivision_not: Int
  teamDivision_in: [Int!]
  teamDivision_not_in: [Int!]
  teamDivision_lt: Int
  teamDivision_lte: Int
  teamDivision_gt: Int
  teamDivision_gte: Int
  homeFixtures_every: HomeTeamFixtureWhereInput
  homeFixtures_some: HomeTeamFixtureWhereInput
  homeFixtures_none: HomeTeamFixtureWhereInput
  awayFixtures_every: AwayTeamFixtureWhereInput
  awayFixtures_some: AwayTeamFixtureWhereInput
  awayFixtures_none: AwayTeamFixtureWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  NOT: [TeamWhereInput!]
}

input TeamWhereUniqueInput {
  id: ID
  code: Int
}

type User {
  id: ID!
  email: String!
  name: String!
  countryCode: String
  phoneNumber: String
  favoriteTeam: Team
  country: Country
  displayName: String!
  isPrivate: Boolean!
  password: String!
  photos(where: UserPhotoWhereInput, orderBy: UserPhotoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserPhoto!]
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean!
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions(where: FandemSubscriptionWhereInput, orderBy: FandemSubscriptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FandemSubscription!]
  userRoles(where: UserRoleWhereInput, orderBy: UserRoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserRole!]
  status(where: UserStatusWhereInput, orderBy: UserStatusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserStatus!]
  followers: UserFollowers
  influencers: UserInfluencers
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserAssignedRole {
  id: ID!
  user: User!
  userRole: UserRole!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserAssignedRoleConnection {
  pageInfo: PageInfo!
  edges: [UserAssignedRoleEdge]!
  aggregate: AggregateUserAssignedRole!
}

input UserAssignedRoleCreateInput {
  id: ID
  user: UserCreateOneInput!
  userRole: UserRoleCreateOneInput!
}

type UserAssignedRoleEdge {
  node: UserAssignedRole!
  cursor: String!
}

enum UserAssignedRoleOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserAssignedRolePreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserAssignedRoleSubscriptionPayload {
  mutation: MutationType!
  node: UserAssignedRole
  updatedFields: [String!]
  previousValues: UserAssignedRolePreviousValues
}

input UserAssignedRoleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserAssignedRoleWhereInput
  AND: [UserAssignedRoleSubscriptionWhereInput!]
  OR: [UserAssignedRoleSubscriptionWhereInput!]
  NOT: [UserAssignedRoleSubscriptionWhereInput!]
}

input UserAssignedRoleUpdateInput {
  user: UserUpdateOneRequiredInput
  userRole: UserRoleUpdateOneRequiredInput
}

input UserAssignedRoleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  userRole: UserRoleWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserAssignedRoleWhereInput!]
  OR: [UserAssignedRoleWhereInput!]
  NOT: [UserAssignedRoleWhereInput!]
}

input UserAssignedRoleWhereUniqueInput {
  id: ID
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  name: String!
  countryCode: String
  phoneNumber: String
  favoriteTeam: TeamCreateOneInput
  country: CountryCreateOneInput
  displayName: String!
  isPrivate: Boolean
  password: String!
  photos: UserPhotoCreateManyWithoutUserInput
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions: FandemSubscriptionCreateManyInput
  userRoles: UserRoleCreateManyInput
  status: UserStatusCreateManyInput
  followers: UserFollowersCreateOneWithoutUserInput
  influencers: UserInfluencersCreateOneWithoutUserInput
}

input UserCreateManyInput {
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutFollowersInput {
  create: UserCreateWithoutFollowersInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutInfluencersInput {
  create: UserCreateWithoutInfluencersInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPhotosInput {
  create: UserCreateWithoutPhotosInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutFollowersInput {
  id: ID
  email: String!
  name: String!
  countryCode: String
  phoneNumber: String
  favoriteTeam: TeamCreateOneInput
  country: CountryCreateOneInput
  displayName: String!
  isPrivate: Boolean
  password: String!
  photos: UserPhotoCreateManyWithoutUserInput
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions: FandemSubscriptionCreateManyInput
  userRoles: UserRoleCreateManyInput
  status: UserStatusCreateManyInput
  influencers: UserInfluencersCreateOneWithoutUserInput
}

input UserCreateWithoutInfluencersInput {
  id: ID
  email: String!
  name: String!
  countryCode: String
  phoneNumber: String
  favoriteTeam: TeamCreateOneInput
  country: CountryCreateOneInput
  displayName: String!
  isPrivate: Boolean
  password: String!
  photos: UserPhotoCreateManyWithoutUserInput
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions: FandemSubscriptionCreateManyInput
  userRoles: UserRoleCreateManyInput
  status: UserStatusCreateManyInput
  followers: UserFollowersCreateOneWithoutUserInput
}

input UserCreateWithoutPhotosInput {
  id: ID
  email: String!
  name: String!
  countryCode: String
  phoneNumber: String
  favoriteTeam: TeamCreateOneInput
  country: CountryCreateOneInput
  displayName: String!
  isPrivate: Boolean
  password: String!
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions: FandemSubscriptionCreateManyInput
  userRoles: UserRoleCreateManyInput
  status: UserStatusCreateManyInput
  followers: UserFollowersCreateOneWithoutUserInput
  influencers: UserInfluencersCreateOneWithoutUserInput
}

type UserEdge {
  node: User!
  cursor: String!
}

type UserFollowers {
  id: ID!
  followers(where: FollowerWhereInput, orderBy: FollowerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Follower!]
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserFollowersConnection {
  pageInfo: PageInfo!
  edges: [UserFollowersEdge]!
  aggregate: AggregateUserFollowers!
}

input UserFollowersCreateInput {
  id: ID
  followers: FollowerCreateManyInput
  user: UserCreateOneWithoutFollowersInput!
}

input UserFollowersCreateOneWithoutUserInput {
  create: UserFollowersCreateWithoutUserInput
  connect: UserFollowersWhereUniqueInput
}

input UserFollowersCreateWithoutUserInput {
  id: ID
  followers: FollowerCreateManyInput
}

type UserFollowersEdge {
  node: UserFollowers!
  cursor: String!
}

enum UserFollowersOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserFollowersPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserFollowersSubscriptionPayload {
  mutation: MutationType!
  node: UserFollowers
  updatedFields: [String!]
  previousValues: UserFollowersPreviousValues
}

input UserFollowersSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserFollowersWhereInput
  AND: [UserFollowersSubscriptionWhereInput!]
  OR: [UserFollowersSubscriptionWhereInput!]
  NOT: [UserFollowersSubscriptionWhereInput!]
}

input UserFollowersUpdateInput {
  followers: FollowerUpdateManyInput
  user: UserUpdateOneRequiredWithoutFollowersInput
}

input UserFollowersUpdateOneWithoutUserInput {
  create: UserFollowersCreateWithoutUserInput
  update: UserFollowersUpdateWithoutUserDataInput
  upsert: UserFollowersUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  connect: UserFollowersWhereUniqueInput
}

input UserFollowersUpdateWithoutUserDataInput {
  followers: FollowerUpdateManyInput
}

input UserFollowersUpsertWithoutUserInput {
  update: UserFollowersUpdateWithoutUserDataInput!
  create: UserFollowersCreateWithoutUserInput!
}

input UserFollowersWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  followers_every: FollowerWhereInput
  followers_some: FollowerWhereInput
  followers_none: FollowerWhereInput
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserFollowersWhereInput!]
  OR: [UserFollowersWhereInput!]
  NOT: [UserFollowersWhereInput!]
}

input UserFollowersWhereUniqueInput {
  id: ID
}

type UserInfluencers {
  id: ID!
  user: User!
  influencers(where: InfluencerWhereInput, orderBy: InfluencerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Influencer!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserInfluencersConnection {
  pageInfo: PageInfo!
  edges: [UserInfluencersEdge]!
  aggregate: AggregateUserInfluencers!
}

input UserInfluencersCreateInput {
  id: ID
  user: UserCreateOneWithoutInfluencersInput!
  influencers: InfluencerCreateManyInput
}

input UserInfluencersCreateOneWithoutUserInput {
  create: UserInfluencersCreateWithoutUserInput
  connect: UserInfluencersWhereUniqueInput
}

input UserInfluencersCreateWithoutUserInput {
  id: ID
  influencers: InfluencerCreateManyInput
}

type UserInfluencersEdge {
  node: UserInfluencers!
  cursor: String!
}

enum UserInfluencersOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserInfluencersPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserInfluencersSubscriptionPayload {
  mutation: MutationType!
  node: UserInfluencers
  updatedFields: [String!]
  previousValues: UserInfluencersPreviousValues
}

input UserInfluencersSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserInfluencersWhereInput
  AND: [UserInfluencersSubscriptionWhereInput!]
  OR: [UserInfluencersSubscriptionWhereInput!]
  NOT: [UserInfluencersSubscriptionWhereInput!]
}

input UserInfluencersUpdateInput {
  user: UserUpdateOneRequiredWithoutInfluencersInput
  influencers: InfluencerUpdateManyInput
}

input UserInfluencersUpdateOneWithoutUserInput {
  create: UserInfluencersCreateWithoutUserInput
  update: UserInfluencersUpdateWithoutUserDataInput
  upsert: UserInfluencersUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  connect: UserInfluencersWhereUniqueInput
}

input UserInfluencersUpdateWithoutUserDataInput {
  influencers: InfluencerUpdateManyInput
}

input UserInfluencersUpsertWithoutUserInput {
  update: UserInfluencersUpdateWithoutUserDataInput!
  create: UserInfluencersCreateWithoutUserInput!
}

input UserInfluencersWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  influencers_every: InfluencerWhereInput
  influencers_some: InfluencerWhereInput
  influencers_none: InfluencerWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserInfluencersWhereInput!]
  OR: [UserInfluencersWhereInput!]
  NOT: [UserInfluencersWhereInput!]
}

input UserInfluencersWhereUniqueInput {
  id: ID
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  name_ASC
  name_DESC
  countryCode_ASC
  countryCode_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  displayName_ASC
  displayName_DESC
  isPrivate_ASC
  isPrivate_DESC
  password_ASC
  password_DESC
  emailValidationToken_ASC
  emailValidationToken_DESC
  emailValidationTokenExpiry_ASC
  emailValidationTokenExpiry_DESC
  emailValidated_ASC
  emailValidated_DESC
  emailValidationDate_ASC
  emailValidationDate_DESC
  resetToken_ASC
  resetToken_DESC
  resetTokenExpiry_ASC
  resetTokenExpiry_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPhoto {
  id: ID!
  user: User!
  photo: Photo!
  isProfile: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserPhotoConnection {
  pageInfo: PageInfo!
  edges: [UserPhotoEdge]!
  aggregate: AggregateUserPhoto!
}

input UserPhotoCreateInput {
  id: ID
  user: UserCreateOneWithoutPhotosInput!
  photo: PhotoCreateOneInput!
  isProfile: Boolean
}

input UserPhotoCreateManyWithoutUserInput {
  create: [UserPhotoCreateWithoutUserInput!]
  connect: [UserPhotoWhereUniqueInput!]
}

input UserPhotoCreateWithoutUserInput {
  id: ID
  photo: PhotoCreateOneInput!
  isProfile: Boolean
}

type UserPhotoEdge {
  node: UserPhoto!
  cursor: String!
}

enum UserPhotoOrderByInput {
  id_ASC
  id_DESC
  isProfile_ASC
  isProfile_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPhotoPreviousValues {
  id: ID!
  isProfile: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input UserPhotoScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  isProfile: Boolean
  isProfile_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserPhotoScalarWhereInput!]
  OR: [UserPhotoScalarWhereInput!]
  NOT: [UserPhotoScalarWhereInput!]
}

type UserPhotoSubscriptionPayload {
  mutation: MutationType!
  node: UserPhoto
  updatedFields: [String!]
  previousValues: UserPhotoPreviousValues
}

input UserPhotoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserPhotoWhereInput
  AND: [UserPhotoSubscriptionWhereInput!]
  OR: [UserPhotoSubscriptionWhereInput!]
  NOT: [UserPhotoSubscriptionWhereInput!]
}

input UserPhotoUpdateInput {
  user: UserUpdateOneRequiredWithoutPhotosInput
  photo: PhotoUpdateOneRequiredInput
  isProfile: Boolean
}

input UserPhotoUpdateManyDataInput {
  isProfile: Boolean
}

input UserPhotoUpdateManyMutationInput {
  isProfile: Boolean
}

input UserPhotoUpdateManyWithoutUserInput {
  create: [UserPhotoCreateWithoutUserInput!]
  delete: [UserPhotoWhereUniqueInput!]
  connect: [UserPhotoWhereUniqueInput!]
  set: [UserPhotoWhereUniqueInput!]
  disconnect: [UserPhotoWhereUniqueInput!]
  update: [UserPhotoUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [UserPhotoUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [UserPhotoScalarWhereInput!]
  updateMany: [UserPhotoUpdateManyWithWhereNestedInput!]
}

input UserPhotoUpdateManyWithWhereNestedInput {
  where: UserPhotoScalarWhereInput!
  data: UserPhotoUpdateManyDataInput!
}

input UserPhotoUpdateWithoutUserDataInput {
  photo: PhotoUpdateOneRequiredInput
  isProfile: Boolean
}

input UserPhotoUpdateWithWhereUniqueWithoutUserInput {
  where: UserPhotoWhereUniqueInput!
  data: UserPhotoUpdateWithoutUserDataInput!
}

input UserPhotoUpsertWithWhereUniqueWithoutUserInput {
  where: UserPhotoWhereUniqueInput!
  update: UserPhotoUpdateWithoutUserDataInput!
  create: UserPhotoCreateWithoutUserInput!
}

input UserPhotoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  photo: PhotoWhereInput
  isProfile: Boolean
  isProfile_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserPhotoWhereInput!]
  OR: [UserPhotoWhereInput!]
  NOT: [UserPhotoWhereInput!]
}

input UserPhotoWhereUniqueInput {
  id: ID
}

type UserPreviousValues {
  id: ID!
  email: String!
  name: String!
  countryCode: String
  phoneNumber: String
  displayName: String!
  isPrivate: Boolean!
  password: String!
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean!
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserRole {
  id: ID!
  name: String!
  description: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserRoleConnection {
  pageInfo: PageInfo!
  edges: [UserRoleEdge]!
  aggregate: AggregateUserRole!
}

input UserRoleCreateInput {
  id: ID
  name: String!
  description: String!
}

input UserRoleCreateManyInput {
  create: [UserRoleCreateInput!]
  connect: [UserRoleWhereUniqueInput!]
}

input UserRoleCreateOneInput {
  create: UserRoleCreateInput
  connect: UserRoleWhereUniqueInput
}

type UserRoleEdge {
  node: UserRole!
  cursor: String!
}

enum UserRoleOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserRolePreviousValues {
  id: ID!
  name: String!
  description: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input UserRoleScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserRoleScalarWhereInput!]
  OR: [UserRoleScalarWhereInput!]
  NOT: [UserRoleScalarWhereInput!]
}

type UserRoleSubscriptionPayload {
  mutation: MutationType!
  node: UserRole
  updatedFields: [String!]
  previousValues: UserRolePreviousValues
}

input UserRoleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserRoleWhereInput
  AND: [UserRoleSubscriptionWhereInput!]
  OR: [UserRoleSubscriptionWhereInput!]
  NOT: [UserRoleSubscriptionWhereInput!]
}

input UserRoleUpdateDataInput {
  name: String
  description: String
}

input UserRoleUpdateInput {
  name: String
  description: String
}

input UserRoleUpdateManyDataInput {
  name: String
  description: String
}

input UserRoleUpdateManyInput {
  create: [UserRoleCreateInput!]
  update: [UserRoleUpdateWithWhereUniqueNestedInput!]
  upsert: [UserRoleUpsertWithWhereUniqueNestedInput!]
  delete: [UserRoleWhereUniqueInput!]
  connect: [UserRoleWhereUniqueInput!]
  set: [UserRoleWhereUniqueInput!]
  disconnect: [UserRoleWhereUniqueInput!]
  deleteMany: [UserRoleScalarWhereInput!]
  updateMany: [UserRoleUpdateManyWithWhereNestedInput!]
}

input UserRoleUpdateManyMutationInput {
  name: String
  description: String
}

input UserRoleUpdateManyWithWhereNestedInput {
  where: UserRoleScalarWhereInput!
  data: UserRoleUpdateManyDataInput!
}

input UserRoleUpdateOneRequiredInput {
  create: UserRoleCreateInput
  update: UserRoleUpdateDataInput
  upsert: UserRoleUpsertNestedInput
  connect: UserRoleWhereUniqueInput
}

input UserRoleUpdateWithWhereUniqueNestedInput {
  where: UserRoleWhereUniqueInput!
  data: UserRoleUpdateDataInput!
}

input UserRoleUpsertNestedInput {
  update: UserRoleUpdateDataInput!
  create: UserRoleCreateInput!
}

input UserRoleUpsertWithWhereUniqueNestedInput {
  where: UserRoleWhereUniqueInput!
  update: UserRoleUpdateDataInput!
  create: UserRoleCreateInput!
}

input UserRoleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserRoleWhereInput!]
  OR: [UserRoleWhereInput!]
  NOT: [UserRoleWhereInput!]
}

input UserRoleWhereUniqueInput {
  id: ID
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  countryCode: String
  countryCode_not: String
  countryCode_in: [String!]
  countryCode_not_in: [String!]
  countryCode_lt: String
  countryCode_lte: String
  countryCode_gt: String
  countryCode_gte: String
  countryCode_contains: String
  countryCode_not_contains: String
  countryCode_starts_with: String
  countryCode_not_starts_with: String
  countryCode_ends_with: String
  countryCode_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  displayName: String
  displayName_not: String
  displayName_in: [String!]
  displayName_not_in: [String!]
  displayName_lt: String
  displayName_lte: String
  displayName_gt: String
  displayName_gte: String
  displayName_contains: String
  displayName_not_contains: String
  displayName_starts_with: String
  displayName_not_starts_with: String
  displayName_ends_with: String
  displayName_not_ends_with: String
  isPrivate: Boolean
  isPrivate_not: Boolean
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  emailValidationToken: String
  emailValidationToken_not: String
  emailValidationToken_in: [String!]
  emailValidationToken_not_in: [String!]
  emailValidationToken_lt: String
  emailValidationToken_lte: String
  emailValidationToken_gt: String
  emailValidationToken_gte: String
  emailValidationToken_contains: String
  emailValidationToken_not_contains: String
  emailValidationToken_starts_with: String
  emailValidationToken_not_starts_with: String
  emailValidationToken_ends_with: String
  emailValidationToken_not_ends_with: String
  emailValidationTokenExpiry: Float
  emailValidationTokenExpiry_not: Float
  emailValidationTokenExpiry_in: [Float!]
  emailValidationTokenExpiry_not_in: [Float!]
  emailValidationTokenExpiry_lt: Float
  emailValidationTokenExpiry_lte: Float
  emailValidationTokenExpiry_gt: Float
  emailValidationTokenExpiry_gte: Float
  emailValidated: Boolean
  emailValidated_not: Boolean
  emailValidationDate: DateTime
  emailValidationDate_not: DateTime
  emailValidationDate_in: [DateTime!]
  emailValidationDate_not_in: [DateTime!]
  emailValidationDate_lt: DateTime
  emailValidationDate_lte: DateTime
  emailValidationDate_gt: DateTime
  emailValidationDate_gte: DateTime
  resetToken: String
  resetToken_not: String
  resetToken_in: [String!]
  resetToken_not_in: [String!]
  resetToken_lt: String
  resetToken_lte: String
  resetToken_gt: String
  resetToken_gte: String
  resetToken_contains: String
  resetToken_not_contains: String
  resetToken_starts_with: String
  resetToken_not_starts_with: String
  resetToken_ends_with: String
  resetToken_not_ends_with: String
  resetTokenExpiry: Float
  resetTokenExpiry_not: Float
  resetTokenExpiry_in: [Float!]
  resetTokenExpiry_not_in: [Float!]
  resetTokenExpiry_lt: Float
  resetTokenExpiry_lte: Float
  resetTokenExpiry_gt: Float
  resetTokenExpiry_gte: Float
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserStatus {
  id: ID!
  status: Status
  currentStatus: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserStatusConnection {
  pageInfo: PageInfo!
  edges: [UserStatusEdge]!
  aggregate: AggregateUserStatus!
}

input UserStatusCreateInput {
  id: ID
  status: StatusCreateOneWithoutAuthorInput
  currentStatus: Boolean
}

input UserStatusCreateManyInput {
  create: [UserStatusCreateInput!]
  connect: [UserStatusWhereUniqueInput!]
}

input UserStatusCreateOneWithoutStatusInput {
  create: UserStatusCreateWithoutStatusInput
  connect: UserStatusWhereUniqueInput
}

input UserStatusCreateWithoutStatusInput {
  id: ID
  currentStatus: Boolean
}

type UserStatusEdge {
  node: UserStatus!
  cursor: String!
}

enum UserStatusOrderByInput {
  id_ASC
  id_DESC
  currentStatus_ASC
  currentStatus_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserStatusPreviousValues {
  id: ID!
  currentStatus: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input UserStatusScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  currentStatus: Boolean
  currentStatus_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserStatusScalarWhereInput!]
  OR: [UserStatusScalarWhereInput!]
  NOT: [UserStatusScalarWhereInput!]
}

type UserStatusSubscriptionPayload {
  mutation: MutationType!
  node: UserStatus
  updatedFields: [String!]
  previousValues: UserStatusPreviousValues
}

input UserStatusSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserStatusWhereInput
  AND: [UserStatusSubscriptionWhereInput!]
  OR: [UserStatusSubscriptionWhereInput!]
  NOT: [UserStatusSubscriptionWhereInput!]
}

input UserStatusUpdateDataInput {
  status: StatusUpdateOneWithoutAuthorInput
  currentStatus: Boolean
}

input UserStatusUpdateInput {
  status: StatusUpdateOneWithoutAuthorInput
  currentStatus: Boolean
}

input UserStatusUpdateManyDataInput {
  currentStatus: Boolean
}

input UserStatusUpdateManyInput {
  create: [UserStatusCreateInput!]
  update: [UserStatusUpdateWithWhereUniqueNestedInput!]
  upsert: [UserStatusUpsertWithWhereUniqueNestedInput!]
  delete: [UserStatusWhereUniqueInput!]
  connect: [UserStatusWhereUniqueInput!]
  set: [UserStatusWhereUniqueInput!]
  disconnect: [UserStatusWhereUniqueInput!]
  deleteMany: [UserStatusScalarWhereInput!]
  updateMany: [UserStatusUpdateManyWithWhereNestedInput!]
}

input UserStatusUpdateManyMutationInput {
  currentStatus: Boolean
}

input UserStatusUpdateManyWithWhereNestedInput {
  where: UserStatusScalarWhereInput!
  data: UserStatusUpdateManyDataInput!
}

input UserStatusUpdateOneWithoutStatusInput {
  create: UserStatusCreateWithoutStatusInput
  update: UserStatusUpdateWithoutStatusDataInput
  upsert: UserStatusUpsertWithoutStatusInput
  delete: Boolean
  disconnect: Boolean
  connect: UserStatusWhereUniqueInput
}

input UserStatusUpdateWithoutStatusDataInput {
  currentStatus: Boolean
}

input UserStatusUpdateWithWhereUniqueNestedInput {
  where: UserStatusWhereUniqueInput!
  data: UserStatusUpdateDataInput!
}

input UserStatusUpsertWithoutStatusInput {
  update: UserStatusUpdateWithoutStatusDataInput!
  create: UserStatusCreateWithoutStatusInput!
}

input UserStatusUpsertWithWhereUniqueNestedInput {
  where: UserStatusWhereUniqueInput!
  update: UserStatusUpdateDataInput!
  create: UserStatusCreateInput!
}

input UserStatusWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: StatusWhereInput
  currentStatus: Boolean
  currentStatus_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserStatusWhereInput!]
  OR: [UserStatusWhereInput!]
  NOT: [UserStatusWhereInput!]
}

input UserStatusWhereUniqueInput {
  id: ID
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  email: String
  name: String
  countryCode: String
  phoneNumber: String
  favoriteTeam: TeamUpdateOneInput
  country: CountryUpdateOneInput
  displayName: String
  isPrivate: Boolean
  password: String
  photos: UserPhotoUpdateManyWithoutUserInput
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions: FandemSubscriptionUpdateManyInput
  userRoles: UserRoleUpdateManyInput
  status: UserStatusUpdateManyInput
  followers: UserFollowersUpdateOneWithoutUserInput
  influencers: UserInfluencersUpdateOneWithoutUserInput
}

input UserUpdateInput {
  email: String
  name: String
  countryCode: String
  phoneNumber: String
  favoriteTeam: TeamUpdateOneInput
  country: CountryUpdateOneInput
  displayName: String
  isPrivate: Boolean
  password: String
  photos: UserPhotoUpdateManyWithoutUserInput
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions: FandemSubscriptionUpdateManyInput
  userRoles: UserRoleUpdateManyInput
  status: UserStatusUpdateManyInput
  followers: UserFollowersUpdateOneWithoutUserInput
  influencers: UserInfluencersUpdateOneWithoutUserInput
}

input UserUpdateManyDataInput {
  email: String
  name: String
  countryCode: String
  phoneNumber: String
  displayName: String
  isPrivate: Boolean
  password: String
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
}

input UserUpdateManyInput {
  create: [UserCreateInput!]
  update: [UserUpdateWithWhereUniqueNestedInput!]
  upsert: [UserUpsertWithWhereUniqueNestedInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyMutationInput {
  email: String
  name: String
  countryCode: String
  phoneNumber: String
  displayName: String
  isPrivate: Boolean
  password: String
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutFollowersInput {
  create: UserCreateWithoutFollowersInput
  update: UserUpdateWithoutFollowersDataInput
  upsert: UserUpsertWithoutFollowersInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutInfluencersInput {
  create: UserCreateWithoutInfluencersInput
  update: UserUpdateWithoutInfluencersDataInput
  upsert: UserUpsertWithoutInfluencersInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPhotosInput {
  create: UserCreateWithoutPhotosInput
  update: UserUpdateWithoutPhotosDataInput
  upsert: UserUpsertWithoutPhotosInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutFollowersDataInput {
  email: String
  name: String
  countryCode: String
  phoneNumber: String
  favoriteTeam: TeamUpdateOneInput
  country: CountryUpdateOneInput
  displayName: String
  isPrivate: Boolean
  password: String
  photos: UserPhotoUpdateManyWithoutUserInput
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions: FandemSubscriptionUpdateManyInput
  userRoles: UserRoleUpdateManyInput
  status: UserStatusUpdateManyInput
  influencers: UserInfluencersUpdateOneWithoutUserInput
}

input UserUpdateWithoutInfluencersDataInput {
  email: String
  name: String
  countryCode: String
  phoneNumber: String
  favoriteTeam: TeamUpdateOneInput
  country: CountryUpdateOneInput
  displayName: String
  isPrivate: Boolean
  password: String
  photos: UserPhotoUpdateManyWithoutUserInput
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions: FandemSubscriptionUpdateManyInput
  userRoles: UserRoleUpdateManyInput
  status: UserStatusUpdateManyInput
  followers: UserFollowersUpdateOneWithoutUserInput
}

input UserUpdateWithoutPhotosDataInput {
  email: String
  name: String
  countryCode: String
  phoneNumber: String
  favoriteTeam: TeamUpdateOneInput
  country: CountryUpdateOneInput
  displayName: String
  isPrivate: Boolean
  password: String
  emailValidationToken: String
  emailValidationTokenExpiry: Float
  emailValidated: Boolean
  emailValidationDate: DateTime
  resetToken: String
  resetTokenExpiry: Float
  subscriptions: FandemSubscriptionUpdateManyInput
  userRoles: UserRoleUpdateManyInput
  status: UserStatusUpdateManyInput
  followers: UserFollowersUpdateOneWithoutUserInput
  influencers: UserInfluencersUpdateOneWithoutUserInput
}

input UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  data: UserUpdateDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutFollowersInput {
  update: UserUpdateWithoutFollowersDataInput!
  create: UserCreateWithoutFollowersInput!
}

input UserUpsertWithoutInfluencersInput {
  update: UserUpdateWithoutInfluencersDataInput!
  create: UserCreateWithoutInfluencersInput!
}

input UserUpsertWithoutPhotosInput {
  update: UserUpdateWithoutPhotosDataInput!
  create: UserCreateWithoutPhotosInput!
}

input UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  countryCode: String
  countryCode_not: String
  countryCode_in: [String!]
  countryCode_not_in: [String!]
  countryCode_lt: String
  countryCode_lte: String
  countryCode_gt: String
  countryCode_gte: String
  countryCode_contains: String
  countryCode_not_contains: String
  countryCode_starts_with: String
  countryCode_not_starts_with: String
  countryCode_ends_with: String
  countryCode_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  favoriteTeam: TeamWhereInput
  country: CountryWhereInput
  displayName: String
  displayName_not: String
  displayName_in: [String!]
  displayName_not_in: [String!]
  displayName_lt: String
  displayName_lte: String
  displayName_gt: String
  displayName_gte: String
  displayName_contains: String
  displayName_not_contains: String
  displayName_starts_with: String
  displayName_not_starts_with: String
  displayName_ends_with: String
  displayName_not_ends_with: String
  isPrivate: Boolean
  isPrivate_not: Boolean
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  photos_every: UserPhotoWhereInput
  photos_some: UserPhotoWhereInput
  photos_none: UserPhotoWhereInput
  emailValidationToken: String
  emailValidationToken_not: String
  emailValidationToken_in: [String!]
  emailValidationToken_not_in: [String!]
  emailValidationToken_lt: String
  emailValidationToken_lte: String
  emailValidationToken_gt: String
  emailValidationToken_gte: String
  emailValidationToken_contains: String
  emailValidationToken_not_contains: String
  emailValidationToken_starts_with: String
  emailValidationToken_not_starts_with: String
  emailValidationToken_ends_with: String
  emailValidationToken_not_ends_with: String
  emailValidationTokenExpiry: Float
  emailValidationTokenExpiry_not: Float
  emailValidationTokenExpiry_in: [Float!]
  emailValidationTokenExpiry_not_in: [Float!]
  emailValidationTokenExpiry_lt: Float
  emailValidationTokenExpiry_lte: Float
  emailValidationTokenExpiry_gt: Float
  emailValidationTokenExpiry_gte: Float
  emailValidated: Boolean
  emailValidated_not: Boolean
  emailValidationDate: DateTime
  emailValidationDate_not: DateTime
  emailValidationDate_in: [DateTime!]
  emailValidationDate_not_in: [DateTime!]
  emailValidationDate_lt: DateTime
  emailValidationDate_lte: DateTime
  emailValidationDate_gt: DateTime
  emailValidationDate_gte: DateTime
  resetToken: String
  resetToken_not: String
  resetToken_in: [String!]
  resetToken_not_in: [String!]
  resetToken_lt: String
  resetToken_lte: String
  resetToken_gt: String
  resetToken_gte: String
  resetToken_contains: String
  resetToken_not_contains: String
  resetToken_starts_with: String
  resetToken_not_starts_with: String
  resetToken_ends_with: String
  resetToken_not_ends_with: String
  resetTokenExpiry: Float
  resetTokenExpiry_not: Float
  resetTokenExpiry_in: [Float!]
  resetTokenExpiry_not_in: [Float!]
  resetTokenExpiry_lt: Float
  resetTokenExpiry_lte: Float
  resetTokenExpiry_gt: Float
  resetTokenExpiry_gte: Float
  subscriptions_every: FandemSubscriptionWhereInput
  subscriptions_some: FandemSubscriptionWhereInput
  subscriptions_none: FandemSubscriptionWhereInput
  userRoles_every: UserRoleWhereInput
  userRoles_some: UserRoleWhereInput
  userRoles_none: UserRoleWhereInput
  status_every: UserStatusWhereInput
  status_some: UserStatusWhereInput
  status_none: UserStatusWhereInput
  followers: UserFollowersWhereInput
  influencers: UserInfluencersWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
  displayName: String
}
`
      }
    