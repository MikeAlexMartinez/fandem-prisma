// Code generated by Prisma (prisma@1.34.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  activeSubscriptions: (
    where?: ActiveSubscriptionsWhereInput
  ) => Promise<boolean>;
  awayTeamFixture: (where?: AwayTeamFixtureWhereInput) => Promise<boolean>;
  country: (where?: CountryWhereInput) => Promise<boolean>;
  fandemSubscription: (
    where?: FandemSubscriptionWhereInput
  ) => Promise<boolean>;
  fixture: (where?: FixtureWhereInput) => Promise<boolean>;
  follower: (where?: FollowerWhereInput) => Promise<boolean>;
  gameweek: (where?: GameweekWhereInput) => Promise<boolean>;
  homeTeamFixture: (where?: HomeTeamFixtureWhereInput) => Promise<boolean>;
  influencer: (where?: InfluencerWhereInput) => Promise<boolean>;
  photo: (where?: PhotoWhereInput) => Promise<boolean>;
  season: (where?: SeasonWhereInput) => Promise<boolean>;
  status: (where?: StatusWhereInput) => Promise<boolean>;
  team: (where?: TeamWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userAssignedRole: (where?: UserAssignedRoleWhereInput) => Promise<boolean>;
  userFollowers: (where?: UserFollowersWhereInput) => Promise<boolean>;
  userInfluencers: (where?: UserInfluencersWhereInput) => Promise<boolean>;
  userPhoto: (where?: UserPhotoWhereInput) => Promise<boolean>;
  userRole: (where?: UserRoleWhereInput) => Promise<boolean>;
  userStatus: (where?: UserStatusWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  activeSubscriptions: (
    where: ActiveSubscriptionsWhereUniqueInput
  ) => ActiveSubscriptionsNullablePromise;
  activeSubscriptionses: (args?: {
    where?: ActiveSubscriptionsWhereInput;
    orderBy?: ActiveSubscriptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ActiveSubscriptions>;
  activeSubscriptionsesConnection: (args?: {
    where?: ActiveSubscriptionsWhereInput;
    orderBy?: ActiveSubscriptionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ActiveSubscriptionsConnectionPromise;
  awayTeamFixture: (
    where: AwayTeamFixtureWhereUniqueInput
  ) => AwayTeamFixtureNullablePromise;
  awayTeamFixtures: (args?: {
    where?: AwayTeamFixtureWhereInput;
    orderBy?: AwayTeamFixtureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AwayTeamFixture>;
  awayTeamFixturesConnection: (args?: {
    where?: AwayTeamFixtureWhereInput;
    orderBy?: AwayTeamFixtureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AwayTeamFixtureConnectionPromise;
  country: (where: CountryWhereUniqueInput) => CountryNullablePromise;
  countries: (args?: {
    where?: CountryWhereInput;
    orderBy?: CountryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Country>;
  countriesConnection: (args?: {
    where?: CountryWhereInput;
    orderBy?: CountryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CountryConnectionPromise;
  fandemSubscription: (
    where: FandemSubscriptionWhereUniqueInput
  ) => FandemSubscriptionNullablePromise;
  fandemSubscriptions: (args?: {
    where?: FandemSubscriptionWhereInput;
    orderBy?: FandemSubscriptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<FandemSubscription>;
  fandemSubscriptionsConnection: (args?: {
    where?: FandemSubscriptionWhereInput;
    orderBy?: FandemSubscriptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FandemSubscriptionConnectionPromise;
  fixture: (where: FixtureWhereUniqueInput) => FixtureNullablePromise;
  fixtures: (args?: {
    where?: FixtureWhereInput;
    orderBy?: FixtureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Fixture>;
  fixturesConnection: (args?: {
    where?: FixtureWhereInput;
    orderBy?: FixtureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FixtureConnectionPromise;
  follower: (where: FollowerWhereUniqueInput) => FollowerNullablePromise;
  followers: (args?: {
    where?: FollowerWhereInput;
    orderBy?: FollowerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Follower>;
  followersConnection: (args?: {
    where?: FollowerWhereInput;
    orderBy?: FollowerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FollowerConnectionPromise;
  gameweek: (where: GameweekWhereUniqueInput) => GameweekNullablePromise;
  gameweeks: (args?: {
    where?: GameweekWhereInput;
    orderBy?: GameweekOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Gameweek>;
  gameweeksConnection: (args?: {
    where?: GameweekWhereInput;
    orderBy?: GameweekOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GameweekConnectionPromise;
  homeTeamFixture: (
    where: HomeTeamFixtureWhereUniqueInput
  ) => HomeTeamFixtureNullablePromise;
  homeTeamFixtures: (args?: {
    where?: HomeTeamFixtureWhereInput;
    orderBy?: HomeTeamFixtureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<HomeTeamFixture>;
  homeTeamFixturesConnection: (args?: {
    where?: HomeTeamFixtureWhereInput;
    orderBy?: HomeTeamFixtureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HomeTeamFixtureConnectionPromise;
  influencer: (where: InfluencerWhereUniqueInput) => InfluencerNullablePromise;
  influencers: (args?: {
    where?: InfluencerWhereInput;
    orderBy?: InfluencerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Influencer>;
  influencersConnection: (args?: {
    where?: InfluencerWhereInput;
    orderBy?: InfluencerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InfluencerConnectionPromise;
  photo: (where: PhotoWhereUniqueInput) => PhotoNullablePromise;
  photos: (args?: {
    where?: PhotoWhereInput;
    orderBy?: PhotoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Photo>;
  photosConnection: (args?: {
    where?: PhotoWhereInput;
    orderBy?: PhotoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PhotoConnectionPromise;
  season: (where: SeasonWhereUniqueInput) => SeasonNullablePromise;
  seasons: (args?: {
    where?: SeasonWhereInput;
    orderBy?: SeasonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Season>;
  seasonsConnection: (args?: {
    where?: SeasonWhereInput;
    orderBy?: SeasonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SeasonConnectionPromise;
  status: (where: StatusWhereUniqueInput) => StatusNullablePromise;
  statuses: (args?: {
    where?: StatusWhereInput;
    orderBy?: StatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Status>;
  statusesConnection: (args?: {
    where?: StatusWhereInput;
    orderBy?: StatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StatusConnectionPromise;
  team: (where: TeamWhereUniqueInput) => TeamNullablePromise;
  teams: (args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Team>;
  teamsConnection: (args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TeamConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  userAssignedRole: (
    where: UserAssignedRoleWhereUniqueInput
  ) => UserAssignedRoleNullablePromise;
  userAssignedRoles: (args?: {
    where?: UserAssignedRoleWhereInput;
    orderBy?: UserAssignedRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserAssignedRole>;
  userAssignedRolesConnection: (args?: {
    where?: UserAssignedRoleWhereInput;
    orderBy?: UserAssignedRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserAssignedRoleConnectionPromise;
  userFollowers: (
    where: UserFollowersWhereUniqueInput
  ) => UserFollowersNullablePromise;
  userFollowerses: (args?: {
    where?: UserFollowersWhereInput;
    orderBy?: UserFollowersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserFollowers>;
  userFollowersesConnection: (args?: {
    where?: UserFollowersWhereInput;
    orderBy?: UserFollowersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserFollowersConnectionPromise;
  userInfluencers: (
    where: UserInfluencersWhereUniqueInput
  ) => UserInfluencersNullablePromise;
  userInfluencerses: (args?: {
    where?: UserInfluencersWhereInput;
    orderBy?: UserInfluencersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserInfluencers>;
  userInfluencersesConnection: (args?: {
    where?: UserInfluencersWhereInput;
    orderBy?: UserInfluencersOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserInfluencersConnectionPromise;
  userPhoto: (where: UserPhotoWhereUniqueInput) => UserPhotoNullablePromise;
  userPhotos: (args?: {
    where?: UserPhotoWhereInput;
    orderBy?: UserPhotoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserPhoto>;
  userPhotosConnection: (args?: {
    where?: UserPhotoWhereInput;
    orderBy?: UserPhotoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserPhotoConnectionPromise;
  userRole: (where: UserRoleWhereUniqueInput) => UserRoleNullablePromise;
  userRoles: (args?: {
    where?: UserRoleWhereInput;
    orderBy?: UserRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserRole>;
  userRolesConnection: (args?: {
    where?: UserRoleWhereInput;
    orderBy?: UserRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserRoleConnectionPromise;
  userStatus: (where: UserStatusWhereUniqueInput) => UserStatusNullablePromise;
  userStatuses: (args?: {
    where?: UserStatusWhereInput;
    orderBy?: UserStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserStatus>;
  userStatusesConnection: (args?: {
    where?: UserStatusWhereInput;
    orderBy?: UserStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserStatusConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createActiveSubscriptions: (
    data: ActiveSubscriptionsCreateInput
  ) => ActiveSubscriptionsPromise;
  updateActiveSubscriptions: (args: {
    data: ActiveSubscriptionsUpdateInput;
    where: ActiveSubscriptionsWhereUniqueInput;
  }) => ActiveSubscriptionsPromise;
  updateManyActiveSubscriptionses: (args: {
    data: ActiveSubscriptionsUpdateManyMutationInput;
    where?: ActiveSubscriptionsWhereInput;
  }) => BatchPayloadPromise;
  upsertActiveSubscriptions: (args: {
    where: ActiveSubscriptionsWhereUniqueInput;
    create: ActiveSubscriptionsCreateInput;
    update: ActiveSubscriptionsUpdateInput;
  }) => ActiveSubscriptionsPromise;
  deleteActiveSubscriptions: (
    where: ActiveSubscriptionsWhereUniqueInput
  ) => ActiveSubscriptionsPromise;
  deleteManyActiveSubscriptionses: (
    where?: ActiveSubscriptionsWhereInput
  ) => BatchPayloadPromise;
  createAwayTeamFixture: (
    data: AwayTeamFixtureCreateInput
  ) => AwayTeamFixturePromise;
  updateAwayTeamFixture: (args: {
    data: AwayTeamFixtureUpdateInput;
    where: AwayTeamFixtureWhereUniqueInput;
  }) => AwayTeamFixturePromise;
  upsertAwayTeamFixture: (args: {
    where: AwayTeamFixtureWhereUniqueInput;
    create: AwayTeamFixtureCreateInput;
    update: AwayTeamFixtureUpdateInput;
  }) => AwayTeamFixturePromise;
  deleteAwayTeamFixture: (
    where: AwayTeamFixtureWhereUniqueInput
  ) => AwayTeamFixturePromise;
  deleteManyAwayTeamFixtures: (
    where?: AwayTeamFixtureWhereInput
  ) => BatchPayloadPromise;
  createCountry: (data: CountryCreateInput) => CountryPromise;
  updateCountry: (args: {
    data: CountryUpdateInput;
    where: CountryWhereUniqueInput;
  }) => CountryPromise;
  updateManyCountries: (args: {
    data: CountryUpdateManyMutationInput;
    where?: CountryWhereInput;
  }) => BatchPayloadPromise;
  upsertCountry: (args: {
    where: CountryWhereUniqueInput;
    create: CountryCreateInput;
    update: CountryUpdateInput;
  }) => CountryPromise;
  deleteCountry: (where: CountryWhereUniqueInput) => CountryPromise;
  deleteManyCountries: (where?: CountryWhereInput) => BatchPayloadPromise;
  createFandemSubscription: (
    data: FandemSubscriptionCreateInput
  ) => FandemSubscriptionPromise;
  updateFandemSubscription: (args: {
    data: FandemSubscriptionUpdateInput;
    where: FandemSubscriptionWhereUniqueInput;
  }) => FandemSubscriptionPromise;
  updateManyFandemSubscriptions: (args: {
    data: FandemSubscriptionUpdateManyMutationInput;
    where?: FandemSubscriptionWhereInput;
  }) => BatchPayloadPromise;
  upsertFandemSubscription: (args: {
    where: FandemSubscriptionWhereUniqueInput;
    create: FandemSubscriptionCreateInput;
    update: FandemSubscriptionUpdateInput;
  }) => FandemSubscriptionPromise;
  deleteFandemSubscription: (
    where: FandemSubscriptionWhereUniqueInput
  ) => FandemSubscriptionPromise;
  deleteManyFandemSubscriptions: (
    where?: FandemSubscriptionWhereInput
  ) => BatchPayloadPromise;
  createFixture: (data: FixtureCreateInput) => FixturePromise;
  updateFixture: (args: {
    data: FixtureUpdateInput;
    where: FixtureWhereUniqueInput;
  }) => FixturePromise;
  updateManyFixtures: (args: {
    data: FixtureUpdateManyMutationInput;
    where?: FixtureWhereInput;
  }) => BatchPayloadPromise;
  upsertFixture: (args: {
    where: FixtureWhereUniqueInput;
    create: FixtureCreateInput;
    update: FixtureUpdateInput;
  }) => FixturePromise;
  deleteFixture: (where: FixtureWhereUniqueInput) => FixturePromise;
  deleteManyFixtures: (where?: FixtureWhereInput) => BatchPayloadPromise;
  createFollower: (data: FollowerCreateInput) => FollowerPromise;
  updateFollower: (args: {
    data: FollowerUpdateInput;
    where: FollowerWhereUniqueInput;
  }) => FollowerPromise;
  updateManyFollowers: (args: {
    data: FollowerUpdateManyMutationInput;
    where?: FollowerWhereInput;
  }) => BatchPayloadPromise;
  upsertFollower: (args: {
    where: FollowerWhereUniqueInput;
    create: FollowerCreateInput;
    update: FollowerUpdateInput;
  }) => FollowerPromise;
  deleteFollower: (where: FollowerWhereUniqueInput) => FollowerPromise;
  deleteManyFollowers: (where?: FollowerWhereInput) => BatchPayloadPromise;
  createGameweek: (data: GameweekCreateInput) => GameweekPromise;
  updateGameweek: (args: {
    data: GameweekUpdateInput;
    where: GameweekWhereUniqueInput;
  }) => GameweekPromise;
  updateManyGameweeks: (args: {
    data: GameweekUpdateManyMutationInput;
    where?: GameweekWhereInput;
  }) => BatchPayloadPromise;
  upsertGameweek: (args: {
    where: GameweekWhereUniqueInput;
    create: GameweekCreateInput;
    update: GameweekUpdateInput;
  }) => GameweekPromise;
  deleteGameweek: (where: GameweekWhereUniqueInput) => GameweekPromise;
  deleteManyGameweeks: (where?: GameweekWhereInput) => BatchPayloadPromise;
  createHomeTeamFixture: (
    data: HomeTeamFixtureCreateInput
  ) => HomeTeamFixturePromise;
  updateHomeTeamFixture: (args: {
    data: HomeTeamFixtureUpdateInput;
    where: HomeTeamFixtureWhereUniqueInput;
  }) => HomeTeamFixturePromise;
  upsertHomeTeamFixture: (args: {
    where: HomeTeamFixtureWhereUniqueInput;
    create: HomeTeamFixtureCreateInput;
    update: HomeTeamFixtureUpdateInput;
  }) => HomeTeamFixturePromise;
  deleteHomeTeamFixture: (
    where: HomeTeamFixtureWhereUniqueInput
  ) => HomeTeamFixturePromise;
  deleteManyHomeTeamFixtures: (
    where?: HomeTeamFixtureWhereInput
  ) => BatchPayloadPromise;
  createInfluencer: (data: InfluencerCreateInput) => InfluencerPromise;
  updateInfluencer: (args: {
    data: InfluencerUpdateInput;
    where: InfluencerWhereUniqueInput;
  }) => InfluencerPromise;
  upsertInfluencer: (args: {
    where: InfluencerWhereUniqueInput;
    create: InfluencerCreateInput;
    update: InfluencerUpdateInput;
  }) => InfluencerPromise;
  deleteInfluencer: (where: InfluencerWhereUniqueInput) => InfluencerPromise;
  deleteManyInfluencers: (where?: InfluencerWhereInput) => BatchPayloadPromise;
  createPhoto: (data: PhotoCreateInput) => PhotoPromise;
  updatePhoto: (args: {
    data: PhotoUpdateInput;
    where: PhotoWhereUniqueInput;
  }) => PhotoPromise;
  updateManyPhotos: (args: {
    data: PhotoUpdateManyMutationInput;
    where?: PhotoWhereInput;
  }) => BatchPayloadPromise;
  upsertPhoto: (args: {
    where: PhotoWhereUniqueInput;
    create: PhotoCreateInput;
    update: PhotoUpdateInput;
  }) => PhotoPromise;
  deletePhoto: (where: PhotoWhereUniqueInput) => PhotoPromise;
  deleteManyPhotos: (where?: PhotoWhereInput) => BatchPayloadPromise;
  createSeason: (data: SeasonCreateInput) => SeasonPromise;
  updateSeason: (args: {
    data: SeasonUpdateInput;
    where: SeasonWhereUniqueInput;
  }) => SeasonPromise;
  updateManySeasons: (args: {
    data: SeasonUpdateManyMutationInput;
    where?: SeasonWhereInput;
  }) => BatchPayloadPromise;
  upsertSeason: (args: {
    where: SeasonWhereUniqueInput;
    create: SeasonCreateInput;
    update: SeasonUpdateInput;
  }) => SeasonPromise;
  deleteSeason: (where: SeasonWhereUniqueInput) => SeasonPromise;
  deleteManySeasons: (where?: SeasonWhereInput) => BatchPayloadPromise;
  createStatus: (data: StatusCreateInput) => StatusPromise;
  updateStatus: (args: {
    data: StatusUpdateInput;
    where: StatusWhereUniqueInput;
  }) => StatusPromise;
  updateManyStatuses: (args: {
    data: StatusUpdateManyMutationInput;
    where?: StatusWhereInput;
  }) => BatchPayloadPromise;
  upsertStatus: (args: {
    where: StatusWhereUniqueInput;
    create: StatusCreateInput;
    update: StatusUpdateInput;
  }) => StatusPromise;
  deleteStatus: (where: StatusWhereUniqueInput) => StatusPromise;
  deleteManyStatuses: (where?: StatusWhereInput) => BatchPayloadPromise;
  createTeam: (data: TeamCreateInput) => TeamPromise;
  updateTeam: (args: {
    data: TeamUpdateInput;
    where: TeamWhereUniqueInput;
  }) => TeamPromise;
  updateManyTeams: (args: {
    data: TeamUpdateManyMutationInput;
    where?: TeamWhereInput;
  }) => BatchPayloadPromise;
  upsertTeam: (args: {
    where: TeamWhereUniqueInput;
    create: TeamCreateInput;
    update: TeamUpdateInput;
  }) => TeamPromise;
  deleteTeam: (where: TeamWhereUniqueInput) => TeamPromise;
  deleteManyTeams: (where?: TeamWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserAssignedRole: (
    data: UserAssignedRoleCreateInput
  ) => UserAssignedRolePromise;
  updateUserAssignedRole: (args: {
    data: UserAssignedRoleUpdateInput;
    where: UserAssignedRoleWhereUniqueInput;
  }) => UserAssignedRolePromise;
  upsertUserAssignedRole: (args: {
    where: UserAssignedRoleWhereUniqueInput;
    create: UserAssignedRoleCreateInput;
    update: UserAssignedRoleUpdateInput;
  }) => UserAssignedRolePromise;
  deleteUserAssignedRole: (
    where: UserAssignedRoleWhereUniqueInput
  ) => UserAssignedRolePromise;
  deleteManyUserAssignedRoles: (
    where?: UserAssignedRoleWhereInput
  ) => BatchPayloadPromise;
  createUserFollowers: (data: UserFollowersCreateInput) => UserFollowersPromise;
  updateUserFollowers: (args: {
    data: UserFollowersUpdateInput;
    where: UserFollowersWhereUniqueInput;
  }) => UserFollowersPromise;
  upsertUserFollowers: (args: {
    where: UserFollowersWhereUniqueInput;
    create: UserFollowersCreateInput;
    update: UserFollowersUpdateInput;
  }) => UserFollowersPromise;
  deleteUserFollowers: (
    where: UserFollowersWhereUniqueInput
  ) => UserFollowersPromise;
  deleteManyUserFollowerses: (
    where?: UserFollowersWhereInput
  ) => BatchPayloadPromise;
  createUserInfluencers: (
    data: UserInfluencersCreateInput
  ) => UserInfluencersPromise;
  updateUserInfluencers: (args: {
    data: UserInfluencersUpdateInput;
    where: UserInfluencersWhereUniqueInput;
  }) => UserInfluencersPromise;
  upsertUserInfluencers: (args: {
    where: UserInfluencersWhereUniqueInput;
    create: UserInfluencersCreateInput;
    update: UserInfluencersUpdateInput;
  }) => UserInfluencersPromise;
  deleteUserInfluencers: (
    where: UserInfluencersWhereUniqueInput
  ) => UserInfluencersPromise;
  deleteManyUserInfluencerses: (
    where?: UserInfluencersWhereInput
  ) => BatchPayloadPromise;
  createUserPhoto: (data: UserPhotoCreateInput) => UserPhotoPromise;
  updateUserPhoto: (args: {
    data: UserPhotoUpdateInput;
    where: UserPhotoWhereUniqueInput;
  }) => UserPhotoPromise;
  updateManyUserPhotos: (args: {
    data: UserPhotoUpdateManyMutationInput;
    where?: UserPhotoWhereInput;
  }) => BatchPayloadPromise;
  upsertUserPhoto: (args: {
    where: UserPhotoWhereUniqueInput;
    create: UserPhotoCreateInput;
    update: UserPhotoUpdateInput;
  }) => UserPhotoPromise;
  deleteUserPhoto: (where: UserPhotoWhereUniqueInput) => UserPhotoPromise;
  deleteManyUserPhotos: (where?: UserPhotoWhereInput) => BatchPayloadPromise;
  createUserRole: (data: UserRoleCreateInput) => UserRolePromise;
  updateUserRole: (args: {
    data: UserRoleUpdateInput;
    where: UserRoleWhereUniqueInput;
  }) => UserRolePromise;
  updateManyUserRoles: (args: {
    data: UserRoleUpdateManyMutationInput;
    where?: UserRoleWhereInput;
  }) => BatchPayloadPromise;
  upsertUserRole: (args: {
    where: UserRoleWhereUniqueInput;
    create: UserRoleCreateInput;
    update: UserRoleUpdateInput;
  }) => UserRolePromise;
  deleteUserRole: (where: UserRoleWhereUniqueInput) => UserRolePromise;
  deleteManyUserRoles: (where?: UserRoleWhereInput) => BatchPayloadPromise;
  createUserStatus: (data: UserStatusCreateInput) => UserStatusPromise;
  updateUserStatus: (args: {
    data: UserStatusUpdateInput;
    where: UserStatusWhereUniqueInput;
  }) => UserStatusPromise;
  updateManyUserStatuses: (args: {
    data: UserStatusUpdateManyMutationInput;
    where?: UserStatusWhereInput;
  }) => BatchPayloadPromise;
  upsertUserStatus: (args: {
    where: UserStatusWhereUniqueInput;
    create: UserStatusCreateInput;
    update: UserStatusUpdateInput;
  }) => UserStatusPromise;
  deleteUserStatus: (where: UserStatusWhereUniqueInput) => UserStatusPromise;
  deleteManyUserStatuses: (where?: UserStatusWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  activeSubscriptions: (
    where?: ActiveSubscriptionsSubscriptionWhereInput
  ) => ActiveSubscriptionsSubscriptionPayloadSubscription;
  awayTeamFixture: (
    where?: AwayTeamFixtureSubscriptionWhereInput
  ) => AwayTeamFixtureSubscriptionPayloadSubscription;
  country: (
    where?: CountrySubscriptionWhereInput
  ) => CountrySubscriptionPayloadSubscription;
  fandemSubscription: (
    where?: FandemSubscriptionSubscriptionWhereInput
  ) => FandemSubscriptionSubscriptionPayloadSubscription;
  fixture: (
    where?: FixtureSubscriptionWhereInput
  ) => FixtureSubscriptionPayloadSubscription;
  follower: (
    where?: FollowerSubscriptionWhereInput
  ) => FollowerSubscriptionPayloadSubscription;
  gameweek: (
    where?: GameweekSubscriptionWhereInput
  ) => GameweekSubscriptionPayloadSubscription;
  homeTeamFixture: (
    where?: HomeTeamFixtureSubscriptionWhereInput
  ) => HomeTeamFixtureSubscriptionPayloadSubscription;
  influencer: (
    where?: InfluencerSubscriptionWhereInput
  ) => InfluencerSubscriptionPayloadSubscription;
  photo: (
    where?: PhotoSubscriptionWhereInput
  ) => PhotoSubscriptionPayloadSubscription;
  season: (
    where?: SeasonSubscriptionWhereInput
  ) => SeasonSubscriptionPayloadSubscription;
  status: (
    where?: StatusSubscriptionWhereInput
  ) => StatusSubscriptionPayloadSubscription;
  team: (
    where?: TeamSubscriptionWhereInput
  ) => TeamSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userAssignedRole: (
    where?: UserAssignedRoleSubscriptionWhereInput
  ) => UserAssignedRoleSubscriptionPayloadSubscription;
  userFollowers: (
    where?: UserFollowersSubscriptionWhereInput
  ) => UserFollowersSubscriptionPayloadSubscription;
  userInfluencers: (
    where?: UserInfluencersSubscriptionWhereInput
  ) => UserInfluencersSubscriptionPayloadSubscription;
  userPhoto: (
    where?: UserPhotoSubscriptionWhereInput
  ) => UserPhotoSubscriptionPayloadSubscription;
  userRole: (
    where?: UserRoleSubscriptionWhereInput
  ) => UserRoleSubscriptionPayloadSubscription;
  userStatus: (
    where?: UserStatusSubscriptionWhereInput
  ) => UserStatusSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type InfluencerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HomeTeamFixtureOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FollowerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "blocked_ASC"
  | "blocked_DESC"
  | "accepted_ASC"
  | "accepted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserInfluencersOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "name_ASC"
  | "name_DESC"
  | "countryCode_ASC"
  | "countryCode_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "displayName_ASC"
  | "displayName_DESC"
  | "isPrivate_ASC"
  | "isPrivate_DESC"
  | "password_ASC"
  | "password_DESC"
  | "emailValidationToken_ASC"
  | "emailValidationToken_DESC"
  | "emailValidationTokenExpiry_ASC"
  | "emailValidationTokenExpiry_DESC"
  | "emailValidated_ASC"
  | "emailValidated_DESC"
  | "emailValidationDate_ASC"
  | "emailValidationDate_DESC"
  | "resetToken_ASC"
  | "resetToken_DESC"
  | "resetTokenExpiry_ASC"
  | "resetTokenExpiry_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserAssignedRoleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserStatusOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "currentStatus_ASC"
  | "currentStatus_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StatusOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GameweekOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "averageEntryScore_ASC"
  | "averageEntryScore_DESC"
  | "dataChecked_ASC"
  | "dataChecked_DESC"
  | "deadlineTime_ASC"
  | "deadlineTime_DESC"
  | "deadlineTimeEpoch_ASC"
  | "deadlineTimeEpoch_DESC"
  | "deadlineTimeGameOffset_ASC"
  | "deadlineTimeGameOffset_DESC"
  | "finished_ASC"
  | "finished_DESC"
  | "highestScore_ASC"
  | "highestScore_DESC"
  | "highestScoringEntry_ASC"
  | "highestScoringEntry_DESC"
  | "fplEventId_ASC"
  | "fplEventId_DESC"
  | "isCurrent_ASC"
  | "isCurrent_DESC"
  | "isNext_ASC"
  | "isNext_DESC"
  | "isPrevious_ASC"
  | "isPrevious_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PhotoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "image_ASC"
  | "image_DESC"
  | "largeImage_ASC"
  | "largeImage_DESC"
  | "smallImage_ASC"
  | "smallImage_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserRoleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActiveSubscriptionsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AwayTeamFixtureOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserPhotoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isProfile_ASC"
  | "isProfile_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FandemSubscriptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FixtureOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fplCode_ASC"
  | "fplCode_DESC"
  | "finished_ASC"
  | "finished_DESC"
  | "finishedProvisional_ASC"
  | "finishedProvisional_DESC"
  | "fixtureId_ASC"
  | "fixtureId_DESC"
  | "kickoffTime_ASC"
  | "kickoffTime_DESC"
  | "minutes_ASC"
  | "minutes_DESC"
  | "provisionalStartTime_ASC"
  | "provisionalStartTime_DESC"
  | "started_ASC"
  | "started_DESC"
  | "teamADifficulty_ASC"
  | "teamADifficulty_DESC"
  | "teamAScore_ASC"
  | "teamAScore_DESC"
  | "teamHDifficulty_ASC"
  | "teamHDifficulty_DESC"
  | "teamHScore_ASC"
  | "teamHScore_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CountryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "iso_ASC"
  | "iso_DESC"
  | "name_ASC"
  | "name_DESC"
  | "code_ASC"
  | "code_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SeasonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fplId_ASC"
  | "fplId_DESC"
  | "label_ASC"
  | "label_DESC"
  | "competition_ASC"
  | "competition_DESC"
  | "startYear_ASC"
  | "startYear_DESC"
  | "endYear_ASC"
  | "endYear_DESC"
  | "isCurrent_ASC"
  | "isCurrent_DESC"
  | "isPrevious_ASC"
  | "isPrevious_DESC"
  | "isNext_ASC"
  | "isNext_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TeamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "fplTeamId_ASC"
  | "fplTeamId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "shortName_ASC"
  | "shortName_DESC"
  | "strength_ASC"
  | "strength_DESC"
  | "strengthAttackAway_ASC"
  | "strengthAttackAway_DESC"
  | "strengthAttackHome_ASC"
  | "strengthAttackHome_DESC"
  | "strengthDefenceAway_ASC"
  | "strengthDefenceAway_DESC"
  | "strengthDefenceHome_ASC"
  | "strengthDefenceHome_DESC"
  | "strengthOverallAway_ASC"
  | "strengthOverallAway_DESC"
  | "strengthOverallHome_ASC"
  | "strengthOverallHome_DESC"
  | "teamDivision_ASC"
  | "teamDivision_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserFollowersOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface FixtureUpdateWithoutTeamHDataInput {
  fplCode?: Maybe<Int>;
  event?: Maybe<GameweekUpdateOneRequiredWithoutFixturesInput>;
  finished?: Maybe<Boolean>;
  finishedProvisional?: Maybe<Boolean>;
  fixtureId?: Maybe<Int>;
  kickoffTime?: Maybe<DateTimeInput>;
  minutes?: Maybe<Int>;
  provisionalStartTime?: Maybe<Boolean>;
  started?: Maybe<Boolean>;
  teamA?: Maybe<AwayTeamFixtureUpdateOneRequiredWithoutFixtureInput>;
  teamADifficulty?: Maybe<Int>;
  teamAScore?: Maybe<Int>;
  teamHDifficulty?: Maybe<Int>;
  teamHScore?: Maybe<Int>;
}

export type ActiveSubscriptionsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface HomeTeamFixtureCreateWithoutFixtureInput {
  id?: Maybe<ID_Input>;
  homeTeam: TeamCreateOneWithoutHomeFixturesInput;
}

export interface UserInfluencersUpsertWithoutUserInput {
  update: UserInfluencersUpdateWithoutUserDataInput;
  create: UserInfluencersCreateWithoutUserInput;
}

export interface TeamCreateOneWithoutHomeFixturesInput {
  create?: Maybe<TeamCreateWithoutHomeFixturesInput>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface HomeTeamFixtureUpdateOneRequiredWithoutFixtureInput {
  create?: Maybe<HomeTeamFixtureCreateWithoutFixtureInput>;
  update?: Maybe<HomeTeamFixtureUpdateWithoutFixtureDataInput>;
  upsert?: Maybe<HomeTeamFixtureUpsertWithoutFixtureInput>;
  connect?: Maybe<HomeTeamFixtureWhereUniqueInput>;
}

export interface TeamCreateWithoutHomeFixturesInput {
  id?: Maybe<ID_Input>;
  code: Int;
  season: SeasonCreateOneInput;
  fplTeamId: Int;
  name: String;
  shortName: String;
  strength: Int;
  strengthAttackAway: Int;
  strengthAttackHome: Int;
  strengthDefenceAway: Int;
  strengthDefenceHome: Int;
  strengthOverallAway: Int;
  strengthOverallHome: Int;
  teamDivision?: Maybe<Int>;
  awayFixtures?: Maybe<AwayTeamFixtureCreateManyWithoutAwayTeamInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  countryCode?: Maybe<String>;
  countryCode_not?: Maybe<String>;
  countryCode_in?: Maybe<String[] | String>;
  countryCode_not_in?: Maybe<String[] | String>;
  countryCode_lt?: Maybe<String>;
  countryCode_lte?: Maybe<String>;
  countryCode_gt?: Maybe<String>;
  countryCode_gte?: Maybe<String>;
  countryCode_contains?: Maybe<String>;
  countryCode_not_contains?: Maybe<String>;
  countryCode_starts_with?: Maybe<String>;
  countryCode_not_starts_with?: Maybe<String>;
  countryCode_ends_with?: Maybe<String>;
  countryCode_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  favoriteTeam?: Maybe<TeamWhereInput>;
  country?: Maybe<CountryWhereInput>;
  displayName?: Maybe<String>;
  displayName_not?: Maybe<String>;
  displayName_in?: Maybe<String[] | String>;
  displayName_not_in?: Maybe<String[] | String>;
  displayName_lt?: Maybe<String>;
  displayName_lte?: Maybe<String>;
  displayName_gt?: Maybe<String>;
  displayName_gte?: Maybe<String>;
  displayName_contains?: Maybe<String>;
  displayName_not_contains?: Maybe<String>;
  displayName_starts_with?: Maybe<String>;
  displayName_not_starts_with?: Maybe<String>;
  displayName_ends_with?: Maybe<String>;
  displayName_not_ends_with?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  isPrivate_not?: Maybe<Boolean>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  photos_every?: Maybe<UserPhotoWhereInput>;
  photos_some?: Maybe<UserPhotoWhereInput>;
  photos_none?: Maybe<UserPhotoWhereInput>;
  emailValidationToken?: Maybe<String>;
  emailValidationToken_not?: Maybe<String>;
  emailValidationToken_in?: Maybe<String[] | String>;
  emailValidationToken_not_in?: Maybe<String[] | String>;
  emailValidationToken_lt?: Maybe<String>;
  emailValidationToken_lte?: Maybe<String>;
  emailValidationToken_gt?: Maybe<String>;
  emailValidationToken_gte?: Maybe<String>;
  emailValidationToken_contains?: Maybe<String>;
  emailValidationToken_not_contains?: Maybe<String>;
  emailValidationToken_starts_with?: Maybe<String>;
  emailValidationToken_not_starts_with?: Maybe<String>;
  emailValidationToken_ends_with?: Maybe<String>;
  emailValidationToken_not_ends_with?: Maybe<String>;
  emailValidationTokenExpiry?: Maybe<Float>;
  emailValidationTokenExpiry_not?: Maybe<Float>;
  emailValidationTokenExpiry_in?: Maybe<Float[] | Float>;
  emailValidationTokenExpiry_not_in?: Maybe<Float[] | Float>;
  emailValidationTokenExpiry_lt?: Maybe<Float>;
  emailValidationTokenExpiry_lte?: Maybe<Float>;
  emailValidationTokenExpiry_gt?: Maybe<Float>;
  emailValidationTokenExpiry_gte?: Maybe<Float>;
  emailValidated?: Maybe<Boolean>;
  emailValidated_not?: Maybe<Boolean>;
  emailValidationDate?: Maybe<DateTimeInput>;
  emailValidationDate_not?: Maybe<DateTimeInput>;
  emailValidationDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  emailValidationDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  emailValidationDate_lt?: Maybe<DateTimeInput>;
  emailValidationDate_lte?: Maybe<DateTimeInput>;
  emailValidationDate_gt?: Maybe<DateTimeInput>;
  emailValidationDate_gte?: Maybe<DateTimeInput>;
  resetToken?: Maybe<String>;
  resetToken_not?: Maybe<String>;
  resetToken_in?: Maybe<String[] | String>;
  resetToken_not_in?: Maybe<String[] | String>;
  resetToken_lt?: Maybe<String>;
  resetToken_lte?: Maybe<String>;
  resetToken_gt?: Maybe<String>;
  resetToken_gte?: Maybe<String>;
  resetToken_contains?: Maybe<String>;
  resetToken_not_contains?: Maybe<String>;
  resetToken_starts_with?: Maybe<String>;
  resetToken_not_starts_with?: Maybe<String>;
  resetToken_ends_with?: Maybe<String>;
  resetToken_not_ends_with?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  resetTokenExpiry_not?: Maybe<Float>;
  resetTokenExpiry_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_not_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_lt?: Maybe<Float>;
  resetTokenExpiry_lte?: Maybe<Float>;
  resetTokenExpiry_gt?: Maybe<Float>;
  resetTokenExpiry_gte?: Maybe<Float>;
  subscriptions_every?: Maybe<FandemSubscriptionWhereInput>;
  subscriptions_some?: Maybe<FandemSubscriptionWhereInput>;
  subscriptions_none?: Maybe<FandemSubscriptionWhereInput>;
  userRoles_every?: Maybe<UserRoleWhereInput>;
  userRoles_some?: Maybe<UserRoleWhereInput>;
  userRoles_none?: Maybe<UserRoleWhereInput>;
  status_every?: Maybe<UserStatusWhereInput>;
  status_some?: Maybe<UserStatusWhereInput>;
  status_none?: Maybe<UserStatusWhereInput>;
  followers?: Maybe<UserFollowersWhereInput>;
  influencers?: Maybe<UserInfluencersWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface AwayTeamFixtureCreateManyWithoutAwayTeamInput {
  create?: Maybe<
    | AwayTeamFixtureCreateWithoutAwayTeamInput[]
    | AwayTeamFixtureCreateWithoutAwayTeamInput
  >;
  connect?: Maybe<
    AwayTeamFixtureWhereUniqueInput[] | AwayTeamFixtureWhereUniqueInput
  >;
}

export interface UserStatusSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserStatusWhereInput>;
  AND?: Maybe<
    UserStatusSubscriptionWhereInput[] | UserStatusSubscriptionWhereInput
  >;
  OR?: Maybe<
    UserStatusSubscriptionWhereInput[] | UserStatusSubscriptionWhereInput
  >;
  NOT?: Maybe<
    UserStatusSubscriptionWhereInput[] | UserStatusSubscriptionWhereInput
  >;
}

export interface AwayTeamFixtureCreateWithoutAwayTeamInput {
  id?: Maybe<ID_Input>;
  fixture: FixtureCreateOneWithoutTeamAInput;
}

export interface UserRoleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserRoleWhereInput[] | UserRoleWhereInput>;
  OR?: Maybe<UserRoleWhereInput[] | UserRoleWhereInput>;
  NOT?: Maybe<UserRoleWhereInput[] | UserRoleWhereInput>;
}

export interface FixtureCreateOneWithoutTeamAInput {
  create?: Maybe<FixtureCreateWithoutTeamAInput>;
  connect?: Maybe<FixtureWhereUniqueInput>;
}

export interface StatusWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  author?: Maybe<UserStatusWhereInput>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  likes_every?: Maybe<UserWhereInput>;
  likes_some?: Maybe<UserWhereInput>;
  likes_none?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StatusWhereInput[] | StatusWhereInput>;
  OR?: Maybe<StatusWhereInput[] | StatusWhereInput>;
  NOT?: Maybe<StatusWhereInput[] | StatusWhereInput>;
}

export interface FixtureCreateWithoutTeamAInput {
  id?: Maybe<ID_Input>;
  fplCode: Int;
  event: GameweekCreateOneWithoutFixturesInput;
  finished: Boolean;
  finishedProvisional: Boolean;
  fixtureId: Int;
  kickoffTime?: Maybe<DateTimeInput>;
  minutes: Int;
  provisionalStartTime: Boolean;
  started: Boolean;
  teamADifficulty: Int;
  teamAScore?: Maybe<Int>;
  teamH: HomeTeamFixtureCreateOneWithoutFixtureInput;
  teamHDifficulty: Int;
  teamHScore?: Maybe<Int>;
}

export interface FollowerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  blocked?: Maybe<Boolean>;
  blocked_not?: Maybe<Boolean>;
  accepted?: Maybe<Boolean>;
  accepted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FollowerWhereInput[] | FollowerWhereInput>;
  OR?: Maybe<FollowerWhereInput[] | FollowerWhereInput>;
  NOT?: Maybe<FollowerWhereInput[] | FollowerWhereInput>;
}

export interface CountryCreateOneInput {
  create?: Maybe<CountryCreateInput>;
  connect?: Maybe<CountryWhereUniqueInput>;
}

export interface InfluencerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InfluencerWhereInput[] | InfluencerWhereInput>;
  OR?: Maybe<InfluencerWhereInput[] | InfluencerWhereInput>;
  NOT?: Maybe<InfluencerWhereInput[] | InfluencerWhereInput>;
}

export interface CountryCreateInput {
  id?: Maybe<ID_Input>;
  iso: String;
  name: String;
  code: String;
}

export interface UserRoleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserRoleWhereInput>;
  AND?: Maybe<
    UserRoleSubscriptionWhereInput[] | UserRoleSubscriptionWhereInput
  >;
  OR?: Maybe<UserRoleSubscriptionWhereInput[] | UserRoleSubscriptionWhereInput>;
  NOT?: Maybe<
    UserRoleSubscriptionWhereInput[] | UserRoleSubscriptionWhereInput
  >;
}

export interface UserPhotoCreateManyWithoutUserInput {
  create?: Maybe<
    UserPhotoCreateWithoutUserInput[] | UserPhotoCreateWithoutUserInput
  >;
  connect?: Maybe<UserPhotoWhereUniqueInput[] | UserPhotoWhereUniqueInput>;
}

export interface UserInfluencersSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserInfluencersWhereInput>;
  AND?: Maybe<
    | UserInfluencersSubscriptionWhereInput[]
    | UserInfluencersSubscriptionWhereInput
  >;
  OR?: Maybe<
    | UserInfluencersSubscriptionWhereInput[]
    | UserInfluencersSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UserInfluencersSubscriptionWhereInput[]
    | UserInfluencersSubscriptionWhereInput
  >;
}

export interface UserPhotoCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  photo: PhotoCreateOneInput;
  isProfile?: Maybe<Boolean>;
}

export interface UserAssignedRoleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserAssignedRoleWhereInput>;
  AND?: Maybe<
    | UserAssignedRoleSubscriptionWhereInput[]
    | UserAssignedRoleSubscriptionWhereInput
  >;
  OR?: Maybe<
    | UserAssignedRoleSubscriptionWhereInput[]
    | UserAssignedRoleSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UserAssignedRoleSubscriptionWhereInput[]
    | UserAssignedRoleSubscriptionWhereInput
  >;
}

export interface PhotoCreateOneInput {
  create?: Maybe<PhotoCreateInput>;
  connect?: Maybe<PhotoWhereUniqueInput>;
}

export interface TeamSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TeamWhereInput>;
  AND?: Maybe<TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput>;
  OR?: Maybe<TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput>;
  NOT?: Maybe<TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput>;
}

export interface PhotoCreateInput {
  id?: Maybe<ID_Input>;
  image: String;
  largeImage?: Maybe<String>;
  smallImage?: Maybe<String>;
}

export interface StatusSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StatusWhereInput>;
  AND?: Maybe<StatusSubscriptionWhereInput[] | StatusSubscriptionWhereInput>;
  OR?: Maybe<StatusSubscriptionWhereInput[] | StatusSubscriptionWhereInput>;
  NOT?: Maybe<StatusSubscriptionWhereInput[] | StatusSubscriptionWhereInput>;
}

export interface FandemSubscriptionCreateManyInput {
  create?: Maybe<
    FandemSubscriptionCreateInput[] | FandemSubscriptionCreateInput
  >;
  connect?: Maybe<
    FandemSubscriptionWhereUniqueInput[] | FandemSubscriptionWhereUniqueInput
  >;
}

export interface TeamWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<Int>;
  code_not?: Maybe<Int>;
  code_in?: Maybe<Int[] | Int>;
  code_not_in?: Maybe<Int[] | Int>;
  code_lt?: Maybe<Int>;
  code_lte?: Maybe<Int>;
  code_gt?: Maybe<Int>;
  code_gte?: Maybe<Int>;
  season?: Maybe<SeasonWhereInput>;
  fplTeamId?: Maybe<Int>;
  fplTeamId_not?: Maybe<Int>;
  fplTeamId_in?: Maybe<Int[] | Int>;
  fplTeamId_not_in?: Maybe<Int[] | Int>;
  fplTeamId_lt?: Maybe<Int>;
  fplTeamId_lte?: Maybe<Int>;
  fplTeamId_gt?: Maybe<Int>;
  fplTeamId_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  shortName?: Maybe<String>;
  shortName_not?: Maybe<String>;
  shortName_in?: Maybe<String[] | String>;
  shortName_not_in?: Maybe<String[] | String>;
  shortName_lt?: Maybe<String>;
  shortName_lte?: Maybe<String>;
  shortName_gt?: Maybe<String>;
  shortName_gte?: Maybe<String>;
  shortName_contains?: Maybe<String>;
  shortName_not_contains?: Maybe<String>;
  shortName_starts_with?: Maybe<String>;
  shortName_not_starts_with?: Maybe<String>;
  shortName_ends_with?: Maybe<String>;
  shortName_not_ends_with?: Maybe<String>;
  strength?: Maybe<Int>;
  strength_not?: Maybe<Int>;
  strength_in?: Maybe<Int[] | Int>;
  strength_not_in?: Maybe<Int[] | Int>;
  strength_lt?: Maybe<Int>;
  strength_lte?: Maybe<Int>;
  strength_gt?: Maybe<Int>;
  strength_gte?: Maybe<Int>;
  strengthAttackAway?: Maybe<Int>;
  strengthAttackAway_not?: Maybe<Int>;
  strengthAttackAway_in?: Maybe<Int[] | Int>;
  strengthAttackAway_not_in?: Maybe<Int[] | Int>;
  strengthAttackAway_lt?: Maybe<Int>;
  strengthAttackAway_lte?: Maybe<Int>;
  strengthAttackAway_gt?: Maybe<Int>;
  strengthAttackAway_gte?: Maybe<Int>;
  strengthAttackHome?: Maybe<Int>;
  strengthAttackHome_not?: Maybe<Int>;
  strengthAttackHome_in?: Maybe<Int[] | Int>;
  strengthAttackHome_not_in?: Maybe<Int[] | Int>;
  strengthAttackHome_lt?: Maybe<Int>;
  strengthAttackHome_lte?: Maybe<Int>;
  strengthAttackHome_gt?: Maybe<Int>;
  strengthAttackHome_gte?: Maybe<Int>;
  strengthDefenceAway?: Maybe<Int>;
  strengthDefenceAway_not?: Maybe<Int>;
  strengthDefenceAway_in?: Maybe<Int[] | Int>;
  strengthDefenceAway_not_in?: Maybe<Int[] | Int>;
  strengthDefenceAway_lt?: Maybe<Int>;
  strengthDefenceAway_lte?: Maybe<Int>;
  strengthDefenceAway_gt?: Maybe<Int>;
  strengthDefenceAway_gte?: Maybe<Int>;
  strengthDefenceHome?: Maybe<Int>;
  strengthDefenceHome_not?: Maybe<Int>;
  strengthDefenceHome_in?: Maybe<Int[] | Int>;
  strengthDefenceHome_not_in?: Maybe<Int[] | Int>;
  strengthDefenceHome_lt?: Maybe<Int>;
  strengthDefenceHome_lte?: Maybe<Int>;
  strengthDefenceHome_gt?: Maybe<Int>;
  strengthDefenceHome_gte?: Maybe<Int>;
  strengthOverallAway?: Maybe<Int>;
  strengthOverallAway_not?: Maybe<Int>;
  strengthOverallAway_in?: Maybe<Int[] | Int>;
  strengthOverallAway_not_in?: Maybe<Int[] | Int>;
  strengthOverallAway_lt?: Maybe<Int>;
  strengthOverallAway_lte?: Maybe<Int>;
  strengthOverallAway_gt?: Maybe<Int>;
  strengthOverallAway_gte?: Maybe<Int>;
  strengthOverallHome?: Maybe<Int>;
  strengthOverallHome_not?: Maybe<Int>;
  strengthOverallHome_in?: Maybe<Int[] | Int>;
  strengthOverallHome_not_in?: Maybe<Int[] | Int>;
  strengthOverallHome_lt?: Maybe<Int>;
  strengthOverallHome_lte?: Maybe<Int>;
  strengthOverallHome_gt?: Maybe<Int>;
  strengthOverallHome_gte?: Maybe<Int>;
  teamDivision?: Maybe<Int>;
  teamDivision_not?: Maybe<Int>;
  teamDivision_in?: Maybe<Int[] | Int>;
  teamDivision_not_in?: Maybe<Int[] | Int>;
  teamDivision_lt?: Maybe<Int>;
  teamDivision_lte?: Maybe<Int>;
  teamDivision_gt?: Maybe<Int>;
  teamDivision_gte?: Maybe<Int>;
  homeFixtures_every?: Maybe<HomeTeamFixtureWhereInput>;
  homeFixtures_some?: Maybe<HomeTeamFixtureWhereInput>;
  homeFixtures_none?: Maybe<HomeTeamFixtureWhereInput>;
  awayFixtures_every?: Maybe<AwayTeamFixtureWhereInput>;
  awayFixtures_some?: Maybe<AwayTeamFixtureWhereInput>;
  awayFixtures_none?: Maybe<AwayTeamFixtureWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TeamWhereInput[] | TeamWhereInput>;
  OR?: Maybe<TeamWhereInput[] | TeamWhereInput>;
  NOT?: Maybe<TeamWhereInput[] | TeamWhereInput>;
}

export interface FandemSubscriptionCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
}

export interface AwayTeamFixtureWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fixture?: Maybe<FixtureWhereInput>;
  awayTeam?: Maybe<TeamWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AwayTeamFixtureWhereInput[] | AwayTeamFixtureWhereInput>;
  OR?: Maybe<AwayTeamFixtureWhereInput[] | AwayTeamFixtureWhereInput>;
  NOT?: Maybe<AwayTeamFixtureWhereInput[] | AwayTeamFixtureWhereInput>;
}

export interface UserRoleCreateManyInput {
  create?: Maybe<UserRoleCreateInput[] | UserRoleCreateInput>;
  connect?: Maybe<UserRoleWhereUniqueInput[] | UserRoleWhereUniqueInput>;
}

export interface HomeTeamFixtureSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HomeTeamFixtureWhereInput>;
  AND?: Maybe<
    | HomeTeamFixtureSubscriptionWhereInput[]
    | HomeTeamFixtureSubscriptionWhereInput
  >;
  OR?: Maybe<
    | HomeTeamFixtureSubscriptionWhereInput[]
    | HomeTeamFixtureSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | HomeTeamFixtureSubscriptionWhereInput[]
    | HomeTeamFixtureSubscriptionWhereInput
  >;
}

export interface UserRoleCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
}

export interface GameweekSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GameweekWhereInput>;
  AND?: Maybe<
    GameweekSubscriptionWhereInput[] | GameweekSubscriptionWhereInput
  >;
  OR?: Maybe<GameweekSubscriptionWhereInput[] | GameweekSubscriptionWhereInput>;
  NOT?: Maybe<
    GameweekSubscriptionWhereInput[] | GameweekSubscriptionWhereInput
  >;
}

export interface UserStatusCreateManyInput {
  create?: Maybe<UserStatusCreateInput[] | UserStatusCreateInput>;
  connect?: Maybe<UserStatusWhereUniqueInput[] | UserStatusWhereUniqueInput>;
}

export interface FollowerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FollowerWhereInput>;
  AND?: Maybe<
    FollowerSubscriptionWhereInput[] | FollowerSubscriptionWhereInput
  >;
  OR?: Maybe<FollowerSubscriptionWhereInput[] | FollowerSubscriptionWhereInput>;
  NOT?: Maybe<
    FollowerSubscriptionWhereInput[] | FollowerSubscriptionWhereInput
  >;
}

export interface UserStatusCreateInput {
  id?: Maybe<ID_Input>;
  status?: Maybe<StatusCreateOneWithoutAuthorInput>;
  currentStatus?: Maybe<Boolean>;
}

export interface FandemSubscriptionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FandemSubscriptionWhereInput>;
  AND?: Maybe<
    | FandemSubscriptionSubscriptionWhereInput[]
    | FandemSubscriptionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | FandemSubscriptionSubscriptionWhereInput[]
    | FandemSubscriptionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | FandemSubscriptionSubscriptionWhereInput[]
    | FandemSubscriptionSubscriptionWhereInput
  >;
}

export interface StatusCreateOneWithoutAuthorInput {
  create?: Maybe<StatusCreateWithoutAuthorInput>;
  connect?: Maybe<StatusWhereUniqueInput>;
}

export interface AwayTeamFixtureSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AwayTeamFixtureWhereInput>;
  AND?: Maybe<
    | AwayTeamFixtureSubscriptionWhereInput[]
    | AwayTeamFixtureSubscriptionWhereInput
  >;
  OR?: Maybe<
    | AwayTeamFixtureSubscriptionWhereInput[]
    | AwayTeamFixtureSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | AwayTeamFixtureSubscriptionWhereInput[]
    | AwayTeamFixtureSubscriptionWhereInput
  >;
}

export interface StatusCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  content: String;
  likes?: Maybe<UserCreateManyInput>;
}

export interface ActiveSubscriptionsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ActiveSubscriptionsWhereInput>;
  AND?: Maybe<
    | ActiveSubscriptionsSubscriptionWhereInput[]
    | ActiveSubscriptionsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ActiveSubscriptionsSubscriptionWhereInput[]
    | ActiveSubscriptionsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ActiveSubscriptionsSubscriptionWhereInput[]
    | ActiveSubscriptionsSubscriptionWhereInput
  >;
}

export interface UserCreateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserStatusUpdateInput {
  status?: Maybe<StatusUpdateOneWithoutAuthorInput>;
  currentStatus?: Maybe<Boolean>;
}

export interface UserFollowersCreateOneWithoutUserInput {
  create?: Maybe<UserFollowersCreateWithoutUserInput>;
  connect?: Maybe<UserFollowersWhereUniqueInput>;
}

export interface SeasonWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fplId?: Maybe<Int>;
  fplId_not?: Maybe<Int>;
  fplId_in?: Maybe<Int[] | Int>;
  fplId_not_in?: Maybe<Int[] | Int>;
  fplId_lt?: Maybe<Int>;
  fplId_lte?: Maybe<Int>;
  fplId_gt?: Maybe<Int>;
  fplId_gte?: Maybe<Int>;
  label?: Maybe<String>;
  label_not?: Maybe<String>;
  label_in?: Maybe<String[] | String>;
  label_not_in?: Maybe<String[] | String>;
  label_lt?: Maybe<String>;
  label_lte?: Maybe<String>;
  label_gt?: Maybe<String>;
  label_gte?: Maybe<String>;
  label_contains?: Maybe<String>;
  label_not_contains?: Maybe<String>;
  label_starts_with?: Maybe<String>;
  label_not_starts_with?: Maybe<String>;
  label_ends_with?: Maybe<String>;
  label_not_ends_with?: Maybe<String>;
  competition?: Maybe<String>;
  competition_not?: Maybe<String>;
  competition_in?: Maybe<String[] | String>;
  competition_not_in?: Maybe<String[] | String>;
  competition_lt?: Maybe<String>;
  competition_lte?: Maybe<String>;
  competition_gt?: Maybe<String>;
  competition_gte?: Maybe<String>;
  competition_contains?: Maybe<String>;
  competition_not_contains?: Maybe<String>;
  competition_starts_with?: Maybe<String>;
  competition_not_starts_with?: Maybe<String>;
  competition_ends_with?: Maybe<String>;
  competition_not_ends_with?: Maybe<String>;
  startYear?: Maybe<Int>;
  startYear_not?: Maybe<Int>;
  startYear_in?: Maybe<Int[] | Int>;
  startYear_not_in?: Maybe<Int[] | Int>;
  startYear_lt?: Maybe<Int>;
  startYear_lte?: Maybe<Int>;
  startYear_gt?: Maybe<Int>;
  startYear_gte?: Maybe<Int>;
  endYear?: Maybe<Int>;
  endYear_not?: Maybe<Int>;
  endYear_in?: Maybe<Int[] | Int>;
  endYear_not_in?: Maybe<Int[] | Int>;
  endYear_lt?: Maybe<Int>;
  endYear_lte?: Maybe<Int>;
  endYear_gt?: Maybe<Int>;
  endYear_gte?: Maybe<Int>;
  isCurrent?: Maybe<Boolean>;
  isCurrent_not?: Maybe<Boolean>;
  isPrevious?: Maybe<Boolean>;
  isPrevious_not?: Maybe<Boolean>;
  isNext?: Maybe<Boolean>;
  isNext_not?: Maybe<Boolean>;
  events_every?: Maybe<GameweekWhereInput>;
  events_some?: Maybe<GameweekWhereInput>;
  events_none?: Maybe<GameweekWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<SeasonWhereInput[] | SeasonWhereInput>;
  OR?: Maybe<SeasonWhereInput[] | SeasonWhereInput>;
  NOT?: Maybe<SeasonWhereInput[] | SeasonWhereInput>;
}

export interface UserFollowersCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  followers?: Maybe<FollowerCreateManyInput>;
}

export interface UserRoleUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface FollowerCreateManyInput {
  create?: Maybe<FollowerCreateInput[] | FollowerCreateInput>;
  connect?: Maybe<FollowerWhereUniqueInput[] | FollowerWhereUniqueInput>;
}

export type FandemSubscriptionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FollowerCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  blocked?: Maybe<Boolean>;
  accepted?: Maybe<Boolean>;
}

export interface UserUpdateWithoutPhotosDataInput {
  email?: Maybe<String>;
  name?: Maybe<String>;
  countryCode?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  favoriteTeam?: Maybe<TeamUpdateOneInput>;
  country?: Maybe<CountryUpdateOneInput>;
  displayName?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  password?: Maybe<String>;
  emailValidationToken?: Maybe<String>;
  emailValidationTokenExpiry?: Maybe<Float>;
  emailValidated?: Maybe<Boolean>;
  emailValidationDate?: Maybe<DateTimeInput>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  subscriptions?: Maybe<FandemSubscriptionUpdateManyInput>;
  userRoles?: Maybe<UserRoleUpdateManyInput>;
  status?: Maybe<UserStatusUpdateManyInput>;
  followers?: Maybe<UserFollowersUpdateOneWithoutUserInput>;
  influencers?: Maybe<UserInfluencersUpdateOneWithoutUserInput>;
}

export interface UserInfluencersCreateOneWithoutUserInput {
  create?: Maybe<UserInfluencersCreateWithoutUserInput>;
  connect?: Maybe<UserInfluencersWhereUniqueInput>;
}

export type FixtureWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  fplCode?: Maybe<Int>;
}>;

export interface UserInfluencersCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  influencers?: Maybe<InfluencerCreateManyInput>;
}

export interface UserCreateWithoutPhotosInput {
  id?: Maybe<ID_Input>;
  email: String;
  name: String;
  countryCode?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  favoriteTeam?: Maybe<TeamCreateOneInput>;
  country?: Maybe<CountryCreateOneInput>;
  displayName: String;
  isPrivate?: Maybe<Boolean>;
  password: String;
  emailValidationToken?: Maybe<String>;
  emailValidationTokenExpiry?: Maybe<Float>;
  emailValidated?: Maybe<Boolean>;
  emailValidationDate?: Maybe<DateTimeInput>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  subscriptions?: Maybe<FandemSubscriptionCreateManyInput>;
  userRoles?: Maybe<UserRoleCreateManyInput>;
  status?: Maybe<UserStatusCreateManyInput>;
  followers?: Maybe<UserFollowersCreateOneWithoutUserInput>;
  influencers?: Maybe<UserInfluencersCreateOneWithoutUserInput>;
}

export interface InfluencerCreateManyInput {
  create?: Maybe<InfluencerCreateInput[] | InfluencerCreateInput>;
  connect?: Maybe<InfluencerWhereUniqueInput[] | InfluencerWhereUniqueInput>;
}

export type FollowerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface InfluencerCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
}

export interface UserUpsertWithoutInfluencersInput {
  update: UserUpdateWithoutInfluencersDataInput;
  create: UserCreateWithoutInfluencersInput;
}

export interface UserRoleCreateOneInput {
  create?: Maybe<UserRoleCreateInput>;
  connect?: Maybe<UserRoleWhereUniqueInput>;
}

export type GameweekWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  fplEventId?: Maybe<Int>;
}>;

export interface ActiveSubscriptionsUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  subscription?: Maybe<UserRoleUpdateOneRequiredInput>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
}

export interface UserInfluencersUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutInfluencersInput>;
  influencers?: Maybe<InfluencerUpdateManyInput>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type HomeTeamFixtureWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateDataInput {
  email?: Maybe<String>;
  name?: Maybe<String>;
  countryCode?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  favoriteTeam?: Maybe<TeamUpdateOneInput>;
  country?: Maybe<CountryUpdateOneInput>;
  displayName?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  password?: Maybe<String>;
  photos?: Maybe<UserPhotoUpdateManyWithoutUserInput>;
  emailValidationToken?: Maybe<String>;
  emailValidationTokenExpiry?: Maybe<Float>;
  emailValidated?: Maybe<Boolean>;
  emailValidationDate?: Maybe<DateTimeInput>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  subscriptions?: Maybe<FandemSubscriptionUpdateManyInput>;
  userRoles?: Maybe<UserRoleUpdateManyInput>;
  status?: Maybe<UserStatusUpdateManyInput>;
  followers?: Maybe<UserFollowersUpdateOneWithoutUserInput>;
  influencers?: Maybe<UserInfluencersUpdateOneWithoutUserInput>;
}

export interface UserInfluencersCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutInfluencersInput;
  influencers?: Maybe<InfluencerCreateManyInput>;
}

export interface TeamUpdateOneInput {
  create?: Maybe<TeamCreateInput>;
  update?: Maybe<TeamUpdateDataInput>;
  upsert?: Maybe<TeamUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export type InfluencerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TeamUpdateDataInput {
  code?: Maybe<Int>;
  season?: Maybe<SeasonUpdateOneRequiredInput>;
  fplTeamId?: Maybe<Int>;
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  strength?: Maybe<Int>;
  strengthAttackAway?: Maybe<Int>;
  strengthAttackHome?: Maybe<Int>;
  strengthDefenceAway?: Maybe<Int>;
  strengthDefenceHome?: Maybe<Int>;
  strengthOverallAway?: Maybe<Int>;
  strengthOverallHome?: Maybe<Int>;
  teamDivision?: Maybe<Int>;
  homeFixtures?: Maybe<HomeTeamFixtureUpdateManyWithoutHomeTeamInput>;
  awayFixtures?: Maybe<AwayTeamFixtureUpdateManyWithoutAwayTeamInput>;
}

export interface UserUpdateOneRequiredWithoutFollowersInput {
  create?: Maybe<UserCreateWithoutFollowersInput>;
  update?: Maybe<UserUpdateWithoutFollowersDataInput>;
  upsert?: Maybe<UserUpsertWithoutFollowersInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface SeasonUpdateOneRequiredInput {
  create?: Maybe<SeasonCreateInput>;
  update?: Maybe<SeasonUpdateDataInput>;
  upsert?: Maybe<SeasonUpsertNestedInput>;
  connect?: Maybe<SeasonWhereUniqueInput>;
}

export type PhotoWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SeasonUpdateDataInput {
  fplId?: Maybe<Int>;
  label?: Maybe<String>;
  competition?: Maybe<String>;
  startYear?: Maybe<Int>;
  endYear?: Maybe<Int>;
  isCurrent?: Maybe<Boolean>;
  isPrevious?: Maybe<Boolean>;
  isNext?: Maybe<Boolean>;
  events?: Maybe<GameweekUpdateManyWithoutSeasonInput>;
}

export interface UserCreateWithoutFollowersInput {
  id?: Maybe<ID_Input>;
  email: String;
  name: String;
  countryCode?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  favoriteTeam?: Maybe<TeamCreateOneInput>;
  country?: Maybe<CountryCreateOneInput>;
  displayName: String;
  isPrivate?: Maybe<Boolean>;
  password: String;
  photos?: Maybe<UserPhotoCreateManyWithoutUserInput>;
  emailValidationToken?: Maybe<String>;
  emailValidationTokenExpiry?: Maybe<Float>;
  emailValidated?: Maybe<Boolean>;
  emailValidationDate?: Maybe<DateTimeInput>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  subscriptions?: Maybe<FandemSubscriptionCreateManyInput>;
  userRoles?: Maybe<UserRoleCreateManyInput>;
  status?: Maybe<UserStatusCreateManyInput>;
  influencers?: Maybe<UserInfluencersCreateOneWithoutUserInput>;
}

export interface GameweekUpdateManyWithoutSeasonInput {
  create?: Maybe<
    GameweekCreateWithoutSeasonInput[] | GameweekCreateWithoutSeasonInput
  >;
  delete?: Maybe<GameweekWhereUniqueInput[] | GameweekWhereUniqueInput>;
  connect?: Maybe<GameweekWhereUniqueInput[] | GameweekWhereUniqueInput>;
  set?: Maybe<GameweekWhereUniqueInput[] | GameweekWhereUniqueInput>;
  disconnect?: Maybe<GameweekWhereUniqueInput[] | GameweekWhereUniqueInput>;
  update?: Maybe<
    | GameweekUpdateWithWhereUniqueWithoutSeasonInput[]
    | GameweekUpdateWithWhereUniqueWithoutSeasonInput
  >;
  upsert?: Maybe<
    | GameweekUpsertWithWhereUniqueWithoutSeasonInput[]
    | GameweekUpsertWithWhereUniqueWithoutSeasonInput
  >;
  deleteMany?: Maybe<GameweekScalarWhereInput[] | GameweekScalarWhereInput>;
  updateMany?: Maybe<
    | GameweekUpdateManyWithWhereNestedInput[]
    | GameweekUpdateManyWithWhereNestedInput
  >;
}

export interface UserFollowersCreateInput {
  id?: Maybe<ID_Input>;
  followers?: Maybe<FollowerCreateManyInput>;
  user: UserCreateOneWithoutFollowersInput;
}

export interface GameweekUpdateWithWhereUniqueWithoutSeasonInput {
  where: GameweekWhereUniqueInput;
  data: GameweekUpdateWithoutSeasonDataInput;
}

export interface UserAssignedRoleUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  userRole?: Maybe<UserRoleUpdateOneRequiredInput>;
}

export interface GameweekUpdateWithoutSeasonDataInput {
  averageEntryScore?: Maybe<Int>;
  dataChecked?: Maybe<Boolean>;
  deadlineTime?: Maybe<DateTimeInput>;
  deadlineTimeEpoch?: Maybe<Int>;
  deadlineTimeGameOffset?: Maybe<Int>;
  finished?: Maybe<Boolean>;
  highestScore?: Maybe<Int>;
  highestScoringEntry?: Maybe<Int>;
  fplEventId?: Maybe<Int>;
  isCurrent?: Maybe<Boolean>;
  isNext?: Maybe<Boolean>;
  isPrevious?: Maybe<Boolean>;
  name?: Maybe<String>;
  fixtures?: Maybe<FixtureUpdateManyWithoutEventInput>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  name?: Maybe<String>;
  countryCode?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  displayName?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  password?: Maybe<String>;
  emailValidationToken?: Maybe<String>;
  emailValidationTokenExpiry?: Maybe<Float>;
  emailValidated?: Maybe<Boolean>;
  emailValidationDate?: Maybe<DateTimeInput>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
}

export interface FixtureUpdateManyWithoutEventInput {
  create?: Maybe<
    FixtureCreateWithoutEventInput[] | FixtureCreateWithoutEventInput
  >;
  delete?: Maybe<FixtureWhereUniqueInput[] | FixtureWhereUniqueInput>;
  connect?: Maybe<FixtureWhereUniqueInput[] | FixtureWhereUniqueInput>;
  set?: Maybe<FixtureWhereUniqueInput[] | FixtureWhereUniqueInput>;
  disconnect?: Maybe<FixtureWhereUniqueInput[] | FixtureWhereUniqueInput>;
  update?: Maybe<
    | FixtureUpdateWithWhereUniqueWithoutEventInput[]
    | FixtureUpdateWithWhereUniqueWithoutEventInput
  >;
  upsert?: Maybe<
    | FixtureUpsertWithWhereUniqueWithoutEventInput[]
    | FixtureUpsertWithWhereUniqueWithoutEventInput
  >;
  deleteMany?: Maybe<FixtureScalarWhereInput[] | FixtureScalarWhereInput>;
  updateMany?: Maybe<
    | FixtureUpdateManyWithWhereNestedInput[]
    | FixtureUpdateManyWithWhereNestedInput
  >;
}

export type StatusWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FixtureUpdateWithWhereUniqueWithoutEventInput {
  where: FixtureWhereUniqueInput;
  data: FixtureUpdateWithoutEventDataInput;
}

export interface TeamUpdateInput {
  code?: Maybe<Int>;
  season?: Maybe<SeasonUpdateOneRequiredInput>;
  fplTeamId?: Maybe<Int>;
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  strength?: Maybe<Int>;
  strengthAttackAway?: Maybe<Int>;
  strengthAttackHome?: Maybe<Int>;
  strengthDefenceAway?: Maybe<Int>;
  strengthDefenceHome?: Maybe<Int>;
  strengthOverallAway?: Maybe<Int>;
  strengthOverallHome?: Maybe<Int>;
  teamDivision?: Maybe<Int>;
  homeFixtures?: Maybe<HomeTeamFixtureUpdateManyWithoutHomeTeamInput>;
  awayFixtures?: Maybe<AwayTeamFixtureUpdateManyWithoutAwayTeamInput>;
}

export interface FixtureUpdateWithoutEventDataInput {
  fplCode?: Maybe<Int>;
  finished?: Maybe<Boolean>;
  finishedProvisional?: Maybe<Boolean>;
  fixtureId?: Maybe<Int>;
  kickoffTime?: Maybe<DateTimeInput>;
  minutes?: Maybe<Int>;
  provisionalStartTime?: Maybe<Boolean>;
  started?: Maybe<Boolean>;
  teamA?: Maybe<AwayTeamFixtureUpdateOneRequiredWithoutFixtureInput>;
  teamADifficulty?: Maybe<Int>;
  teamAScore?: Maybe<Int>;
  teamH?: Maybe<HomeTeamFixtureUpdateOneRequiredWithoutFixtureInput>;
  teamHDifficulty?: Maybe<Int>;
  teamHScore?: Maybe<Int>;
}

export interface UserStatusUpsertWithoutStatusInput {
  update: UserStatusUpdateWithoutStatusDataInput;
  create: UserStatusCreateWithoutStatusInput;
}

export interface AwayTeamFixtureUpdateOneRequiredWithoutFixtureInput {
  create?: Maybe<AwayTeamFixtureCreateWithoutFixtureInput>;
  update?: Maybe<AwayTeamFixtureUpdateWithoutFixtureDataInput>;
  upsert?: Maybe<AwayTeamFixtureUpsertWithoutFixtureInput>;
  connect?: Maybe<AwayTeamFixtureWhereUniqueInput>;
}

export interface UserStatusUpdateWithoutStatusDataInput {
  currentStatus?: Maybe<Boolean>;
}

export interface AwayTeamFixtureUpdateWithoutFixtureDataInput {
  awayTeam?: Maybe<TeamUpdateOneRequiredWithoutAwayFixturesInput>;
}

export interface StatusUpdateInput {
  author?: Maybe<UserStatusUpdateOneWithoutStatusInput>;
  content?: Maybe<String>;
  likes?: Maybe<UserUpdateManyInput>;
}

export interface TeamUpdateOneRequiredWithoutAwayFixturesInput {
  create?: Maybe<TeamCreateWithoutAwayFixturesInput>;
  update?: Maybe<TeamUpdateWithoutAwayFixturesDataInput>;
  upsert?: Maybe<TeamUpsertWithoutAwayFixturesInput>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
  displayName?: Maybe<String>;
}>;

export interface TeamUpdateWithoutAwayFixturesDataInput {
  code?: Maybe<Int>;
  season?: Maybe<SeasonUpdateOneRequiredInput>;
  fplTeamId?: Maybe<Int>;
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  strength?: Maybe<Int>;
  strengthAttackAway?: Maybe<Int>;
  strengthAttackHome?: Maybe<Int>;
  strengthDefenceAway?: Maybe<Int>;
  strengthDefenceHome?: Maybe<Int>;
  strengthOverallAway?: Maybe<Int>;
  strengthOverallHome?: Maybe<Int>;
  teamDivision?: Maybe<Int>;
  homeFixtures?: Maybe<HomeTeamFixtureUpdateManyWithoutHomeTeamInput>;
}

export interface StatusCreateInput {
  id?: Maybe<ID_Input>;
  author?: Maybe<UserStatusCreateOneWithoutStatusInput>;
  content: String;
  likes?: Maybe<UserCreateManyInput>;
}

export interface HomeTeamFixtureUpdateManyWithoutHomeTeamInput {
  create?: Maybe<
    | HomeTeamFixtureCreateWithoutHomeTeamInput[]
    | HomeTeamFixtureCreateWithoutHomeTeamInput
  >;
  delete?: Maybe<
    HomeTeamFixtureWhereUniqueInput[] | HomeTeamFixtureWhereUniqueInput
  >;
  connect?: Maybe<
    HomeTeamFixtureWhereUniqueInput[] | HomeTeamFixtureWhereUniqueInput
  >;
  set?: Maybe<
    HomeTeamFixtureWhereUniqueInput[] | HomeTeamFixtureWhereUniqueInput
  >;
  disconnect?: Maybe<
    HomeTeamFixtureWhereUniqueInput[] | HomeTeamFixtureWhereUniqueInput
  >;
  update?: Maybe<
    | HomeTeamFixtureUpdateWithWhereUniqueWithoutHomeTeamInput[]
    | HomeTeamFixtureUpdateWithWhereUniqueWithoutHomeTeamInput
  >;
  upsert?: Maybe<
    | HomeTeamFixtureUpsertWithWhereUniqueWithoutHomeTeamInput[]
    | HomeTeamFixtureUpsertWithWhereUniqueWithoutHomeTeamInput
  >;
  deleteMany?: Maybe<
    HomeTeamFixtureScalarWhereInput[] | HomeTeamFixtureScalarWhereInput
  >;
}

export type UserAssignedRoleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface HomeTeamFixtureUpdateWithWhereUniqueWithoutHomeTeamInput {
  where: HomeTeamFixtureWhereUniqueInput;
  data: HomeTeamFixtureUpdateWithoutHomeTeamDataInput;
}

export interface UserAssignedRoleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  userRole?: Maybe<UserRoleWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserAssignedRoleWhereInput[] | UserAssignedRoleWhereInput>;
  OR?: Maybe<UserAssignedRoleWhereInput[] | UserAssignedRoleWhereInput>;
  NOT?: Maybe<UserAssignedRoleWhereInput[] | UserAssignedRoleWhereInput>;
}

export interface HomeTeamFixtureUpdateWithoutHomeTeamDataInput {
  fixture?: Maybe<FixtureUpdateOneRequiredWithoutTeamHInput>;
}

export interface PhotoUpdateInput {
  image?: Maybe<String>;
  largeImage?: Maybe<String>;
  smallImage?: Maybe<String>;
}

export interface FixtureUpdateOneRequiredWithoutTeamHInput {
  create?: Maybe<FixtureCreateWithoutTeamHInput>;
  update?: Maybe<FixtureUpdateWithoutTeamHDataInput>;
  upsert?: Maybe<FixtureUpsertWithoutTeamHInput>;
  connect?: Maybe<FixtureWhereUniqueInput>;
}

export interface HomeTeamFixtureUpdateInput {
  fixture?: Maybe<FixtureUpdateOneRequiredWithoutTeamHInput>;
  homeTeam?: Maybe<TeamUpdateOneRequiredWithoutHomeFixturesInput>;
}

export interface UserRoleUpdateOneRequiredInput {
  create?: Maybe<UserRoleCreateInput>;
  update?: Maybe<UserRoleUpdateDataInput>;
  upsert?: Maybe<UserRoleUpsertNestedInput>;
  connect?: Maybe<UserRoleWhereUniqueInput>;
}

export interface HomeTeamFixtureCreateInput {
  id?: Maybe<ID_Input>;
  fixture: FixtureCreateOneWithoutTeamHInput;
  homeTeam: TeamCreateOneWithoutHomeFixturesInput;
}

export interface GameweekUpdateOneRequiredWithoutFixturesInput {
  create?: Maybe<GameweekCreateWithoutFixturesInput>;
  update?: Maybe<GameweekUpdateWithoutFixturesDataInput>;
  upsert?: Maybe<GameweekUpsertWithoutFixturesInput>;
  connect?: Maybe<GameweekWhereUniqueInput>;
}

export interface GameweekUpdateInput {
  season?: Maybe<SeasonUpdateOneRequiredWithoutEventsInput>;
  averageEntryScore?: Maybe<Int>;
  dataChecked?: Maybe<Boolean>;
  deadlineTime?: Maybe<DateTimeInput>;
  deadlineTimeEpoch?: Maybe<Int>;
  deadlineTimeGameOffset?: Maybe<Int>;
  finished?: Maybe<Boolean>;
  highestScore?: Maybe<Int>;
  highestScoringEntry?: Maybe<Int>;
  fplEventId?: Maybe<Int>;
  isCurrent?: Maybe<Boolean>;
  isNext?: Maybe<Boolean>;
  isPrevious?: Maybe<Boolean>;
  name?: Maybe<String>;
  fixtures?: Maybe<FixtureUpdateManyWithoutEventInput>;
}

export interface GameweekUpdateWithoutFixturesDataInput {
  season?: Maybe<SeasonUpdateOneRequiredWithoutEventsInput>;
  averageEntryScore?: Maybe<Int>;
  dataChecked?: Maybe<Boolean>;
  deadlineTime?: Maybe<DateTimeInput>;
  deadlineTimeEpoch?: Maybe<Int>;
  deadlineTimeGameOffset?: Maybe<Int>;
  finished?: Maybe<Boolean>;
  highestScore?: Maybe<Int>;
  highestScoringEntry?: Maybe<Int>;
  fplEventId?: Maybe<Int>;
  isCurrent?: Maybe<Boolean>;
  isNext?: Maybe<Boolean>;
  isPrevious?: Maybe<Boolean>;
  name?: Maybe<String>;
}

export type UserInfluencersWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SeasonUpdateOneRequiredWithoutEventsInput {
  create?: Maybe<SeasonCreateWithoutEventsInput>;
  update?: Maybe<SeasonUpdateWithoutEventsDataInput>;
  upsert?: Maybe<SeasonUpsertWithoutEventsInput>;
  connect?: Maybe<SeasonWhereUniqueInput>;
}

export interface FollowerUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  blocked?: Maybe<Boolean>;
  accepted?: Maybe<Boolean>;
}

export interface SeasonUpdateWithoutEventsDataInput {
  fplId?: Maybe<Int>;
  label?: Maybe<String>;
  competition?: Maybe<String>;
  startYear?: Maybe<Int>;
  endYear?: Maybe<Int>;
  isCurrent?: Maybe<Boolean>;
  isPrevious?: Maybe<Boolean>;
  isNext?: Maybe<Boolean>;
}

export interface FixtureUpdateInput {
  fplCode?: Maybe<Int>;
  event?: Maybe<GameweekUpdateOneRequiredWithoutFixturesInput>;
  finished?: Maybe<Boolean>;
  finishedProvisional?: Maybe<Boolean>;
  fixtureId?: Maybe<Int>;
  kickoffTime?: Maybe<DateTimeInput>;
  minutes?: Maybe<Int>;
  provisionalStartTime?: Maybe<Boolean>;
  started?: Maybe<Boolean>;
  teamA?: Maybe<AwayTeamFixtureUpdateOneRequiredWithoutFixtureInput>;
  teamADifficulty?: Maybe<Int>;
  teamAScore?: Maybe<Int>;
  teamH?: Maybe<HomeTeamFixtureUpdateOneRequiredWithoutFixtureInput>;
  teamHDifficulty?: Maybe<Int>;
  teamHScore?: Maybe<Int>;
}

export interface SeasonUpsertWithoutEventsInput {
  update: SeasonUpdateWithoutEventsDataInput;
  create: SeasonCreateWithoutEventsInput;
}

export interface FixtureCreateInput {
  id?: Maybe<ID_Input>;
  fplCode: Int;
  event: GameweekCreateOneWithoutFixturesInput;
  finished: Boolean;
  finishedProvisional: Boolean;
  fixtureId: Int;
  kickoffTime?: Maybe<DateTimeInput>;
  minutes: Int;
  provisionalStartTime: Boolean;
  started: Boolean;
  teamA: AwayTeamFixtureCreateOneWithoutFixtureInput;
  teamADifficulty: Int;
  teamAScore?: Maybe<Int>;
  teamH: HomeTeamFixtureCreateOneWithoutFixtureInput;
  teamHDifficulty: Int;
  teamHScore?: Maybe<Int>;
}

export interface GameweekUpsertWithoutFixturesInput {
  update: GameweekUpdateWithoutFixturesDataInput;
  create: GameweekCreateWithoutFixturesInput;
}

export interface FandemSubscriptionUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface FixtureUpsertWithoutTeamHInput {
  update: FixtureUpdateWithoutTeamHDataInput;
  create: FixtureCreateWithoutTeamHInput;
}

export interface CountryUpdateManyMutationInput {
  iso?: Maybe<String>;
  name?: Maybe<String>;
  code?: Maybe<String>;
}

export interface HomeTeamFixtureUpsertWithWhereUniqueWithoutHomeTeamInput {
  where: HomeTeamFixtureWhereUniqueInput;
  update: HomeTeamFixtureUpdateWithoutHomeTeamDataInput;
  create: HomeTeamFixtureCreateWithoutHomeTeamInput;
}

export interface AwayTeamFixtureUpdateInput {
  fixture?: Maybe<FixtureUpdateOneRequiredWithoutTeamAInput>;
  awayTeam?: Maybe<TeamUpdateOneRequiredWithoutAwayFixturesInput>;
}

export interface HomeTeamFixtureScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    HomeTeamFixtureScalarWhereInput[] | HomeTeamFixtureScalarWhereInput
  >;
  OR?: Maybe<
    HomeTeamFixtureScalarWhereInput[] | HomeTeamFixtureScalarWhereInput
  >;
  NOT?: Maybe<
    HomeTeamFixtureScalarWhereInput[] | HomeTeamFixtureScalarWhereInput
  >;
}

export interface AwayTeamFixtureCreateInput {
  id?: Maybe<ID_Input>;
  fixture: FixtureCreateOneWithoutTeamAInput;
  awayTeam: TeamCreateOneWithoutAwayFixturesInput;
}

export interface TeamUpsertWithoutAwayFixturesInput {
  update: TeamUpdateWithoutAwayFixturesDataInput;
  create: TeamCreateWithoutAwayFixturesInput;
}

export interface UserRoleUpsertNestedInput {
  update: UserRoleUpdateDataInput;
  create: UserRoleCreateInput;
}

export interface AwayTeamFixtureUpsertWithoutFixtureInput {
  update: AwayTeamFixtureUpdateWithoutFixtureDataInput;
  create: AwayTeamFixtureCreateWithoutFixtureInput;
}

export interface ActiveSubscriptionsCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  subscription: UserRoleCreateOneInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  name: String;
  countryCode?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  favoriteTeam?: Maybe<TeamCreateOneInput>;
  country?: Maybe<CountryCreateOneInput>;
  displayName: String;
  isPrivate?: Maybe<Boolean>;
  password: String;
  photos?: Maybe<UserPhotoCreateManyWithoutUserInput>;
  emailValidationToken?: Maybe<String>;
  emailValidationTokenExpiry?: Maybe<Float>;
  emailValidated?: Maybe<Boolean>;
  emailValidationDate?: Maybe<DateTimeInput>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  subscriptions?: Maybe<FandemSubscriptionCreateManyInput>;
  userRoles?: Maybe<UserRoleCreateManyInput>;
  status?: Maybe<UserStatusCreateManyInput>;
  followers?: Maybe<UserFollowersCreateOneWithoutUserInput>;
  influencers?: Maybe<UserInfluencersCreateOneWithoutUserInput>;
}

export interface HomeTeamFixtureUpdateWithoutFixtureDataInput {
  homeTeam?: Maybe<TeamUpdateOneRequiredWithoutHomeFixturesInput>;
}

export interface TeamCreateInput {
  id?: Maybe<ID_Input>;
  code: Int;
  season: SeasonCreateOneInput;
  fplTeamId: Int;
  name: String;
  shortName: String;
  strength: Int;
  strengthAttackAway: Int;
  strengthAttackHome: Int;
  strengthDefenceAway: Int;
  strengthDefenceHome: Int;
  strengthOverallAway: Int;
  strengthOverallHome: Int;
  teamDivision?: Maybe<Int>;
  homeFixtures?: Maybe<HomeTeamFixtureCreateManyWithoutHomeTeamInput>;
  awayFixtures?: Maybe<AwayTeamFixtureCreateManyWithoutAwayTeamInput>;
}

export interface TeamUpdateOneRequiredWithoutHomeFixturesInput {
  create?: Maybe<TeamCreateWithoutHomeFixturesInput>;
  update?: Maybe<TeamUpdateWithoutHomeFixturesDataInput>;
  upsert?: Maybe<TeamUpsertWithoutHomeFixturesInput>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface SeasonCreateInput {
  id?: Maybe<ID_Input>;
  fplId: Int;
  label: String;
  competition: String;
  startYear: Int;
  endYear: Int;
  isCurrent: Boolean;
  isPrevious: Boolean;
  isNext: Boolean;
  events?: Maybe<GameweekCreateManyWithoutSeasonInput>;
}

export interface TeamUpdateWithoutHomeFixturesDataInput {
  code?: Maybe<Int>;
  season?: Maybe<SeasonUpdateOneRequiredInput>;
  fplTeamId?: Maybe<Int>;
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  strength?: Maybe<Int>;
  strengthAttackAway?: Maybe<Int>;
  strengthAttackHome?: Maybe<Int>;
  strengthDefenceAway?: Maybe<Int>;
  strengthDefenceHome?: Maybe<Int>;
  strengthOverallAway?: Maybe<Int>;
  strengthOverallHome?: Maybe<Int>;
  teamDivision?: Maybe<Int>;
  awayFixtures?: Maybe<AwayTeamFixtureUpdateManyWithoutAwayTeamInput>;
}

export interface GameweekCreateWithoutSeasonInput {
  id?: Maybe<ID_Input>;
  averageEntryScore?: Maybe<Int>;
  dataChecked: Boolean;
  deadlineTime: DateTimeInput;
  deadlineTimeEpoch: Int;
  deadlineTimeGameOffset: Int;
  finished: Boolean;
  highestScore?: Maybe<Int>;
  highestScoringEntry?: Maybe<Int>;
  fplEventId: Int;
  isCurrent: Boolean;
  isNext: Boolean;
  isPrevious: Boolean;
  name: String;
  fixtures?: Maybe<FixtureCreateManyWithoutEventInput>;
}

export interface AwayTeamFixtureUpdateManyWithoutAwayTeamInput {
  create?: Maybe<
    | AwayTeamFixtureCreateWithoutAwayTeamInput[]
    | AwayTeamFixtureCreateWithoutAwayTeamInput
  >;
  delete?: Maybe<
    AwayTeamFixtureWhereUniqueInput[] | AwayTeamFixtureWhereUniqueInput
  >;
  connect?: Maybe<
    AwayTeamFixtureWhereUniqueInput[] | AwayTeamFixtureWhereUniqueInput
  >;
  set?: Maybe<
    AwayTeamFixtureWhereUniqueInput[] | AwayTeamFixtureWhereUniqueInput
  >;
  disconnect?: Maybe<
    AwayTeamFixtureWhereUniqueInput[] | AwayTeamFixtureWhereUniqueInput
  >;
  update?: Maybe<
    | AwayTeamFixtureUpdateWithWhereUniqueWithoutAwayTeamInput[]
    | AwayTeamFixtureUpdateWithWhereUniqueWithoutAwayTeamInput
  >;
  upsert?: Maybe<
    | AwayTeamFixtureUpsertWithWhereUniqueWithoutAwayTeamInput[]
    | AwayTeamFixtureUpsertWithWhereUniqueWithoutAwayTeamInput
  >;
  deleteMany?: Maybe<
    AwayTeamFixtureScalarWhereInput[] | AwayTeamFixtureScalarWhereInput
  >;
}

export interface FixtureCreateWithoutEventInput {
  id?: Maybe<ID_Input>;
  fplCode: Int;
  finished: Boolean;
  finishedProvisional: Boolean;
  fixtureId: Int;
  kickoffTime?: Maybe<DateTimeInput>;
  minutes: Int;
  provisionalStartTime: Boolean;
  started: Boolean;
  teamA: AwayTeamFixtureCreateOneWithoutFixtureInput;
  teamADifficulty: Int;
  teamAScore?: Maybe<Int>;
  teamH: HomeTeamFixtureCreateOneWithoutFixtureInput;
  teamHDifficulty: Int;
  teamHScore?: Maybe<Int>;
}

export interface AwayTeamFixtureUpdateWithWhereUniqueWithoutAwayTeamInput {
  where: AwayTeamFixtureWhereUniqueInput;
  data: AwayTeamFixtureUpdateWithoutAwayTeamDataInput;
}

export interface AwayTeamFixtureCreateWithoutFixtureInput {
  id?: Maybe<ID_Input>;
  awayTeam: TeamCreateOneWithoutAwayFixturesInput;
}

export interface AwayTeamFixtureUpdateWithoutAwayTeamDataInput {
  fixture?: Maybe<FixtureUpdateOneRequiredWithoutTeamAInput>;
}

export interface TeamCreateWithoutAwayFixturesInput {
  id?: Maybe<ID_Input>;
  code: Int;
  season: SeasonCreateOneInput;
  fplTeamId: Int;
  name: String;
  shortName: String;
  strength: Int;
  strengthAttackAway: Int;
  strengthAttackHome: Int;
  strengthDefenceAway: Int;
  strengthDefenceHome: Int;
  strengthOverallAway: Int;
  strengthOverallHome: Int;
  teamDivision?: Maybe<Int>;
  homeFixtures?: Maybe<HomeTeamFixtureCreateManyWithoutHomeTeamInput>;
}

export interface FixtureUpdateOneRequiredWithoutTeamAInput {
  create?: Maybe<FixtureCreateWithoutTeamAInput>;
  update?: Maybe<FixtureUpdateWithoutTeamADataInput>;
  upsert?: Maybe<FixtureUpsertWithoutTeamAInput>;
  connect?: Maybe<FixtureWhereUniqueInput>;
}

export interface HomeTeamFixtureCreateWithoutHomeTeamInput {
  id?: Maybe<ID_Input>;
  fixture: FixtureCreateOneWithoutTeamHInput;
}

export interface FixtureUpdateWithoutTeamADataInput {
  fplCode?: Maybe<Int>;
  event?: Maybe<GameweekUpdateOneRequiredWithoutFixturesInput>;
  finished?: Maybe<Boolean>;
  finishedProvisional?: Maybe<Boolean>;
  fixtureId?: Maybe<Int>;
  kickoffTime?: Maybe<DateTimeInput>;
  minutes?: Maybe<Int>;
  provisionalStartTime?: Maybe<Boolean>;
  started?: Maybe<Boolean>;
  teamADifficulty?: Maybe<Int>;
  teamAScore?: Maybe<Int>;
  teamH?: Maybe<HomeTeamFixtureUpdateOneRequiredWithoutFixtureInput>;
  teamHDifficulty?: Maybe<Int>;
  teamHScore?: Maybe<Int>;
}

export interface FixtureCreateWithoutTeamHInput {
  id?: Maybe<ID_Input>;
  fplCode: Int;
  event: GameweekCreateOneWithoutFixturesInput;
  finished: Boolean;
  finishedProvisional: Boolean;
  fixtureId: Int;
  kickoffTime?: Maybe<DateTimeInput>;
  minutes: Int;
  provisionalStartTime: Boolean;
  started: Boolean;
  teamA: AwayTeamFixtureCreateOneWithoutFixtureInput;
  teamADifficulty: Int;
  teamAScore?: Maybe<Int>;
  teamHDifficulty: Int;
  teamHScore?: Maybe<Int>;
}

export interface FixtureUpsertWithoutTeamAInput {
  update: FixtureUpdateWithoutTeamADataInput;
  create: FixtureCreateWithoutTeamAInput;
}

export interface GameweekCreateWithoutFixturesInput {
  id?: Maybe<ID_Input>;
  season: SeasonCreateOneWithoutEventsInput;
  averageEntryScore?: Maybe<Int>;
  dataChecked: Boolean;
  deadlineTime: DateTimeInput;
  deadlineTimeEpoch: Int;
  deadlineTimeGameOffset: Int;
  finished: Boolean;
  highestScore?: Maybe<Int>;
  highestScoringEntry?: Maybe<Int>;
  fplEventId: Int;
  isCurrent: Boolean;
  isNext: Boolean;
  isPrevious: Boolean;
  name: String;
}

export interface AwayTeamFixtureUpsertWithWhereUniqueWithoutAwayTeamInput {
  where: AwayTeamFixtureWhereUniqueInput;
  update: AwayTeamFixtureUpdateWithoutAwayTeamDataInput;
  create: AwayTeamFixtureCreateWithoutAwayTeamInput;
}

export interface SeasonCreateWithoutEventsInput {
  id?: Maybe<ID_Input>;
  fplId: Int;
  label: String;
  competition: String;
  startYear: Int;
  endYear: Int;
  isCurrent: Boolean;
  isPrevious: Boolean;
  isNext: Boolean;
}

export interface AwayTeamFixtureScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    AwayTeamFixtureScalarWhereInput[] | AwayTeamFixtureScalarWhereInput
  >;
  OR?: Maybe<
    AwayTeamFixtureScalarWhereInput[] | AwayTeamFixtureScalarWhereInput
  >;
  NOT?: Maybe<
    AwayTeamFixtureScalarWhereInput[] | AwayTeamFixtureScalarWhereInput
  >;
}

export interface UserPhotoWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  photo?: Maybe<PhotoWhereInput>;
  isProfile?: Maybe<Boolean>;
  isProfile_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserPhotoWhereInput[] | UserPhotoWhereInput>;
  OR?: Maybe<UserPhotoWhereInput[] | UserPhotoWhereInput>;
  NOT?: Maybe<UserPhotoWhereInput[] | UserPhotoWhereInput>;
}

export interface TeamUpsertWithoutHomeFixturesInput {
  update: TeamUpdateWithoutHomeFixturesDataInput;
  create: TeamCreateWithoutHomeFixturesInput;
}

export interface FandemSubscriptionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FandemSubscriptionWhereInput[] | FandemSubscriptionWhereInput>;
  OR?: Maybe<FandemSubscriptionWhereInput[] | FandemSubscriptionWhereInput>;
  NOT?: Maybe<FandemSubscriptionWhereInput[] | FandemSubscriptionWhereInput>;
}

export interface HomeTeamFixtureUpsertWithoutFixtureInput {
  update: HomeTeamFixtureUpdateWithoutFixtureDataInput;
  create: HomeTeamFixtureCreateWithoutFixtureInput;
}

export interface UserFollowersWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  followers_every?: Maybe<FollowerWhereInput>;
  followers_some?: Maybe<FollowerWhereInput>;
  followers_none?: Maybe<FollowerWhereInput>;
  user?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserFollowersWhereInput[] | UserFollowersWhereInput>;
  OR?: Maybe<UserFollowersWhereInput[] | UserFollowersWhereInput>;
  NOT?: Maybe<UserFollowersWhereInput[] | UserFollowersWhereInput>;
}

export interface FixtureUpsertWithWhereUniqueWithoutEventInput {
  where: FixtureWhereUniqueInput;
  update: FixtureUpdateWithoutEventDataInput;
  create: FixtureCreateWithoutEventInput;
}

export interface PhotoWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  largeImage?: Maybe<String>;
  largeImage_not?: Maybe<String>;
  largeImage_in?: Maybe<String[] | String>;
  largeImage_not_in?: Maybe<String[] | String>;
  largeImage_lt?: Maybe<String>;
  largeImage_lte?: Maybe<String>;
  largeImage_gt?: Maybe<String>;
  largeImage_gte?: Maybe<String>;
  largeImage_contains?: Maybe<String>;
  largeImage_not_contains?: Maybe<String>;
  largeImage_starts_with?: Maybe<String>;
  largeImage_not_starts_with?: Maybe<String>;
  largeImage_ends_with?: Maybe<String>;
  largeImage_not_ends_with?: Maybe<String>;
  smallImage?: Maybe<String>;
  smallImage_not?: Maybe<String>;
  smallImage_in?: Maybe<String[] | String>;
  smallImage_not_in?: Maybe<String[] | String>;
  smallImage_lt?: Maybe<String>;
  smallImage_lte?: Maybe<String>;
  smallImage_gt?: Maybe<String>;
  smallImage_gte?: Maybe<String>;
  smallImage_contains?: Maybe<String>;
  smallImage_not_contains?: Maybe<String>;
  smallImage_starts_with?: Maybe<String>;
  smallImage_not_starts_with?: Maybe<String>;
  smallImage_ends_with?: Maybe<String>;
  smallImage_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PhotoWhereInput[] | PhotoWhereInput>;
  OR?: Maybe<PhotoWhereInput[] | PhotoWhereInput>;
  NOT?: Maybe<PhotoWhereInput[] | PhotoWhereInput>;
}

export interface FixtureScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fplCode?: Maybe<Int>;
  fplCode_not?: Maybe<Int>;
  fplCode_in?: Maybe<Int[] | Int>;
  fplCode_not_in?: Maybe<Int[] | Int>;
  fplCode_lt?: Maybe<Int>;
  fplCode_lte?: Maybe<Int>;
  fplCode_gt?: Maybe<Int>;
  fplCode_gte?: Maybe<Int>;
  finished?: Maybe<Boolean>;
  finished_not?: Maybe<Boolean>;
  finishedProvisional?: Maybe<Boolean>;
  finishedProvisional_not?: Maybe<Boolean>;
  fixtureId?: Maybe<Int>;
  fixtureId_not?: Maybe<Int>;
  fixtureId_in?: Maybe<Int[] | Int>;
  fixtureId_not_in?: Maybe<Int[] | Int>;
  fixtureId_lt?: Maybe<Int>;
  fixtureId_lte?: Maybe<Int>;
  fixtureId_gt?: Maybe<Int>;
  fixtureId_gte?: Maybe<Int>;
  kickoffTime?: Maybe<DateTimeInput>;
  kickoffTime_not?: Maybe<DateTimeInput>;
  kickoffTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  kickoffTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  kickoffTime_lt?: Maybe<DateTimeInput>;
  kickoffTime_lte?: Maybe<DateTimeInput>;
  kickoffTime_gt?: Maybe<DateTimeInput>;
  kickoffTime_gte?: Maybe<DateTimeInput>;
  minutes?: Maybe<Int>;
  minutes_not?: Maybe<Int>;
  minutes_in?: Maybe<Int[] | Int>;
  minutes_not_in?: Maybe<Int[] | Int>;
  minutes_lt?: Maybe<Int>;
  minutes_lte?: Maybe<Int>;
  minutes_gt?: Maybe<Int>;
  minutes_gte?: Maybe<Int>;
  provisionalStartTime?: Maybe<Boolean>;
  provisionalStartTime_not?: Maybe<Boolean>;
  started?: Maybe<Boolean>;
  started_not?: Maybe<Boolean>;
  teamADifficulty?: Maybe<Int>;
  teamADifficulty_not?: Maybe<Int>;
  teamADifficulty_in?: Maybe<Int[] | Int>;
  teamADifficulty_not_in?: Maybe<Int[] | Int>;
  teamADifficulty_lt?: Maybe<Int>;
  teamADifficulty_lte?: Maybe<Int>;
  teamADifficulty_gt?: Maybe<Int>;
  teamADifficulty_gte?: Maybe<Int>;
  teamAScore?: Maybe<Int>;
  teamAScore_not?: Maybe<Int>;
  teamAScore_in?: Maybe<Int[] | Int>;
  teamAScore_not_in?: Maybe<Int[] | Int>;
  teamAScore_lt?: Maybe<Int>;
  teamAScore_lte?: Maybe<Int>;
  teamAScore_gt?: Maybe<Int>;
  teamAScore_gte?: Maybe<Int>;
  teamHDifficulty?: Maybe<Int>;
  teamHDifficulty_not?: Maybe<Int>;
  teamHDifficulty_in?: Maybe<Int[] | Int>;
  teamHDifficulty_not_in?: Maybe<Int[] | Int>;
  teamHDifficulty_lt?: Maybe<Int>;
  teamHDifficulty_lte?: Maybe<Int>;
  teamHDifficulty_gt?: Maybe<Int>;
  teamHDifficulty_gte?: Maybe<Int>;
  teamHScore?: Maybe<Int>;
  teamHScore_not?: Maybe<Int>;
  teamHScore_in?: Maybe<Int[] | Int>;
  teamHScore_not_in?: Maybe<Int[] | Int>;
  teamHScore_lt?: Maybe<Int>;
  teamHScore_lte?: Maybe<Int>;
  teamHScore_gt?: Maybe<Int>;
  teamHScore_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FixtureScalarWhereInput[] | FixtureScalarWhereInput>;
  OR?: Maybe<FixtureScalarWhereInput[] | FixtureScalarWhereInput>;
  NOT?: Maybe<FixtureScalarWhereInput[] | FixtureScalarWhereInput>;
}

export interface UserFollowersSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserFollowersWhereInput>;
  AND?: Maybe<
    UserFollowersSubscriptionWhereInput[] | UserFollowersSubscriptionWhereInput
  >;
  OR?: Maybe<
    UserFollowersSubscriptionWhereInput[] | UserFollowersSubscriptionWhereInput
  >;
  NOT?: Maybe<
    UserFollowersSubscriptionWhereInput[] | UserFollowersSubscriptionWhereInput
  >;
}

export interface FixtureUpdateManyWithWhereNestedInput {
  where: FixtureScalarWhereInput;
  data: FixtureUpdateManyDataInput;
}

export interface HomeTeamFixtureWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fixture?: Maybe<FixtureWhereInput>;
  homeTeam?: Maybe<TeamWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<HomeTeamFixtureWhereInput[] | HomeTeamFixtureWhereInput>;
  OR?: Maybe<HomeTeamFixtureWhereInput[] | HomeTeamFixtureWhereInput>;
  NOT?: Maybe<HomeTeamFixtureWhereInput[] | HomeTeamFixtureWhereInput>;
}

export interface FixtureUpdateManyDataInput {
  fplCode?: Maybe<Int>;
  finished?: Maybe<Boolean>;
  finishedProvisional?: Maybe<Boolean>;
  fixtureId?: Maybe<Int>;
  kickoffTime?: Maybe<DateTimeInput>;
  minutes?: Maybe<Int>;
  provisionalStartTime?: Maybe<Boolean>;
  started?: Maybe<Boolean>;
  teamADifficulty?: Maybe<Int>;
  teamAScore?: Maybe<Int>;
  teamHDifficulty?: Maybe<Int>;
  teamHScore?: Maybe<Int>;
}

export interface PhotoSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PhotoWhereInput>;
  AND?: Maybe<PhotoSubscriptionWhereInput[] | PhotoSubscriptionWhereInput>;
  OR?: Maybe<PhotoSubscriptionWhereInput[] | PhotoSubscriptionWhereInput>;
  NOT?: Maybe<PhotoSubscriptionWhereInput[] | PhotoSubscriptionWhereInput>;
}

export interface GameweekUpsertWithWhereUniqueWithoutSeasonInput {
  where: GameweekWhereUniqueInput;
  update: GameweekUpdateWithoutSeasonDataInput;
  create: GameweekCreateWithoutSeasonInput;
}

export interface FixtureWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fplCode?: Maybe<Int>;
  fplCode_not?: Maybe<Int>;
  fplCode_in?: Maybe<Int[] | Int>;
  fplCode_not_in?: Maybe<Int[] | Int>;
  fplCode_lt?: Maybe<Int>;
  fplCode_lte?: Maybe<Int>;
  fplCode_gt?: Maybe<Int>;
  fplCode_gte?: Maybe<Int>;
  event?: Maybe<GameweekWhereInput>;
  finished?: Maybe<Boolean>;
  finished_not?: Maybe<Boolean>;
  finishedProvisional?: Maybe<Boolean>;
  finishedProvisional_not?: Maybe<Boolean>;
  fixtureId?: Maybe<Int>;
  fixtureId_not?: Maybe<Int>;
  fixtureId_in?: Maybe<Int[] | Int>;
  fixtureId_not_in?: Maybe<Int[] | Int>;
  fixtureId_lt?: Maybe<Int>;
  fixtureId_lte?: Maybe<Int>;
  fixtureId_gt?: Maybe<Int>;
  fixtureId_gte?: Maybe<Int>;
  kickoffTime?: Maybe<DateTimeInput>;
  kickoffTime_not?: Maybe<DateTimeInput>;
  kickoffTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  kickoffTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  kickoffTime_lt?: Maybe<DateTimeInput>;
  kickoffTime_lte?: Maybe<DateTimeInput>;
  kickoffTime_gt?: Maybe<DateTimeInput>;
  kickoffTime_gte?: Maybe<DateTimeInput>;
  minutes?: Maybe<Int>;
  minutes_not?: Maybe<Int>;
  minutes_in?: Maybe<Int[] | Int>;
  minutes_not_in?: Maybe<Int[] | Int>;
  minutes_lt?: Maybe<Int>;
  minutes_lte?: Maybe<Int>;
  minutes_gt?: Maybe<Int>;
  minutes_gte?: Maybe<Int>;
  provisionalStartTime?: Maybe<Boolean>;
  provisionalStartTime_not?: Maybe<Boolean>;
  started?: Maybe<Boolean>;
  started_not?: Maybe<Boolean>;
  teamA?: Maybe<AwayTeamFixtureWhereInput>;
  teamADifficulty?: Maybe<Int>;
  teamADifficulty_not?: Maybe<Int>;
  teamADifficulty_in?: Maybe<Int[] | Int>;
  teamADifficulty_not_in?: Maybe<Int[] | Int>;
  teamADifficulty_lt?: Maybe<Int>;
  teamADifficulty_lte?: Maybe<Int>;
  teamADifficulty_gt?: Maybe<Int>;
  teamADifficulty_gte?: Maybe<Int>;
  teamAScore?: Maybe<Int>;
  teamAScore_not?: Maybe<Int>;
  teamAScore_in?: Maybe<Int[] | Int>;
  teamAScore_not_in?: Maybe<Int[] | Int>;
  teamAScore_lt?: Maybe<Int>;
  teamAScore_lte?: Maybe<Int>;
  teamAScore_gt?: Maybe<Int>;
  teamAScore_gte?: Maybe<Int>;
  teamH?: Maybe<HomeTeamFixtureWhereInput>;
  teamHDifficulty?: Maybe<Int>;
  teamHDifficulty_not?: Maybe<Int>;
  teamHDifficulty_in?: Maybe<Int[] | Int>;
  teamHDifficulty_not_in?: Maybe<Int[] | Int>;
  teamHDifficulty_lt?: Maybe<Int>;
  teamHDifficulty_lte?: Maybe<Int>;
  teamHDifficulty_gt?: Maybe<Int>;
  teamHDifficulty_gte?: Maybe<Int>;
  teamHScore?: Maybe<Int>;
  teamHScore_not?: Maybe<Int>;
  teamHScore_in?: Maybe<Int[] | Int>;
  teamHScore_not_in?: Maybe<Int[] | Int>;
  teamHScore_lt?: Maybe<Int>;
  teamHScore_lte?: Maybe<Int>;
  teamHScore_gt?: Maybe<Int>;
  teamHScore_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FixtureWhereInput[] | FixtureWhereInput>;
  OR?: Maybe<FixtureWhereInput[] | FixtureWhereInput>;
  NOT?: Maybe<FixtureWhereInput[] | FixtureWhereInput>;
}

export interface GameweekScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  averageEntryScore?: Maybe<Int>;
  averageEntryScore_not?: Maybe<Int>;
  averageEntryScore_in?: Maybe<Int[] | Int>;
  averageEntryScore_not_in?: Maybe<Int[] | Int>;
  averageEntryScore_lt?: Maybe<Int>;
  averageEntryScore_lte?: Maybe<Int>;
  averageEntryScore_gt?: Maybe<Int>;
  averageEntryScore_gte?: Maybe<Int>;
  dataChecked?: Maybe<Boolean>;
  dataChecked_not?: Maybe<Boolean>;
  deadlineTime?: Maybe<DateTimeInput>;
  deadlineTime_not?: Maybe<DateTimeInput>;
  deadlineTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deadlineTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deadlineTime_lt?: Maybe<DateTimeInput>;
  deadlineTime_lte?: Maybe<DateTimeInput>;
  deadlineTime_gt?: Maybe<DateTimeInput>;
  deadlineTime_gte?: Maybe<DateTimeInput>;
  deadlineTimeEpoch?: Maybe<Int>;
  deadlineTimeEpoch_not?: Maybe<Int>;
  deadlineTimeEpoch_in?: Maybe<Int[] | Int>;
  deadlineTimeEpoch_not_in?: Maybe<Int[] | Int>;
  deadlineTimeEpoch_lt?: Maybe<Int>;
  deadlineTimeEpoch_lte?: Maybe<Int>;
  deadlineTimeEpoch_gt?: Maybe<Int>;
  deadlineTimeEpoch_gte?: Maybe<Int>;
  deadlineTimeGameOffset?: Maybe<Int>;
  deadlineTimeGameOffset_not?: Maybe<Int>;
  deadlineTimeGameOffset_in?: Maybe<Int[] | Int>;
  deadlineTimeGameOffset_not_in?: Maybe<Int[] | Int>;
  deadlineTimeGameOffset_lt?: Maybe<Int>;
  deadlineTimeGameOffset_lte?: Maybe<Int>;
  deadlineTimeGameOffset_gt?: Maybe<Int>;
  deadlineTimeGameOffset_gte?: Maybe<Int>;
  finished?: Maybe<Boolean>;
  finished_not?: Maybe<Boolean>;
  highestScore?: Maybe<Int>;
  highestScore_not?: Maybe<Int>;
  highestScore_in?: Maybe<Int[] | Int>;
  highestScore_not_in?: Maybe<Int[] | Int>;
  highestScore_lt?: Maybe<Int>;
  highestScore_lte?: Maybe<Int>;
  highestScore_gt?: Maybe<Int>;
  highestScore_gte?: Maybe<Int>;
  highestScoringEntry?: Maybe<Int>;
  highestScoringEntry_not?: Maybe<Int>;
  highestScoringEntry_in?: Maybe<Int[] | Int>;
  highestScoringEntry_not_in?: Maybe<Int[] | Int>;
  highestScoringEntry_lt?: Maybe<Int>;
  highestScoringEntry_lte?: Maybe<Int>;
  highestScoringEntry_gt?: Maybe<Int>;
  highestScoringEntry_gte?: Maybe<Int>;
  fplEventId?: Maybe<Int>;
  fplEventId_not?: Maybe<Int>;
  fplEventId_in?: Maybe<Int[] | Int>;
  fplEventId_not_in?: Maybe<Int[] | Int>;
  fplEventId_lt?: Maybe<Int>;
  fplEventId_lte?: Maybe<Int>;
  fplEventId_gt?: Maybe<Int>;
  fplEventId_gte?: Maybe<Int>;
  isCurrent?: Maybe<Boolean>;
  isCurrent_not?: Maybe<Boolean>;
  isNext?: Maybe<Boolean>;
  isNext_not?: Maybe<Boolean>;
  isPrevious?: Maybe<Boolean>;
  isPrevious_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<GameweekScalarWhereInput[] | GameweekScalarWhereInput>;
  OR?: Maybe<GameweekScalarWhereInput[] | GameweekScalarWhereInput>;
  NOT?: Maybe<GameweekScalarWhereInput[] | GameweekScalarWhereInput>;
}

export interface FixtureSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FixtureWhereInput>;
  AND?: Maybe<FixtureSubscriptionWhereInput[] | FixtureSubscriptionWhereInput>;
  OR?: Maybe<FixtureSubscriptionWhereInput[] | FixtureSubscriptionWhereInput>;
  NOT?: Maybe<FixtureSubscriptionWhereInput[] | FixtureSubscriptionWhereInput>;
}

export interface GameweekUpdateManyWithWhereNestedInput {
  where: GameweekScalarWhereInput;
  data: GameweekUpdateManyDataInput;
}

export type AwayTeamFixtureWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GameweekUpdateManyDataInput {
  averageEntryScore?: Maybe<Int>;
  dataChecked?: Maybe<Boolean>;
  deadlineTime?: Maybe<DateTimeInput>;
  deadlineTimeEpoch?: Maybe<Int>;
  deadlineTimeGameOffset?: Maybe<Int>;
  finished?: Maybe<Boolean>;
  highestScore?: Maybe<Int>;
  highestScoringEntry?: Maybe<Int>;
  fplEventId?: Maybe<Int>;
  isCurrent?: Maybe<Boolean>;
  isNext?: Maybe<Boolean>;
  isPrevious?: Maybe<Boolean>;
  name?: Maybe<String>;
}

export type CountryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface SeasonUpsertNestedInput {
  update: SeasonUpdateDataInput;
  create: SeasonCreateInput;
}

export interface UserPhotoUpdateManyMutationInput {
  isProfile?: Maybe<Boolean>;
}

export interface TeamUpsertNestedInput {
  update: TeamUpdateDataInput;
  create: TeamCreateInput;
}

export interface UserUpdateOneRequiredWithoutPhotosInput {
  create?: Maybe<UserCreateWithoutPhotosInput>;
  update?: Maybe<UserUpdateWithoutPhotosDataInput>;
  upsert?: Maybe<UserUpsertWithoutPhotosInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CountryUpdateOneInput {
  create?: Maybe<CountryCreateInput>;
  update?: Maybe<CountryUpdateDataInput>;
  upsert?: Maybe<CountryUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CountryWhereUniqueInput>;
}

export interface UserCreateOneWithoutPhotosInput {
  create?: Maybe<UserCreateWithoutPhotosInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CountryUpdateDataInput {
  iso?: Maybe<String>;
  name?: Maybe<String>;
  code?: Maybe<String>;
}

export interface UserUpdateWithoutInfluencersDataInput {
  email?: Maybe<String>;
  name?: Maybe<String>;
  countryCode?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  favoriteTeam?: Maybe<TeamUpdateOneInput>;
  country?: Maybe<CountryUpdateOneInput>;
  displayName?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  password?: Maybe<String>;
  photos?: Maybe<UserPhotoUpdateManyWithoutUserInput>;
  emailValidationToken?: Maybe<String>;
  emailValidationTokenExpiry?: Maybe<Float>;
  emailValidated?: Maybe<Boolean>;
  emailValidationDate?: Maybe<DateTimeInput>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  subscriptions?: Maybe<FandemSubscriptionUpdateManyInput>;
  userRoles?: Maybe<UserRoleUpdateManyInput>;
  status?: Maybe<UserStatusUpdateManyInput>;
  followers?: Maybe<UserFollowersUpdateOneWithoutUserInput>;
}

export interface CountryUpsertNestedInput {
  update: CountryUpdateDataInput;
  create: CountryCreateInput;
}

export interface UserCreateWithoutInfluencersInput {
  id?: Maybe<ID_Input>;
  email: String;
  name: String;
  countryCode?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  favoriteTeam?: Maybe<TeamCreateOneInput>;
  country?: Maybe<CountryCreateOneInput>;
  displayName: String;
  isPrivate?: Maybe<Boolean>;
  password: String;
  photos?: Maybe<UserPhotoCreateManyWithoutUserInput>;
  emailValidationToken?: Maybe<String>;
  emailValidationTokenExpiry?: Maybe<Float>;
  emailValidated?: Maybe<Boolean>;
  emailValidationDate?: Maybe<DateTimeInput>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  subscriptions?: Maybe<FandemSubscriptionCreateManyInput>;
  userRoles?: Maybe<UserRoleCreateManyInput>;
  status?: Maybe<UserStatusCreateManyInput>;
  followers?: Maybe<UserFollowersCreateOneWithoutUserInput>;
}

export interface UserPhotoUpdateManyWithoutUserInput {
  create?: Maybe<
    UserPhotoCreateWithoutUserInput[] | UserPhotoCreateWithoutUserInput
  >;
  delete?: Maybe<UserPhotoWhereUniqueInput[] | UserPhotoWhereUniqueInput>;
  connect?: Maybe<UserPhotoWhereUniqueInput[] | UserPhotoWhereUniqueInput>;
  set?: Maybe<UserPhotoWhereUniqueInput[] | UserPhotoWhereUniqueInput>;
  disconnect?: Maybe<UserPhotoWhereUniqueInput[] | UserPhotoWhereUniqueInput>;
  update?: Maybe<
    | UserPhotoUpdateWithWhereUniqueWithoutUserInput[]
    | UserPhotoUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | UserPhotoUpsertWithWhereUniqueWithoutUserInput[]
    | UserPhotoUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<UserPhotoScalarWhereInput[] | UserPhotoScalarWhereInput>;
  updateMany?: Maybe<
    | UserPhotoUpdateManyWithWhereNestedInput[]
    | UserPhotoUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpsertWithoutFollowersInput {
  update: UserUpdateWithoutFollowersDataInput;
  create: UserCreateWithoutFollowersInput;
}

export interface UserPhotoUpdateWithWhereUniqueWithoutUserInput {
  where: UserPhotoWhereUniqueInput;
  data: UserPhotoUpdateWithoutUserDataInput;
}

export interface UserFollowersUpdateInput {
  followers?: Maybe<FollowerUpdateManyInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutFollowersInput>;
}

export interface UserPhotoUpdateWithoutUserDataInput {
  photo?: Maybe<PhotoUpdateOneRequiredInput>;
  isProfile?: Maybe<Boolean>;
}

export interface UserCreateOneWithoutFollowersInput {
  create?: Maybe<UserCreateWithoutFollowersInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface PhotoUpdateOneRequiredInput {
  create?: Maybe<PhotoCreateInput>;
  update?: Maybe<PhotoUpdateDataInput>;
  upsert?: Maybe<PhotoUpsertNestedInput>;
  connect?: Maybe<PhotoWhereUniqueInput>;
}

export interface UserAssignedRoleCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneInput;
  userRole: UserRoleCreateOneInput;
}

export interface PhotoUpdateDataInput {
  image?: Maybe<String>;
  largeImage?: Maybe<String>;
  smallImage?: Maybe<String>;
}

export interface TeamUpdateManyMutationInput {
  code?: Maybe<Int>;
  fplTeamId?: Maybe<Int>;
  name?: Maybe<String>;
  shortName?: Maybe<String>;
  strength?: Maybe<Int>;
  strengthAttackAway?: Maybe<Int>;
  strengthAttackHome?: Maybe<Int>;
  strengthDefenceAway?: Maybe<Int>;
  strengthDefenceHome?: Maybe<Int>;
  strengthOverallAway?: Maybe<Int>;
  strengthOverallHome?: Maybe<Int>;
  teamDivision?: Maybe<Int>;
}

export interface PhotoUpsertNestedInput {
  update: PhotoUpdateDataInput;
  create: PhotoCreateInput;
}

export type TeamWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  code?: Maybe<Int>;
}>;

export interface UserPhotoUpsertWithWhereUniqueWithoutUserInput {
  where: UserPhotoWhereUniqueInput;
  update: UserPhotoUpdateWithoutUserDataInput;
  create: UserPhotoCreateWithoutUserInput;
}

export interface UserStatusCreateWithoutStatusInput {
  id?: Maybe<ID_Input>;
  currentStatus?: Maybe<Boolean>;
}

export interface UserPhotoScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  isProfile?: Maybe<Boolean>;
  isProfile_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserPhotoScalarWhereInput[] | UserPhotoScalarWhereInput>;
  OR?: Maybe<UserPhotoScalarWhereInput[] | UserPhotoScalarWhereInput>;
  NOT?: Maybe<UserPhotoScalarWhereInput[] | UserPhotoScalarWhereInput>;
}

export interface SeasonUpdateManyMutationInput {
  fplId?: Maybe<Int>;
  label?: Maybe<String>;
  competition?: Maybe<String>;
  startYear?: Maybe<Int>;
  endYear?: Maybe<Int>;
  isCurrent?: Maybe<Boolean>;
  isPrevious?: Maybe<Boolean>;
  isNext?: Maybe<Boolean>;
}

export interface UserPhotoUpdateManyWithWhereNestedInput {
  where: UserPhotoScalarWhereInput;
  data: UserPhotoUpdateManyDataInput;
}

export interface PhotoUpdateManyMutationInput {
  image?: Maybe<String>;
  largeImage?: Maybe<String>;
  smallImage?: Maybe<String>;
}

export interface UserPhotoUpdateManyDataInput {
  isProfile?: Maybe<Boolean>;
}

export type UserFollowersWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FandemSubscriptionUpdateManyInput {
  create?: Maybe<
    FandemSubscriptionCreateInput[] | FandemSubscriptionCreateInput
  >;
  update?: Maybe<
    | FandemSubscriptionUpdateWithWhereUniqueNestedInput[]
    | FandemSubscriptionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | FandemSubscriptionUpsertWithWhereUniqueNestedInput[]
    | FandemSubscriptionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    FandemSubscriptionWhereUniqueInput[] | FandemSubscriptionWhereUniqueInput
  >;
  connect?: Maybe<
    FandemSubscriptionWhereUniqueInput[] | FandemSubscriptionWhereUniqueInput
  >;
  set?: Maybe<
    FandemSubscriptionWhereUniqueInput[] | FandemSubscriptionWhereUniqueInput
  >;
  disconnect?: Maybe<
    FandemSubscriptionWhereUniqueInput[] | FandemSubscriptionWhereUniqueInput
  >;
  deleteMany?: Maybe<
    FandemSubscriptionScalarWhereInput[] | FandemSubscriptionScalarWhereInput
  >;
  updateMany?: Maybe<
    | FandemSubscriptionUpdateManyWithWhereNestedInput[]
    | FandemSubscriptionUpdateManyWithWhereNestedInput
  >;
}

export interface GameweekCreateInput {
  id?: Maybe<ID_Input>;
  season: SeasonCreateOneWithoutEventsInput;
  averageEntryScore?: Maybe<Int>;
  dataChecked: Boolean;
  deadlineTime: DateTimeInput;
  deadlineTimeEpoch: Int;
  deadlineTimeGameOffset: Int;
  finished: Boolean;
  highestScore?: Maybe<Int>;
  highestScoringEntry?: Maybe<Int>;
  fplEventId: Int;
  isCurrent: Boolean;
  isNext: Boolean;
  isPrevious: Boolean;
  name: String;
  fixtures?: Maybe<FixtureCreateManyWithoutEventInput>;
}

export interface FandemSubscriptionUpdateWithWhereUniqueNestedInput {
  where: FandemSubscriptionWhereUniqueInput;
  data: FandemSubscriptionUpdateDataInput;
}

export interface FixtureUpdateManyMutationInput {
  fplCode?: Maybe<Int>;
  finished?: Maybe<Boolean>;
  finishedProvisional?: Maybe<Boolean>;
  fixtureId?: Maybe<Int>;
  kickoffTime?: Maybe<DateTimeInput>;
  minutes?: Maybe<Int>;
  provisionalStartTime?: Maybe<Boolean>;
  started?: Maybe<Boolean>;
  teamADifficulty?: Maybe<Int>;
  teamAScore?: Maybe<Int>;
  teamHDifficulty?: Maybe<Int>;
  teamHScore?: Maybe<Int>;
}

export interface FandemSubscriptionUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface FandemSubscriptionUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface FandemSubscriptionUpsertWithWhereUniqueNestedInput {
  where: FandemSubscriptionWhereUniqueInput;
  update: FandemSubscriptionUpdateDataInput;
  create: FandemSubscriptionCreateInput;
}

export interface CountryUpdateInput {
  iso?: Maybe<String>;
  name?: Maybe<String>;
  code?: Maybe<String>;
}

export interface FandemSubscriptionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    FandemSubscriptionScalarWhereInput[] | FandemSubscriptionScalarWhereInput
  >;
  OR?: Maybe<
    FandemSubscriptionScalarWhereInput[] | FandemSubscriptionScalarWhereInput
  >;
  NOT?: Maybe<
    FandemSubscriptionScalarWhereInput[] | FandemSubscriptionScalarWhereInput
  >;
}

export interface ActiveSubscriptionsUpdateManyMutationInput {
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
}

export interface FandemSubscriptionUpdateManyWithWhereNestedInput {
  where: FandemSubscriptionScalarWhereInput;
  data: FandemSubscriptionUpdateManyDataInput;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface FandemSubscriptionUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface SeasonCreateOneInput {
  create?: Maybe<SeasonCreateInput>;
  connect?: Maybe<SeasonWhereUniqueInput>;
}

export interface UserRoleUpdateManyInput {
  create?: Maybe<UserRoleCreateInput[] | UserRoleCreateInput>;
  update?: Maybe<
    | UserRoleUpdateWithWhereUniqueNestedInput[]
    | UserRoleUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | UserRoleUpsertWithWhereUniqueNestedInput[]
    | UserRoleUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<UserRoleWhereUniqueInput[] | UserRoleWhereUniqueInput>;
  connect?: Maybe<UserRoleWhereUniqueInput[] | UserRoleWhereUniqueInput>;
  set?: Maybe<UserRoleWhereUniqueInput[] | UserRoleWhereUniqueInput>;
  disconnect?: Maybe<UserRoleWhereUniqueInput[] | UserRoleWhereUniqueInput>;
  deleteMany?: Maybe<UserRoleScalarWhereInput[] | UserRoleScalarWhereInput>;
  updateMany?: Maybe<
    | UserRoleUpdateManyWithWhereNestedInput[]
    | UserRoleUpdateManyWithWhereNestedInput
  >;
}

export interface FixtureCreateManyWithoutEventInput {
  create?: Maybe<
    FixtureCreateWithoutEventInput[] | FixtureCreateWithoutEventInput
  >;
  connect?: Maybe<FixtureWhereUniqueInput[] | FixtureWhereUniqueInput>;
}

export interface UserRoleUpdateWithWhereUniqueNestedInput {
  where: UserRoleWhereUniqueInput;
  data: UserRoleUpdateDataInput;
}

export interface TeamCreateOneWithoutAwayFixturesInput {
  create?: Maybe<TeamCreateWithoutAwayFixturesInput>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface UserRoleUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface FixtureCreateOneWithoutTeamHInput {
  create?: Maybe<FixtureCreateWithoutTeamHInput>;
  connect?: Maybe<FixtureWhereUniqueInput>;
}

export interface UserRoleUpsertWithWhereUniqueNestedInput {
  where: UserRoleWhereUniqueInput;
  update: UserRoleUpdateDataInput;
  create: UserRoleCreateInput;
}

export interface SeasonCreateOneWithoutEventsInput {
  create?: Maybe<SeasonCreateWithoutEventsInput>;
  connect?: Maybe<SeasonWhereUniqueInput>;
}

export interface UserRoleScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserRoleScalarWhereInput[] | UserRoleScalarWhereInput>;
  OR?: Maybe<UserRoleScalarWhereInput[] | UserRoleScalarWhereInput>;
  NOT?: Maybe<UserRoleScalarWhereInput[] | UserRoleScalarWhereInput>;
}

export interface CountryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  iso?: Maybe<String>;
  iso_not?: Maybe<String>;
  iso_in?: Maybe<String[] | String>;
  iso_not_in?: Maybe<String[] | String>;
  iso_lt?: Maybe<String>;
  iso_lte?: Maybe<String>;
  iso_gt?: Maybe<String>;
  iso_gte?: Maybe<String>;
  iso_contains?: Maybe<String>;
  iso_not_contains?: Maybe<String>;
  iso_starts_with?: Maybe<String>;
  iso_not_starts_with?: Maybe<String>;
  iso_ends_with?: Maybe<String>;
  iso_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CountryWhereInput[] | CountryWhereInput>;
  OR?: Maybe<CountryWhereInput[] | CountryWhereInput>;
  NOT?: Maybe<CountryWhereInput[] | CountryWhereInput>;
}

export interface UserRoleUpdateManyWithWhereNestedInput {
  where: UserRoleScalarWhereInput;
  data: UserRoleUpdateManyDataInput;
}

export interface UserInfluencersWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  influencers_every?: Maybe<InfluencerWhereInput>;
  influencers_some?: Maybe<InfluencerWhereInput>;
  influencers_none?: Maybe<InfluencerWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserInfluencersWhereInput[] | UserInfluencersWhereInput>;
  OR?: Maybe<UserInfluencersWhereInput[] | UserInfluencersWhereInput>;
  NOT?: Maybe<UserInfluencersWhereInput[] | UserInfluencersWhereInput>;
}

export interface UserRoleUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface UserStatusUpdateManyInput {
  create?: Maybe<UserStatusCreateInput[] | UserStatusCreateInput>;
  update?: Maybe<
    | UserStatusUpdateWithWhereUniqueNestedInput[]
    | UserStatusUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | UserStatusUpsertWithWhereUniqueNestedInput[]
    | UserStatusUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<UserStatusWhereUniqueInput[] | UserStatusWhereUniqueInput>;
  connect?: Maybe<UserStatusWhereUniqueInput[] | UserStatusWhereUniqueInput>;
  set?: Maybe<UserStatusWhereUniqueInput[] | UserStatusWhereUniqueInput>;
  disconnect?: Maybe<UserStatusWhereUniqueInput[] | UserStatusWhereUniqueInput>;
  deleteMany?: Maybe<UserStatusScalarWhereInput[] | UserStatusScalarWhereInput>;
  updateMany?: Maybe<
    | UserStatusUpdateManyWithWhereNestedInput[]
    | UserStatusUpdateManyWithWhereNestedInput
  >;
}

export interface InfluencerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InfluencerWhereInput>;
  AND?: Maybe<
    InfluencerSubscriptionWhereInput[] | InfluencerSubscriptionWhereInput
  >;
  OR?: Maybe<
    InfluencerSubscriptionWhereInput[] | InfluencerSubscriptionWhereInput
  >;
  NOT?: Maybe<
    InfluencerSubscriptionWhereInput[] | InfluencerSubscriptionWhereInput
  >;
}

export interface UserStatusUpdateWithWhereUniqueNestedInput {
  where: UserStatusWhereUniqueInput;
  data: UserStatusUpdateDataInput;
}

export interface CountrySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CountryWhereInput>;
  AND?: Maybe<CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput>;
  OR?: Maybe<CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput>;
  NOT?: Maybe<CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput>;
}

export interface UserStatusUpdateDataInput {
  status?: Maybe<StatusUpdateOneWithoutAuthorInput>;
  currentStatus?: Maybe<Boolean>;
}

export interface UserRoleUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface StatusUpdateOneWithoutAuthorInput {
  create?: Maybe<StatusCreateWithoutAuthorInput>;
  update?: Maybe<StatusUpdateWithoutAuthorDataInput>;
  upsert?: Maybe<StatusUpsertWithoutAuthorInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<StatusWhereUniqueInput>;
}

export interface UserPhotoUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutPhotosInput>;
  photo?: Maybe<PhotoUpdateOneRequiredInput>;
  isProfile?: Maybe<Boolean>;
}

export interface StatusUpdateWithoutAuthorDataInput {
  content?: Maybe<String>;
  likes?: Maybe<UserUpdateManyInput>;
}

export interface UserUpdateOneRequiredWithoutInfluencersInput {
  create?: Maybe<UserCreateWithoutInfluencersInput>;
  update?: Maybe<UserUpdateWithoutInfluencersDataInput>;
  upsert?: Maybe<UserUpsertWithoutInfluencersInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithoutFollowersDataInput {
  email?: Maybe<String>;
  name?: Maybe<String>;
  countryCode?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  favoriteTeam?: Maybe<TeamUpdateOneInput>;
  country?: Maybe<CountryUpdateOneInput>;
  displayName?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  password?: Maybe<String>;
  photos?: Maybe<UserPhotoUpdateManyWithoutUserInput>;
  emailValidationToken?: Maybe<String>;
  emailValidationTokenExpiry?: Maybe<Float>;
  emailValidated?: Maybe<Boolean>;
  emailValidationDate?: Maybe<DateTimeInput>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  subscriptions?: Maybe<FandemSubscriptionUpdateManyInput>;
  userRoles?: Maybe<UserRoleUpdateManyInput>;
  status?: Maybe<UserStatusUpdateManyInput>;
  influencers?: Maybe<UserInfluencersUpdateOneWithoutUserInput>;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export type SeasonWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  fplId?: Maybe<Int>;
}>;

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface StatusUpdateManyMutationInput {
  content?: Maybe<String>;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  countryCode?: Maybe<String>;
  countryCode_not?: Maybe<String>;
  countryCode_in?: Maybe<String[] | String>;
  countryCode_not_in?: Maybe<String[] | String>;
  countryCode_lt?: Maybe<String>;
  countryCode_lte?: Maybe<String>;
  countryCode_gt?: Maybe<String>;
  countryCode_gte?: Maybe<String>;
  countryCode_contains?: Maybe<String>;
  countryCode_not_contains?: Maybe<String>;
  countryCode_starts_with?: Maybe<String>;
  countryCode_not_starts_with?: Maybe<String>;
  countryCode_ends_with?: Maybe<String>;
  countryCode_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  displayName?: Maybe<String>;
  displayName_not?: Maybe<String>;
  displayName_in?: Maybe<String[] | String>;
  displayName_not_in?: Maybe<String[] | String>;
  displayName_lt?: Maybe<String>;
  displayName_lte?: Maybe<String>;
  displayName_gt?: Maybe<String>;
  displayName_gte?: Maybe<String>;
  displayName_contains?: Maybe<String>;
  displayName_not_contains?: Maybe<String>;
  displayName_starts_with?: Maybe<String>;
  displayName_not_starts_with?: Maybe<String>;
  displayName_ends_with?: Maybe<String>;
  displayName_not_ends_with?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  isPrivate_not?: Maybe<Boolean>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  emailValidationToken?: Maybe<String>;
  emailValidationToken_not?: Maybe<String>;
  emailValidationToken_in?: Maybe<String[] | String>;
  emailValidationToken_not_in?: Maybe<String[] | String>;
  emailValidationToken_lt?: Maybe<String>;
  emailValidationToken_lte?: Maybe<String>;
  emailValidationToken_gt?: Maybe<String>;
  emailValidationToken_gte?: Maybe<String>;
  emailValidationToken_contains?: Maybe<String>;
  emailValidationToken_not_contains?: Maybe<String>;
  emailValidationToken_starts_with?: Maybe<String>;
  emailValidationToken_not_starts_with?: Maybe<String>;
  emailValidationToken_ends_with?: Maybe<String>;
  emailValidationToken_not_ends_with?: Maybe<String>;
  emailValidationTokenExpiry?: Maybe<Float>;
  emailValidationTokenExpiry_not?: Maybe<Float>;
  emailValidationTokenExpiry_in?: Maybe<Float[] | Float>;
  emailValidationTokenExpiry_not_in?: Maybe<Float[] | Float>;
  emailValidationTokenExpiry_lt?: Maybe<Float>;
  emailValidationTokenExpiry_lte?: Maybe<Float>;
  emailValidationTokenExpiry_gt?: Maybe<Float>;
  emailValidationTokenExpiry_gte?: Maybe<Float>;
  emailValidated?: Maybe<Boolean>;
  emailValidated_not?: Maybe<Boolean>;
  emailValidationDate?: Maybe<DateTimeInput>;
  emailValidationDate_not?: Maybe<DateTimeInput>;
  emailValidationDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  emailValidationDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  emailValidationDate_lt?: Maybe<DateTimeInput>;
  emailValidationDate_lte?: Maybe<DateTimeInput>;
  emailValidationDate_gt?: Maybe<DateTimeInput>;
  emailValidationDate_gte?: Maybe<DateTimeInput>;
  resetToken?: Maybe<String>;
  resetToken_not?: Maybe<String>;
  resetToken_in?: Maybe<String[] | String>;
  resetToken_not_in?: Maybe<String[] | String>;
  resetToken_lt?: Maybe<String>;
  resetToken_lte?: Maybe<String>;
  resetToken_gt?: Maybe<String>;
  resetToken_gte?: Maybe<String>;
  resetToken_contains?: Maybe<String>;
  resetToken_not_contains?: Maybe<String>;
  resetToken_starts_with?: Maybe<String>;
  resetToken_not_starts_with?: Maybe<String>;
  resetToken_ends_with?: Maybe<String>;
  resetToken_not_ends_with?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  resetTokenExpiry_not?: Maybe<Float>;
  resetTokenExpiry_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_not_in?: Maybe<Float[] | Float>;
  resetTokenExpiry_lt?: Maybe<Float>;
  resetTokenExpiry_lte?: Maybe<Float>;
  resetTokenExpiry_gt?: Maybe<Float>;
  resetTokenExpiry_gte?: Maybe<Float>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserStatusCreateOneWithoutStatusInput {
  create?: Maybe<UserStatusCreateWithoutStatusInput>;
  connect?: Maybe<UserStatusWhereUniqueInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface InfluencerUpdateInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
}

export interface UserUpdateManyDataInput {
  email?: Maybe<String>;
  name?: Maybe<String>;
  countryCode?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  displayName?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  password?: Maybe<String>;
  emailValidationToken?: Maybe<String>;
  emailValidationTokenExpiry?: Maybe<Float>;
  emailValidated?: Maybe<Boolean>;
  emailValidationDate?: Maybe<DateTimeInput>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
}

export interface FollowerUpdateManyMutationInput {
  blocked?: Maybe<Boolean>;
  accepted?: Maybe<Boolean>;
}

export interface StatusUpsertWithoutAuthorInput {
  update: StatusUpdateWithoutAuthorDataInput;
  create: StatusCreateWithoutAuthorInput;
}

export type UserRoleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserStatusUpsertWithWhereUniqueNestedInput {
  where: UserStatusWhereUniqueInput;
  update: UserStatusUpdateDataInput;
  create: UserStatusCreateInput;
}

export interface GameweekCreateManyWithoutSeasonInput {
  create?: Maybe<
    GameweekCreateWithoutSeasonInput[] | GameweekCreateWithoutSeasonInput
  >;
  connect?: Maybe<GameweekWhereUniqueInput[] | GameweekWhereUniqueInput>;
}

export interface UserStatusScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  currentStatus?: Maybe<Boolean>;
  currentStatus_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserStatusScalarWhereInput[] | UserStatusScalarWhereInput>;
  OR?: Maybe<UserStatusScalarWhereInput[] | UserStatusScalarWhereInput>;
  NOT?: Maybe<UserStatusScalarWhereInput[] | UserStatusScalarWhereInput>;
}

export interface HomeTeamFixtureCreateManyWithoutHomeTeamInput {
  create?: Maybe<
    | HomeTeamFixtureCreateWithoutHomeTeamInput[]
    | HomeTeamFixtureCreateWithoutHomeTeamInput
  >;
  connect?: Maybe<
    HomeTeamFixtureWhereUniqueInput[] | HomeTeamFixtureWhereUniqueInput
  >;
}

export interface UserStatusUpdateManyWithWhereNestedInput {
  where: UserStatusScalarWhereInput;
  data: UserStatusUpdateManyDataInput;
}

export interface HomeTeamFixtureCreateOneWithoutFixtureInput {
  create?: Maybe<HomeTeamFixtureCreateWithoutFixtureInput>;
  connect?: Maybe<HomeTeamFixtureWhereUniqueInput>;
}

export interface UserStatusUpdateManyDataInput {
  currentStatus?: Maybe<Boolean>;
}

export interface UserPhotoSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserPhotoWhereInput>;
  AND?: Maybe<
    UserPhotoSubscriptionWhereInput[] | UserPhotoSubscriptionWhereInput
  >;
  OR?: Maybe<
    UserPhotoSubscriptionWhereInput[] | UserPhotoSubscriptionWhereInput
  >;
  NOT?: Maybe<
    UserPhotoSubscriptionWhereInput[] | UserPhotoSubscriptionWhereInput
  >;
}

export interface UserFollowersUpdateOneWithoutUserInput {
  create?: Maybe<UserFollowersCreateWithoutUserInput>;
  update?: Maybe<UserFollowersUpdateWithoutUserDataInput>;
  upsert?: Maybe<UserFollowersUpsertWithoutUserInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserFollowersWhereUniqueInput>;
}

export interface ActiveSubscriptionsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  subscription?: Maybe<UserRoleWhereInput>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ActiveSubscriptionsWhereInput[] | ActiveSubscriptionsWhereInput>;
  OR?: Maybe<ActiveSubscriptionsWhereInput[] | ActiveSubscriptionsWhereInput>;
  NOT?: Maybe<ActiveSubscriptionsWhereInput[] | ActiveSubscriptionsWhereInput>;
}

export interface UserFollowersUpdateWithoutUserDataInput {
  followers?: Maybe<FollowerUpdateManyInput>;
}

export interface UserUpsertWithoutPhotosInput {
  update: UserUpdateWithoutPhotosDataInput;
  create: UserCreateWithoutPhotosInput;
}

export interface FollowerUpdateManyInput {
  create?: Maybe<FollowerCreateInput[] | FollowerCreateInput>;
  update?: Maybe<
    | FollowerUpdateWithWhereUniqueNestedInput[]
    | FollowerUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | FollowerUpsertWithWhereUniqueNestedInput[]
    | FollowerUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<FollowerWhereUniqueInput[] | FollowerWhereUniqueInput>;
  connect?: Maybe<FollowerWhereUniqueInput[] | FollowerWhereUniqueInput>;
  set?: Maybe<FollowerWhereUniqueInput[] | FollowerWhereUniqueInput>;
  disconnect?: Maybe<FollowerWhereUniqueInput[] | FollowerWhereUniqueInput>;
  deleteMany?: Maybe<FollowerScalarWhereInput[] | FollowerScalarWhereInput>;
  updateMany?: Maybe<
    | FollowerUpdateManyWithWhereNestedInput[]
    | FollowerUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateOneWithoutInfluencersInput {
  create?: Maybe<UserCreateWithoutInfluencersInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface FollowerUpdateWithWhereUniqueNestedInput {
  where: FollowerWhereUniqueInput;
  data: FollowerUpdateDataInput;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  name?: Maybe<String>;
  countryCode?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  favoriteTeam?: Maybe<TeamUpdateOneInput>;
  country?: Maybe<CountryUpdateOneInput>;
  displayName?: Maybe<String>;
  isPrivate?: Maybe<Boolean>;
  password?: Maybe<String>;
  photos?: Maybe<UserPhotoUpdateManyWithoutUserInput>;
  emailValidationToken?: Maybe<String>;
  emailValidationTokenExpiry?: Maybe<Float>;
  emailValidated?: Maybe<Boolean>;
  emailValidationDate?: Maybe<DateTimeInput>;
  resetToken?: Maybe<String>;
  resetTokenExpiry?: Maybe<Float>;
  subscriptions?: Maybe<FandemSubscriptionUpdateManyInput>;
  userRoles?: Maybe<UserRoleUpdateManyInput>;
  status?: Maybe<UserStatusUpdateManyInput>;
  followers?: Maybe<UserFollowersUpdateOneWithoutUserInput>;
  influencers?: Maybe<UserInfluencersUpdateOneWithoutUserInput>;
}

export interface FollowerUpdateDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
  blocked?: Maybe<Boolean>;
  accepted?: Maybe<Boolean>;
}

export interface SeasonUpdateInput {
  fplId?: Maybe<Int>;
  label?: Maybe<String>;
  competition?: Maybe<String>;
  startYear?: Maybe<Int>;
  endYear?: Maybe<Int>;
  isCurrent?: Maybe<Boolean>;
  isPrevious?: Maybe<Boolean>;
  isNext?: Maybe<Boolean>;
  events?: Maybe<GameweekUpdateManyWithoutSeasonInput>;
}

export interface FollowerUpsertWithWhereUniqueNestedInput {
  where: FollowerWhereUniqueInput;
  update: FollowerUpdateDataInput;
  create: FollowerCreateInput;
}

export type UserPhotoWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FollowerScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  blocked?: Maybe<Boolean>;
  blocked_not?: Maybe<Boolean>;
  accepted?: Maybe<Boolean>;
  accepted_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FollowerScalarWhereInput[] | FollowerScalarWhereInput>;
  OR?: Maybe<FollowerScalarWhereInput[] | FollowerScalarWhereInput>;
  NOT?: Maybe<FollowerScalarWhereInput[] | FollowerScalarWhereInput>;
}

export interface TeamCreateOneInput {
  create?: Maybe<TeamCreateInput>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface FollowerUpdateManyWithWhereNestedInput {
  where: FollowerScalarWhereInput;
  data: FollowerUpdateManyDataInput;
}

export interface GameweekCreateOneWithoutFixturesInput {
  create?: Maybe<GameweekCreateWithoutFixturesInput>;
  connect?: Maybe<GameweekWhereUniqueInput>;
}

export interface FollowerUpdateManyDataInput {
  blocked?: Maybe<Boolean>;
  accepted?: Maybe<Boolean>;
}

export interface SeasonSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SeasonWhereInput>;
  AND?: Maybe<SeasonSubscriptionWhereInput[] | SeasonSubscriptionWhereInput>;
  OR?: Maybe<SeasonSubscriptionWhereInput[] | SeasonSubscriptionWhereInput>;
  NOT?: Maybe<SeasonSubscriptionWhereInput[] | SeasonSubscriptionWhereInput>;
}

export interface UserFollowersUpsertWithoutUserInput {
  update: UserFollowersUpdateWithoutUserDataInput;
  create: UserFollowersCreateWithoutUserInput;
}

export interface UserPhotoCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutPhotosInput;
  photo: PhotoCreateOneInput;
  isProfile?: Maybe<Boolean>;
}

export interface UserInfluencersUpdateOneWithoutUserInput {
  create?: Maybe<UserInfluencersCreateWithoutUserInput>;
  update?: Maybe<UserInfluencersUpdateWithoutUserDataInput>;
  upsert?: Maybe<UserInfluencersUpsertWithoutUserInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserInfluencersWhereUniqueInput>;
}

export interface UserStatusUpdateOneWithoutStatusInput {
  create?: Maybe<UserStatusCreateWithoutStatusInput>;
  update?: Maybe<UserStatusUpdateWithoutStatusDataInput>;
  upsert?: Maybe<UserStatusUpsertWithoutStatusInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserStatusWhereUniqueInput>;
}

export interface UserInfluencersUpdateWithoutUserDataInput {
  influencers?: Maybe<InfluencerUpdateManyInput>;
}

export type UserStatusWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface InfluencerUpdateManyInput {
  create?: Maybe<InfluencerCreateInput[] | InfluencerCreateInput>;
  update?: Maybe<
    | InfluencerUpdateWithWhereUniqueNestedInput[]
    | InfluencerUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | InfluencerUpsertWithWhereUniqueNestedInput[]
    | InfluencerUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<InfluencerWhereUniqueInput[] | InfluencerWhereUniqueInput>;
  connect?: Maybe<InfluencerWhereUniqueInput[] | InfluencerWhereUniqueInput>;
  set?: Maybe<InfluencerWhereUniqueInput[] | InfluencerWhereUniqueInput>;
  disconnect?: Maybe<InfluencerWhereUniqueInput[] | InfluencerWhereUniqueInput>;
  deleteMany?: Maybe<InfluencerScalarWhereInput[] | InfluencerScalarWhereInput>;
}

export interface UserStatusWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  status?: Maybe<StatusWhereInput>;
  currentStatus?: Maybe<Boolean>;
  currentStatus_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserStatusWhereInput[] | UserStatusWhereInput>;
  OR?: Maybe<UserStatusWhereInput[] | UserStatusWhereInput>;
  NOT?: Maybe<UserStatusWhereInput[] | UserStatusWhereInput>;
}

export interface InfluencerScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<InfluencerScalarWhereInput[] | InfluencerScalarWhereInput>;
  OR?: Maybe<InfluencerScalarWhereInput[] | InfluencerScalarWhereInput>;
  NOT?: Maybe<InfluencerScalarWhereInput[] | InfluencerScalarWhereInput>;
}

export interface InfluencerUpsertWithWhereUniqueNestedInput {
  where: InfluencerWhereUniqueInput;
  update: InfluencerUpdateDataInput;
  create: InfluencerCreateInput;
}

export interface InfluencerUpdateDataInput {
  user?: Maybe<UserUpdateOneRequiredInput>;
}

export interface InfluencerUpdateWithWhereUniqueNestedInput {
  where: InfluencerWhereUniqueInput;
  data: InfluencerUpdateDataInput;
}

export interface UserStatusUpdateManyMutationInput {
  currentStatus?: Maybe<Boolean>;
}

export interface AwayTeamFixtureCreateOneWithoutFixtureInput {
  create?: Maybe<AwayTeamFixtureCreateWithoutFixtureInput>;
  connect?: Maybe<AwayTeamFixtureWhereUniqueInput>;
}

export interface GameweekUpdateManyMutationInput {
  averageEntryScore?: Maybe<Int>;
  dataChecked?: Maybe<Boolean>;
  deadlineTime?: Maybe<DateTimeInput>;
  deadlineTimeEpoch?: Maybe<Int>;
  deadlineTimeGameOffset?: Maybe<Int>;
  finished?: Maybe<Boolean>;
  highestScore?: Maybe<Int>;
  highestScoringEntry?: Maybe<Int>;
  fplEventId?: Maybe<Int>;
  isCurrent?: Maybe<Boolean>;
  isNext?: Maybe<Boolean>;
  isPrevious?: Maybe<Boolean>;
  name?: Maybe<String>;
}

export interface GameweekWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  season?: Maybe<SeasonWhereInput>;
  averageEntryScore?: Maybe<Int>;
  averageEntryScore_not?: Maybe<Int>;
  averageEntryScore_in?: Maybe<Int[] | Int>;
  averageEntryScore_not_in?: Maybe<Int[] | Int>;
  averageEntryScore_lt?: Maybe<Int>;
  averageEntryScore_lte?: Maybe<Int>;
  averageEntryScore_gt?: Maybe<Int>;
  averageEntryScore_gte?: Maybe<Int>;
  dataChecked?: Maybe<Boolean>;
  dataChecked_not?: Maybe<Boolean>;
  deadlineTime?: Maybe<DateTimeInput>;
  deadlineTime_not?: Maybe<DateTimeInput>;
  deadlineTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deadlineTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  deadlineTime_lt?: Maybe<DateTimeInput>;
  deadlineTime_lte?: Maybe<DateTimeInput>;
  deadlineTime_gt?: Maybe<DateTimeInput>;
  deadlineTime_gte?: Maybe<DateTimeInput>;
  deadlineTimeEpoch?: Maybe<Int>;
  deadlineTimeEpoch_not?: Maybe<Int>;
  deadlineTimeEpoch_in?: Maybe<Int[] | Int>;
  deadlineTimeEpoch_not_in?: Maybe<Int[] | Int>;
  deadlineTimeEpoch_lt?: Maybe<Int>;
  deadlineTimeEpoch_lte?: Maybe<Int>;
  deadlineTimeEpoch_gt?: Maybe<Int>;
  deadlineTimeEpoch_gte?: Maybe<Int>;
  deadlineTimeGameOffset?: Maybe<Int>;
  deadlineTimeGameOffset_not?: Maybe<Int>;
  deadlineTimeGameOffset_in?: Maybe<Int[] | Int>;
  deadlineTimeGameOffset_not_in?: Maybe<Int[] | Int>;
  deadlineTimeGameOffset_lt?: Maybe<Int>;
  deadlineTimeGameOffset_lte?: Maybe<Int>;
  deadlineTimeGameOffset_gt?: Maybe<Int>;
  deadlineTimeGameOffset_gte?: Maybe<Int>;
  finished?: Maybe<Boolean>;
  finished_not?: Maybe<Boolean>;
  highestScore?: Maybe<Int>;
  highestScore_not?: Maybe<Int>;
  highestScore_in?: Maybe<Int[] | Int>;
  highestScore_not_in?: Maybe<Int[] | Int>;
  highestScore_lt?: Maybe<Int>;
  highestScore_lte?: Maybe<Int>;
  highestScore_gt?: Maybe<Int>;
  highestScore_gte?: Maybe<Int>;
  highestScoringEntry?: Maybe<Int>;
  highestScoringEntry_not?: Maybe<Int>;
  highestScoringEntry_in?: Maybe<Int[] | Int>;
  highestScoringEntry_not_in?: Maybe<Int[] | Int>;
  highestScoringEntry_lt?: Maybe<Int>;
  highestScoringEntry_lte?: Maybe<Int>;
  highestScoringEntry_gt?: Maybe<Int>;
  highestScoringEntry_gte?: Maybe<Int>;
  fplEventId?: Maybe<Int>;
  fplEventId_not?: Maybe<Int>;
  fplEventId_in?: Maybe<Int[] | Int>;
  fplEventId_not_in?: Maybe<Int[] | Int>;
  fplEventId_lt?: Maybe<Int>;
  fplEventId_lte?: Maybe<Int>;
  fplEventId_gt?: Maybe<Int>;
  fplEventId_gte?: Maybe<Int>;
  isCurrent?: Maybe<Boolean>;
  isCurrent_not?: Maybe<Boolean>;
  isNext?: Maybe<Boolean>;
  isNext_not?: Maybe<Boolean>;
  isPrevious?: Maybe<Boolean>;
  isPrevious_not?: Maybe<Boolean>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  fixtures_every?: Maybe<FixtureWhereInput>;
  fixtures_some?: Maybe<FixtureWhereInput>;
  fixtures_none?: Maybe<FixtureWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<GameweekWhereInput[] | GameweekWhereInput>;
  OR?: Maybe<GameweekWhereInput[] | GameweekWhereInput>;
  NOT?: Maybe<GameweekWhereInput[] | GameweekWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserStatusPreviousValues {
  id: ID_Output;
  currentStatus?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserStatusPreviousValuesPromise
  extends Promise<UserStatusPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  currentStatus: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserStatusPreviousValuesSubscription
  extends Promise<AsyncIterator<UserStatusPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  currentStatus: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CountryConnection {
  pageInfo: PageInfo;
  edges: CountryEdge[];
}

export interface CountryConnectionPromise
  extends Promise<CountryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CountryEdge>>() => T;
  aggregate: <T = AggregateCountryPromise>() => T;
}

export interface CountryConnectionSubscription
  extends Promise<AsyncIterator<CountryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CountryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCountrySubscription>() => T;
}

export interface HomeTeamFixture {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface HomeTeamFixturePromise
  extends Promise<HomeTeamFixture>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  homeTeam: <T = TeamPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HomeTeamFixtureSubscription
  extends Promise<AsyncIterator<HomeTeamFixture>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fixture: <T = FixtureSubscription>() => T;
  homeTeam: <T = TeamSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HomeTeamFixtureNullablePromise
  extends Promise<HomeTeamFixture | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  homeTeam: <T = TeamPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateAwayTeamFixture {
  count: Int;
}

export interface AggregateAwayTeamFixturePromise
  extends Promise<AggregateAwayTeamFixture>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAwayTeamFixtureSubscription
  extends Promise<AsyncIterator<AggregateAwayTeamFixture>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Country {
  id: ID_Output;
  iso: String;
  name: String;
  code: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CountryPromise extends Promise<Country>, Fragmentable {
  id: () => Promise<ID_Output>;
  iso: () => Promise<String>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CountrySubscription
  extends Promise<AsyncIterator<Country>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  iso: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CountryNullablePromise
  extends Promise<Country | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  iso: () => Promise<String>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AwayTeamFixtureEdge {
  node: AwayTeamFixture;
  cursor: String;
}

export interface AwayTeamFixtureEdgePromise
  extends Promise<AwayTeamFixtureEdge>,
    Fragmentable {
  node: <T = AwayTeamFixturePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AwayTeamFixtureEdgeSubscription
  extends Promise<AsyncIterator<AwayTeamFixtureEdge>>,
    Fragmentable {
  node: <T = AwayTeamFixtureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserStatus {
  count: Int;
}

export interface AggregateUserStatusPromise
  extends Promise<AggregateUserStatus>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserStatusSubscription
  extends Promise<AsyncIterator<AggregateUserStatus>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AwayTeamFixtureConnection {
  pageInfo: PageInfo;
  edges: AwayTeamFixtureEdge[];
}

export interface AwayTeamFixtureConnectionPromise
  extends Promise<AwayTeamFixtureConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AwayTeamFixtureEdge>>() => T;
  aggregate: <T = AggregateAwayTeamFixturePromise>() => T;
}

export interface AwayTeamFixtureConnectionSubscription
  extends Promise<AsyncIterator<AwayTeamFixtureConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AwayTeamFixtureEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAwayTeamFixtureSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ActiveSubscriptions {
  id: ID_Output;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ActiveSubscriptionsPromise
  extends Promise<ActiveSubscriptions>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  subscription: <T = UserRolePromise>() => T;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ActiveSubscriptionsSubscription
  extends Promise<AsyncIterator<ActiveSubscriptions>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  subscription: <T = UserRoleSubscription>() => T;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ActiveSubscriptionsNullablePromise
  extends Promise<ActiveSubscriptions | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  subscription: <T = UserRolePromise>() => T;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserStatusConnection {
  pageInfo: PageInfo;
  edges: UserStatusEdge[];
}

export interface UserStatusConnectionPromise
  extends Promise<UserStatusConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserStatusEdge>>() => T;
  aggregate: <T = AggregateUserStatusPromise>() => T;
}

export interface UserStatusConnectionSubscription
  extends Promise<AsyncIterator<UserStatusConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserStatusEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserStatusSubscription>() => T;
}

export interface ActiveSubscriptionsSubscriptionPayload {
  mutation: MutationType;
  node: ActiveSubscriptions;
  updatedFields: String[];
  previousValues: ActiveSubscriptionsPreviousValues;
}

export interface ActiveSubscriptionsSubscriptionPayloadPromise
  extends Promise<ActiveSubscriptionsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActiveSubscriptionsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActiveSubscriptionsPreviousValuesPromise>() => T;
}

export interface ActiveSubscriptionsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActiveSubscriptionsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActiveSubscriptionsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActiveSubscriptionsPreviousValuesSubscription>() => T;
}

export interface UserRoleEdge {
  node: UserRole;
  cursor: String;
}

export interface UserRoleEdgePromise
  extends Promise<UserRoleEdge>,
    Fragmentable {
  node: <T = UserRolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserRoleEdgeSubscription
  extends Promise<AsyncIterator<UserRoleEdge>>,
    Fragmentable {
  node: <T = UserRoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ActiveSubscriptionsPreviousValues {
  id: ID_Output;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ActiveSubscriptionsPreviousValuesPromise
  extends Promise<ActiveSubscriptionsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ActiveSubscriptionsPreviousValuesSubscription
  extends Promise<AsyncIterator<ActiveSubscriptionsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateUserPhoto {
  count: Int;
}

export interface AggregateUserPhotoPromise
  extends Promise<AggregateUserPhoto>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserPhotoSubscription
  extends Promise<AsyncIterator<AggregateUserPhoto>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateActiveSubscriptions {
  count: Int;
}

export interface AggregateActiveSubscriptionsPromise
  extends Promise<AggregateActiveSubscriptions>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActiveSubscriptionsSubscription
  extends Promise<AsyncIterator<AggregateActiveSubscriptions>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserPhotoConnection {
  pageInfo: PageInfo;
  edges: UserPhotoEdge[];
}

export interface UserPhotoConnectionPromise
  extends Promise<UserPhotoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserPhotoEdge>>() => T;
  aggregate: <T = AggregateUserPhotoPromise>() => T;
}

export interface UserPhotoConnectionSubscription
  extends Promise<AsyncIterator<UserPhotoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserPhotoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserPhotoSubscription>() => T;
}

export interface AwayTeamFixtureSubscriptionPayload {
  mutation: MutationType;
  node: AwayTeamFixture;
  updatedFields: String[];
  previousValues: AwayTeamFixturePreviousValues;
}

export interface AwayTeamFixtureSubscriptionPayloadPromise
  extends Promise<AwayTeamFixtureSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AwayTeamFixturePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AwayTeamFixturePreviousValuesPromise>() => T;
}

export interface AwayTeamFixtureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AwayTeamFixtureSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AwayTeamFixtureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AwayTeamFixturePreviousValuesSubscription>() => T;
}

export interface UserInfluencersEdge {
  node: UserInfluencers;
  cursor: String;
}

export interface UserInfluencersEdgePromise
  extends Promise<UserInfluencersEdge>,
    Fragmentable {
  node: <T = UserInfluencersPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserInfluencersEdgeSubscription
  extends Promise<AsyncIterator<UserInfluencersEdge>>,
    Fragmentable {
  node: <T = UserInfluencersSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AwayTeamFixturePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AwayTeamFixturePreviousValuesPromise
  extends Promise<AwayTeamFixturePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AwayTeamFixturePreviousValuesSubscription
  extends Promise<AsyncIterator<AwayTeamFixturePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface User {
  id: ID_Output;
  email: String;
  name: String;
  countryCode?: String;
  phoneNumber?: String;
  displayName: String;
  isPrivate: Boolean;
  password: String;
  emailValidationToken?: String;
  emailValidationTokenExpiry?: Float;
  emailValidated: Boolean;
  emailValidationDate?: DateTimeOutput;
  resetToken?: String;
  resetTokenExpiry?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  countryCode: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  favoriteTeam: <T = TeamPromise>() => T;
  country: <T = CountryPromise>() => T;
  displayName: () => Promise<String>;
  isPrivate: () => Promise<Boolean>;
  password: () => Promise<String>;
  photos: <T = FragmentableArray<UserPhoto>>(args?: {
    where?: UserPhotoWhereInput;
    orderBy?: UserPhotoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  emailValidationToken: () => Promise<String>;
  emailValidationTokenExpiry: () => Promise<Float>;
  emailValidated: () => Promise<Boolean>;
  emailValidationDate: () => Promise<DateTimeOutput>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  subscriptions: <T = FragmentableArray<FandemSubscription>>(args?: {
    where?: FandemSubscriptionWhereInput;
    orderBy?: FandemSubscriptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  userRoles: <T = FragmentableArray<UserRole>>(args?: {
    where?: UserRoleWhereInput;
    orderBy?: UserRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: <T = FragmentableArray<UserStatus>>(args?: {
    where?: UserStatusWhereInput;
    orderBy?: UserStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followers: <T = UserFollowersPromise>() => T;
  influencers: <T = UserInfluencersPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  countryCode: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  favoriteTeam: <T = TeamSubscription>() => T;
  country: <T = CountrySubscription>() => T;
  displayName: () => Promise<AsyncIterator<String>>;
  isPrivate: () => Promise<AsyncIterator<Boolean>>;
  password: () => Promise<AsyncIterator<String>>;
  photos: <T = Promise<AsyncIterator<UserPhotoSubscription>>>(args?: {
    where?: UserPhotoWhereInput;
    orderBy?: UserPhotoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  emailValidationToken: () => Promise<AsyncIterator<String>>;
  emailValidationTokenExpiry: () => Promise<AsyncIterator<Float>>;
  emailValidated: () => Promise<AsyncIterator<Boolean>>;
  emailValidationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  subscriptions: <
    T = Promise<AsyncIterator<FandemSubscriptionSubscription>>
  >(args?: {
    where?: FandemSubscriptionWhereInput;
    orderBy?: FandemSubscriptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  userRoles: <T = Promise<AsyncIterator<UserRoleSubscription>>>(args?: {
    where?: UserRoleWhereInput;
    orderBy?: UserRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: <T = Promise<AsyncIterator<UserStatusSubscription>>>(args?: {
    where?: UserStatusWhereInput;
    orderBy?: UserStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followers: <T = UserFollowersSubscription>() => T;
  influencers: <T = UserInfluencersSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  countryCode: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  favoriteTeam: <T = TeamPromise>() => T;
  country: <T = CountryPromise>() => T;
  displayName: () => Promise<String>;
  isPrivate: () => Promise<Boolean>;
  password: () => Promise<String>;
  photos: <T = FragmentableArray<UserPhoto>>(args?: {
    where?: UserPhotoWhereInput;
    orderBy?: UserPhotoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  emailValidationToken: () => Promise<String>;
  emailValidationTokenExpiry: () => Promise<Float>;
  emailValidated: () => Promise<Boolean>;
  emailValidationDate: () => Promise<DateTimeOutput>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  subscriptions: <T = FragmentableArray<FandemSubscription>>(args?: {
    where?: FandemSubscriptionWhereInput;
    orderBy?: FandemSubscriptionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  userRoles: <T = FragmentableArray<UserRole>>(args?: {
    where?: UserRoleWhereInput;
    orderBy?: UserRoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  status: <T = FragmentableArray<UserStatus>>(args?: {
    where?: UserStatusWhereInput;
    orderBy?: UserStatusOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followers: <T = UserFollowersPromise>() => T;
  influencers: <T = UserInfluencersPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ActiveSubscriptionsEdge {
  node: ActiveSubscriptions;
  cursor: String;
}

export interface ActiveSubscriptionsEdgePromise
  extends Promise<ActiveSubscriptionsEdge>,
    Fragmentable {
  node: <T = ActiveSubscriptionsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActiveSubscriptionsEdgeSubscription
  extends Promise<AsyncIterator<ActiveSubscriptionsEdge>>,
    Fragmentable {
  node: <T = ActiveSubscriptionsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserFollowersEdge {
  node: UserFollowers;
  cursor: String;
}

export interface UserFollowersEdgePromise
  extends Promise<UserFollowersEdge>,
    Fragmentable {
  node: <T = UserFollowersPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserFollowersEdgeSubscription
  extends Promise<AsyncIterator<UserFollowersEdge>>,
    Fragmentable {
  node: <T = UserFollowersSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CountrySubscriptionPayload {
  mutation: MutationType;
  node: Country;
  updatedFields: String[];
  previousValues: CountryPreviousValues;
}

export interface CountrySubscriptionPayloadPromise
  extends Promise<CountrySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CountryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CountryPreviousValuesPromise>() => T;
}

export interface CountrySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CountrySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CountrySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CountryPreviousValuesSubscription>() => T;
}

export interface UserAssignedRoleEdge {
  node: UserAssignedRole;
  cursor: String;
}

export interface UserAssignedRoleEdgePromise
  extends Promise<UserAssignedRoleEdge>,
    Fragmentable {
  node: <T = UserAssignedRolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserAssignedRoleEdgeSubscription
  extends Promise<AsyncIterator<UserAssignedRoleEdge>>,
    Fragmentable {
  node: <T = UserAssignedRoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CountryPreviousValues {
  id: ID_Output;
  iso: String;
  name: String;
  code: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CountryPreviousValuesPromise
  extends Promise<CountryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  iso: () => Promise<String>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CountryPreviousValuesSubscription
  extends Promise<AsyncIterator<CountryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  iso: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Team {
  id: ID_Output;
  code: Int;
  fplTeamId: Int;
  name: String;
  shortName: String;
  strength: Int;
  strengthAttackAway: Int;
  strengthAttackHome: Int;
  strengthDefenceAway: Int;
  strengthDefenceHome: Int;
  strengthOverallAway: Int;
  strengthOverallHome: Int;
  teamDivision?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TeamPromise extends Promise<Team>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<Int>;
  season: <T = SeasonPromise>() => T;
  fplTeamId: () => Promise<Int>;
  name: () => Promise<String>;
  shortName: () => Promise<String>;
  strength: () => Promise<Int>;
  strengthAttackAway: () => Promise<Int>;
  strengthAttackHome: () => Promise<Int>;
  strengthDefenceAway: () => Promise<Int>;
  strengthDefenceHome: () => Promise<Int>;
  strengthOverallAway: () => Promise<Int>;
  strengthOverallHome: () => Promise<Int>;
  teamDivision: () => Promise<Int>;
  homeFixtures: <T = FragmentableArray<HomeTeamFixture>>(args?: {
    where?: HomeTeamFixtureWhereInput;
    orderBy?: HomeTeamFixtureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  awayFixtures: <T = FragmentableArray<AwayTeamFixture>>(args?: {
    where?: AwayTeamFixtureWhereInput;
    orderBy?: AwayTeamFixtureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TeamSubscription
  extends Promise<AsyncIterator<Team>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<Int>>;
  season: <T = SeasonSubscription>() => T;
  fplTeamId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  shortName: () => Promise<AsyncIterator<String>>;
  strength: () => Promise<AsyncIterator<Int>>;
  strengthAttackAway: () => Promise<AsyncIterator<Int>>;
  strengthAttackHome: () => Promise<AsyncIterator<Int>>;
  strengthDefenceAway: () => Promise<AsyncIterator<Int>>;
  strengthDefenceHome: () => Promise<AsyncIterator<Int>>;
  strengthOverallAway: () => Promise<AsyncIterator<Int>>;
  strengthOverallHome: () => Promise<AsyncIterator<Int>>;
  teamDivision: () => Promise<AsyncIterator<Int>>;
  homeFixtures: <
    T = Promise<AsyncIterator<HomeTeamFixtureSubscription>>
  >(args?: {
    where?: HomeTeamFixtureWhereInput;
    orderBy?: HomeTeamFixtureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  awayFixtures: <
    T = Promise<AsyncIterator<AwayTeamFixtureSubscription>>
  >(args?: {
    where?: AwayTeamFixtureWhereInput;
    orderBy?: AwayTeamFixtureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TeamNullablePromise
  extends Promise<Team | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<Int>;
  season: <T = SeasonPromise>() => T;
  fplTeamId: () => Promise<Int>;
  name: () => Promise<String>;
  shortName: () => Promise<String>;
  strength: () => Promise<Int>;
  strengthAttackAway: () => Promise<Int>;
  strengthAttackHome: () => Promise<Int>;
  strengthDefenceAway: () => Promise<Int>;
  strengthDefenceHome: () => Promise<Int>;
  strengthOverallAway: () => Promise<Int>;
  strengthOverallHome: () => Promise<Int>;
  teamDivision: () => Promise<Int>;
  homeFixtures: <T = FragmentableArray<HomeTeamFixture>>(args?: {
    where?: HomeTeamFixtureWhereInput;
    orderBy?: HomeTeamFixtureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  awayFixtures: <T = FragmentableArray<AwayTeamFixture>>(args?: {
    where?: AwayTeamFixtureWhereInput;
    orderBy?: AwayTeamFixtureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FandemSubscriptionSubscriptionPayload {
  mutation: MutationType;
  node: FandemSubscription;
  updatedFields: String[];
  previousValues: FandemSubscriptionPreviousValues;
}

export interface FandemSubscriptionSubscriptionPayloadPromise
  extends Promise<FandemSubscriptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FandemSubscriptionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FandemSubscriptionPreviousValuesPromise>() => T;
}

export interface FandemSubscriptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FandemSubscriptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FandemSubscriptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FandemSubscriptionPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface FandemSubscriptionPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FandemSubscriptionPreviousValuesPromise
  extends Promise<FandemSubscriptionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FandemSubscriptionPreviousValuesSubscription
  extends Promise<AsyncIterator<FandemSubscriptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TeamEdge {
  node: Team;
  cursor: String;
}

export interface TeamEdgePromise extends Promise<TeamEdge>, Fragmentable {
  node: <T = TeamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TeamEdgeSubscription
  extends Promise<AsyncIterator<TeamEdge>>,
    Fragmentable {
  node: <T = TeamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserPhotoPreviousValues {
  id: ID_Output;
  isProfile?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPhotoPreviousValuesPromise
  extends Promise<UserPhotoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isProfile: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPhotoPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPhotoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isProfile: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateTeam {
  count: Int;
}

export interface AggregateTeamPromise
  extends Promise<AggregateTeam>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTeamSubscription
  extends Promise<AsyncIterator<AggregateTeam>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActiveSubscriptionsConnection {
  pageInfo: PageInfo;
  edges: ActiveSubscriptionsEdge[];
}

export interface ActiveSubscriptionsConnectionPromise
  extends Promise<ActiveSubscriptionsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActiveSubscriptionsEdge>>() => T;
  aggregate: <T = AggregateActiveSubscriptionsPromise>() => T;
}

export interface ActiveSubscriptionsConnectionSubscription
  extends Promise<AsyncIterator<ActiveSubscriptionsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ActiveSubscriptionsEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateActiveSubscriptionsSubscription>() => T;
}

export interface TeamConnection {
  pageInfo: PageInfo;
  edges: TeamEdge[];
}

export interface TeamConnectionPromise
  extends Promise<TeamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TeamEdge>>() => T;
  aggregate: <T = AggregateTeamPromise>() => T;
}

export interface TeamConnectionSubscription
  extends Promise<AsyncIterator<TeamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TeamEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTeamSubscription>() => T;
}

export interface StatusConnection {
  pageInfo: PageInfo;
  edges: StatusEdge[];
}

export interface StatusConnectionPromise
  extends Promise<StatusConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StatusEdge>>() => T;
  aggregate: <T = AggregateStatusPromise>() => T;
}

export interface StatusConnectionSubscription
  extends Promise<AsyncIterator<StatusConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StatusEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStatusSubscription>() => T;
}

export interface AggregateStatus {
  count: Int;
}

export interface AggregateStatusPromise
  extends Promise<AggregateStatus>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStatusSubscription
  extends Promise<AsyncIterator<AggregateStatus>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateSeason {
  count: Int;
}

export interface AggregateSeasonPromise
  extends Promise<AggregateSeason>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSeasonSubscription
  extends Promise<AsyncIterator<AggregateSeason>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FixtureSubscriptionPayload {
  mutation: MutationType;
  node: Fixture;
  updatedFields: String[];
  previousValues: FixturePreviousValues;
}

export interface FixtureSubscriptionPayloadPromise
  extends Promise<FixtureSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FixturePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FixturePreviousValuesPromise>() => T;
}

export interface FixtureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FixtureSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FixtureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FixturePreviousValuesSubscription>() => T;
}

export interface SeasonConnection {
  pageInfo: PageInfo;
  edges: SeasonEdge[];
}

export interface SeasonConnectionPromise
  extends Promise<SeasonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SeasonEdge>>() => T;
  aggregate: <T = AggregateSeasonPromise>() => T;
}

export interface SeasonConnectionSubscription
  extends Promise<AsyncIterator<SeasonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SeasonEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSeasonSubscription>() => T;
}

export interface FixturePreviousValues {
  id: ID_Output;
  fplCode: Int;
  finished: Boolean;
  finishedProvisional: Boolean;
  fixtureId: Int;
  kickoffTime?: DateTimeOutput;
  minutes: Int;
  provisionalStartTime: Boolean;
  started: Boolean;
  teamADifficulty: Int;
  teamAScore?: Int;
  teamHDifficulty: Int;
  teamHScore?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FixturePreviousValuesPromise
  extends Promise<FixturePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fplCode: () => Promise<Int>;
  finished: () => Promise<Boolean>;
  finishedProvisional: () => Promise<Boolean>;
  fixtureId: () => Promise<Int>;
  kickoffTime: () => Promise<DateTimeOutput>;
  minutes: () => Promise<Int>;
  provisionalStartTime: () => Promise<Boolean>;
  started: () => Promise<Boolean>;
  teamADifficulty: () => Promise<Int>;
  teamAScore: () => Promise<Int>;
  teamHDifficulty: () => Promise<Int>;
  teamHScore: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FixturePreviousValuesSubscription
  extends Promise<AsyncIterator<FixturePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fplCode: () => Promise<AsyncIterator<Int>>;
  finished: () => Promise<AsyncIterator<Boolean>>;
  finishedProvisional: () => Promise<AsyncIterator<Boolean>>;
  fixtureId: () => Promise<AsyncIterator<Int>>;
  kickoffTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  minutes: () => Promise<AsyncIterator<Int>>;
  provisionalStartTime: () => Promise<AsyncIterator<Boolean>>;
  started: () => Promise<AsyncIterator<Boolean>>;
  teamADifficulty: () => Promise<AsyncIterator<Int>>;
  teamAScore: () => Promise<AsyncIterator<Int>>;
  teamHDifficulty: () => Promise<AsyncIterator<Int>>;
  teamHScore: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregatePhoto {
  count: Int;
}

export interface AggregatePhotoPromise
  extends Promise<AggregatePhoto>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePhotoSubscription
  extends Promise<AsyncIterator<AggregatePhoto>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AwayTeamFixture {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface AwayTeamFixturePromise
  extends Promise<AwayTeamFixture>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  awayTeam: <T = TeamPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AwayTeamFixtureSubscription
  extends Promise<AsyncIterator<AwayTeamFixture>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fixture: <T = FixtureSubscription>() => T;
  awayTeam: <T = TeamSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AwayTeamFixtureNullablePromise
  extends Promise<AwayTeamFixture | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fixture: <T = FixturePromise>() => T;
  awayTeam: <T = TeamPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PhotoConnection {
  pageInfo: PageInfo;
  edges: PhotoEdge[];
}

export interface PhotoConnectionPromise
  extends Promise<PhotoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PhotoEdge>>() => T;
  aggregate: <T = AggregatePhotoPromise>() => T;
}

export interface PhotoConnectionSubscription
  extends Promise<AsyncIterator<PhotoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PhotoEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePhotoSubscription>() => T;
}

export interface FollowerSubscriptionPayload {
  mutation: MutationType;
  node: Follower;
  updatedFields: String[];
  previousValues: FollowerPreviousValues;
}

export interface FollowerSubscriptionPayloadPromise
  extends Promise<FollowerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FollowerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FollowerPreviousValuesPromise>() => T;
}

export interface FollowerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FollowerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FollowerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FollowerPreviousValuesSubscription>() => T;
}

export interface InfluencerEdge {
  node: Influencer;
  cursor: String;
}

export interface InfluencerEdgePromise
  extends Promise<InfluencerEdge>,
    Fragmentable {
  node: <T = InfluencerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InfluencerEdgeSubscription
  extends Promise<AsyncIterator<InfluencerEdge>>,
    Fragmentable {
  node: <T = InfluencerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FollowerPreviousValues {
  id: ID_Output;
  blocked: Boolean;
  accepted: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FollowerPreviousValuesPromise
  extends Promise<FollowerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  blocked: () => Promise<Boolean>;
  accepted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FollowerPreviousValuesSubscription
  extends Promise<AsyncIterator<FollowerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  blocked: () => Promise<AsyncIterator<Boolean>>;
  accepted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateHomeTeamFixture {
  count: Int;
}

export interface AggregateHomeTeamFixturePromise
  extends Promise<AggregateHomeTeamFixture>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHomeTeamFixtureSubscription
  extends Promise<AsyncIterator<AggregateHomeTeamFixture>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Influencer {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InfluencerPromise extends Promise<Influencer>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InfluencerSubscription
  extends Promise<AsyncIterator<Influencer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InfluencerNullablePromise
  extends Promise<Influencer | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HomeTeamFixtureConnection {
  pageInfo: PageInfo;
  edges: HomeTeamFixtureEdge[];
}

export interface HomeTeamFixtureConnectionPromise
  extends Promise<HomeTeamFixtureConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HomeTeamFixtureEdge>>() => T;
  aggregate: <T = AggregateHomeTeamFixturePromise>() => T;
}

export interface HomeTeamFixtureConnectionSubscription
  extends Promise<AsyncIterator<HomeTeamFixtureConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HomeTeamFixtureEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHomeTeamFixtureSubscription>() => T;
}

export interface GameweekSubscriptionPayload {
  mutation: MutationType;
  node: Gameweek;
  updatedFields: String[];
  previousValues: GameweekPreviousValues;
}

export interface GameweekSubscriptionPayloadPromise
  extends Promise<GameweekSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GameweekPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GameweekPreviousValuesPromise>() => T;
}

export interface GameweekSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GameweekSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GameweekSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GameweekPreviousValuesSubscription>() => T;
}

export interface GameweekEdge {
  node: Gameweek;
  cursor: String;
}

export interface GameweekEdgePromise
  extends Promise<GameweekEdge>,
    Fragmentable {
  node: <T = GameweekPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GameweekEdgeSubscription
  extends Promise<AsyncIterator<GameweekEdge>>,
    Fragmentable {
  node: <T = GameweekSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GameweekPreviousValues {
  id: ID_Output;
  averageEntryScore?: Int;
  dataChecked: Boolean;
  deadlineTime: DateTimeOutput;
  deadlineTimeEpoch: Int;
  deadlineTimeGameOffset: Int;
  finished: Boolean;
  highestScore?: Int;
  highestScoringEntry?: Int;
  fplEventId: Int;
  isCurrent: Boolean;
  isNext: Boolean;
  isPrevious: Boolean;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GameweekPreviousValuesPromise
  extends Promise<GameweekPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  averageEntryScore: () => Promise<Int>;
  dataChecked: () => Promise<Boolean>;
  deadlineTime: () => Promise<DateTimeOutput>;
  deadlineTimeEpoch: () => Promise<Int>;
  deadlineTimeGameOffset: () => Promise<Int>;
  finished: () => Promise<Boolean>;
  highestScore: () => Promise<Int>;
  highestScoringEntry: () => Promise<Int>;
  fplEventId: () => Promise<Int>;
  isCurrent: () => Promise<Boolean>;
  isNext: () => Promise<Boolean>;
  isPrevious: () => Promise<Boolean>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GameweekPreviousValuesSubscription
  extends Promise<AsyncIterator<GameweekPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  averageEntryScore: () => Promise<AsyncIterator<Int>>;
  dataChecked: () => Promise<AsyncIterator<Boolean>>;
  deadlineTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  deadlineTimeEpoch: () => Promise<AsyncIterator<Int>>;
  deadlineTimeGameOffset: () => Promise<AsyncIterator<Int>>;
  finished: () => Promise<AsyncIterator<Boolean>>;
  highestScore: () => Promise<AsyncIterator<Int>>;
  highestScoringEntry: () => Promise<AsyncIterator<Int>>;
  fplEventId: () => Promise<AsyncIterator<Int>>;
  isCurrent: () => Promise<AsyncIterator<Boolean>>;
  isNext: () => Promise<AsyncIterator<Boolean>>;
  isPrevious: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateFollower {
  count: Int;
}

export interface AggregateFollowerPromise
  extends Promise<AggregateFollower>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFollowerSubscription
  extends Promise<AsyncIterator<AggregateFollower>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserInfluencers {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserInfluencersPromise
  extends Promise<UserInfluencers>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  influencers: <T = FragmentableArray<Influencer>>(args?: {
    where?: InfluencerWhereInput;
    orderBy?: InfluencerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserInfluencersSubscription
  extends Promise<AsyncIterator<UserInfluencers>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  influencers: <T = Promise<AsyncIterator<InfluencerSubscription>>>(args?: {
    where?: InfluencerWhereInput;
    orderBy?: InfluencerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserInfluencersNullablePromise
  extends Promise<UserInfluencers | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  influencers: <T = FragmentableArray<Influencer>>(args?: {
    where?: InfluencerWhereInput;
    orderBy?: InfluencerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FollowerConnection {
  pageInfo: PageInfo;
  edges: FollowerEdge[];
}

export interface FollowerConnectionPromise
  extends Promise<FollowerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FollowerEdge>>() => T;
  aggregate: <T = AggregateFollowerPromise>() => T;
}

export interface FollowerConnectionSubscription
  extends Promise<AsyncIterator<FollowerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FollowerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFollowerSubscription>() => T;
}

export interface HomeTeamFixtureSubscriptionPayload {
  mutation: MutationType;
  node: HomeTeamFixture;
  updatedFields: String[];
  previousValues: HomeTeamFixturePreviousValues;
}

export interface HomeTeamFixtureSubscriptionPayloadPromise
  extends Promise<HomeTeamFixtureSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HomeTeamFixturePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HomeTeamFixturePreviousValuesPromise>() => T;
}

export interface HomeTeamFixtureSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HomeTeamFixtureSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HomeTeamFixtureSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HomeTeamFixturePreviousValuesSubscription>() => T;
}

export interface FixtureEdge {
  node: Fixture;
  cursor: String;
}

export interface FixtureEdgePromise extends Promise<FixtureEdge>, Fragmentable {
  node: <T = FixturePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FixtureEdgeSubscription
  extends Promise<AsyncIterator<FixtureEdge>>,
    Fragmentable {
  node: <T = FixtureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HomeTeamFixturePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface HomeTeamFixturePreviousValuesPromise
  extends Promise<HomeTeamFixturePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HomeTeamFixturePreviousValuesSubscription
  extends Promise<AsyncIterator<HomeTeamFixturePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateFandemSubscription {
  count: Int;
}

export interface AggregateFandemSubscriptionPromise
  extends Promise<AggregateFandemSubscription>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFandemSubscriptionSubscription
  extends Promise<AsyncIterator<AggregateFandemSubscription>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Follower {
  id: ID_Output;
  blocked: Boolean;
  accepted: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FollowerPromise extends Promise<Follower>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  blocked: () => Promise<Boolean>;
  accepted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FollowerSubscription
  extends Promise<AsyncIterator<Follower>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  blocked: () => Promise<AsyncIterator<Boolean>>;
  accepted: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FollowerNullablePromise
  extends Promise<Follower | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  blocked: () => Promise<Boolean>;
  accepted: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FandemSubscriptionConnection {
  pageInfo: PageInfo;
  edges: FandemSubscriptionEdge[];
}

export interface FandemSubscriptionConnectionPromise
  extends Promise<FandemSubscriptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FandemSubscriptionEdge>>() => T;
  aggregate: <T = AggregateFandemSubscriptionPromise>() => T;
}

export interface FandemSubscriptionConnectionSubscription
  extends Promise<AsyncIterator<FandemSubscriptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<FandemSubscriptionEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateFandemSubscriptionSubscription>() => T;
}

export interface InfluencerSubscriptionPayload {
  mutation: MutationType;
  node: Influencer;
  updatedFields: String[];
  previousValues: InfluencerPreviousValues;
}

export interface InfluencerSubscriptionPayloadPromise
  extends Promise<InfluencerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InfluencerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InfluencerPreviousValuesPromise>() => T;
}

export interface InfluencerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InfluencerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InfluencerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InfluencerPreviousValuesSubscription>() => T;
}

export interface CountryEdge {
  node: Country;
  cursor: String;
}

export interface CountryEdgePromise extends Promise<CountryEdge>, Fragmentable {
  node: <T = CountryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CountryEdgeSubscription
  extends Promise<AsyncIterator<CountryEdge>>,
    Fragmentable {
  node: <T = CountrySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface InfluencerPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface InfluencerPreviousValuesPromise
  extends Promise<InfluencerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InfluencerPreviousValuesSubscription
  extends Promise<AsyncIterator<InfluencerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserStatusEdge {
  node: UserStatus;
  cursor: String;
}

export interface UserStatusEdgePromise
  extends Promise<UserStatusEdge>,
    Fragmentable {
  node: <T = UserStatusPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserStatusEdgeSubscription
  extends Promise<AsyncIterator<UserStatusEdge>>,
    Fragmentable {
  node: <T = UserStatusSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserFollowers {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserFollowersPromise
  extends Promise<UserFollowers>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  followers: <T = FragmentableArray<Follower>>(args?: {
    where?: FollowerWhereInput;
    orderBy?: FollowerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserFollowersSubscription
  extends Promise<AsyncIterator<UserFollowers>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  followers: <T = Promise<AsyncIterator<FollowerSubscription>>>(args?: {
    where?: FollowerWhereInput;
    orderBy?: FollowerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  user: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserFollowersNullablePromise
  extends Promise<UserFollowers | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  followers: <T = FragmentableArray<Follower>>(args?: {
    where?: FollowerWhereInput;
    orderBy?: FollowerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  user: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateUserRole {
  count: Int;
}

export interface AggregateUserRolePromise
  extends Promise<AggregateUserRole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserRoleSubscription
  extends Promise<AsyncIterator<AggregateUserRole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PhotoSubscriptionPayload {
  mutation: MutationType;
  node: Photo;
  updatedFields: String[];
  previousValues: PhotoPreviousValues;
}

export interface PhotoSubscriptionPayloadPromise
  extends Promise<PhotoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PhotoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PhotoPreviousValuesPromise>() => T;
}

export interface PhotoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PhotoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PhotoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PhotoPreviousValuesSubscription>() => T;
}

export interface UserPhotoEdge {
  node: UserPhoto;
  cursor: String;
}

export interface UserPhotoEdgePromise
  extends Promise<UserPhotoEdge>,
    Fragmentable {
  node: <T = UserPhotoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserPhotoEdgeSubscription
  extends Promise<AsyncIterator<UserPhotoEdge>>,
    Fragmentable {
  node: <T = UserPhotoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PhotoPreviousValues {
  id: ID_Output;
  image: String;
  largeImage?: String;
  smallImage?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PhotoPreviousValuesPromise
  extends Promise<PhotoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  image: () => Promise<String>;
  largeImage: () => Promise<String>;
  smallImage: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PhotoPreviousValuesSubscription
  extends Promise<AsyncIterator<PhotoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  image: () => Promise<AsyncIterator<String>>;
  largeImage: () => Promise<AsyncIterator<String>>;
  smallImage: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserInfluencersConnection {
  pageInfo: PageInfo;
  edges: UserInfluencersEdge[];
}

export interface UserInfluencersConnectionPromise
  extends Promise<UserInfluencersConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserInfluencersEdge>>() => T;
  aggregate: <T = AggregateUserInfluencersPromise>() => T;
}

export interface UserInfluencersConnectionSubscription
  extends Promise<AsyncIterator<UserInfluencersConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserInfluencersEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserInfluencersSubscription>() => T;
}

export interface Status {
  id: ID_Output;
  content: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StatusPromise extends Promise<Status>, Fragmentable {
  id: () => Promise<ID_Output>;
  author: <T = UserStatusPromise>() => T;
  content: () => Promise<String>;
  likes: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StatusSubscription
  extends Promise<AsyncIterator<Status>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  author: <T = UserStatusSubscription>() => T;
  content: () => Promise<AsyncIterator<String>>;
  likes: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StatusNullablePromise
  extends Promise<Status | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  author: <T = UserStatusPromise>() => T;
  content: () => Promise<String>;
  likes: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserFollowersConnection {
  pageInfo: PageInfo;
  edges: UserFollowersEdge[];
}

export interface UserFollowersConnectionPromise
  extends Promise<UserFollowersConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserFollowersEdge>>() => T;
  aggregate: <T = AggregateUserFollowersPromise>() => T;
}

export interface UserFollowersConnectionSubscription
  extends Promise<AsyncIterator<UserFollowersConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserFollowersEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserFollowersSubscription>() => T;
}

export interface SeasonSubscriptionPayload {
  mutation: MutationType;
  node: Season;
  updatedFields: String[];
  previousValues: SeasonPreviousValues;
}

export interface SeasonSubscriptionPayloadPromise
  extends Promise<SeasonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SeasonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SeasonPreviousValuesPromise>() => T;
}

export interface SeasonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SeasonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SeasonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SeasonPreviousValuesSubscription>() => T;
}

export interface UserAssignedRoleConnection {
  pageInfo: PageInfo;
  edges: UserAssignedRoleEdge[];
}

export interface UserAssignedRoleConnectionPromise
  extends Promise<UserAssignedRoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserAssignedRoleEdge>>() => T;
  aggregate: <T = AggregateUserAssignedRolePromise>() => T;
}

export interface UserAssignedRoleConnectionSubscription
  extends Promise<AsyncIterator<UserAssignedRoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserAssignedRoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserAssignedRoleSubscription>() => T;
}

export interface SeasonPreviousValues {
  id: ID_Output;
  fplId: Int;
  label: String;
  competition: String;
  startYear: Int;
  endYear: Int;
  isCurrent: Boolean;
  isPrevious: Boolean;
  isNext: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SeasonPreviousValuesPromise
  extends Promise<SeasonPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fplId: () => Promise<Int>;
  label: () => Promise<String>;
  competition: () => Promise<String>;
  startYear: () => Promise<Int>;
  endYear: () => Promise<Int>;
  isCurrent: () => Promise<Boolean>;
  isPrevious: () => Promise<Boolean>;
  isNext: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SeasonPreviousValuesSubscription
  extends Promise<AsyncIterator<SeasonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fplId: () => Promise<AsyncIterator<Int>>;
  label: () => Promise<AsyncIterator<String>>;
  competition: () => Promise<AsyncIterator<String>>;
  startYear: () => Promise<AsyncIterator<Int>>;
  endYear: () => Promise<AsyncIterator<Int>>;
  isCurrent: () => Promise<AsyncIterator<Boolean>>;
  isPrevious: () => Promise<AsyncIterator<Boolean>>;
  isNext: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StatusEdge {
  node: Status;
  cursor: String;
}

export interface StatusEdgePromise extends Promise<StatusEdge>, Fragmentable {
  node: <T = StatusPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StatusEdgeSubscription
  extends Promise<AsyncIterator<StatusEdge>>,
    Fragmentable {
  node: <T = StatusSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserStatus {
  id: ID_Output;
  currentStatus?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserStatusPromise extends Promise<UserStatus>, Fragmentable {
  id: () => Promise<ID_Output>;
  status: <T = StatusPromise>() => T;
  currentStatus: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserStatusSubscription
  extends Promise<AsyncIterator<UserStatus>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: <T = StatusSubscription>() => T;
  currentStatus: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserStatusNullablePromise
  extends Promise<UserStatus | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: <T = StatusPromise>() => T;
  currentStatus: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SeasonEdge {
  node: Season;
  cursor: String;
}

export interface SeasonEdgePromise extends Promise<SeasonEdge>, Fragmentable {
  node: <T = SeasonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SeasonEdgeSubscription
  extends Promise<AsyncIterator<SeasonEdge>>,
    Fragmentable {
  node: <T = SeasonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StatusSubscriptionPayload {
  mutation: MutationType;
  node: Status;
  updatedFields: String[];
  previousValues: StatusPreviousValues;
}

export interface StatusSubscriptionPayloadPromise
  extends Promise<StatusSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StatusPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StatusPreviousValuesPromise>() => T;
}

export interface StatusSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StatusSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StatusSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StatusPreviousValuesSubscription>() => T;
}

export interface PhotoEdge {
  node: Photo;
  cursor: String;
}

export interface PhotoEdgePromise extends Promise<PhotoEdge>, Fragmentable {
  node: <T = PhotoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PhotoEdgeSubscription
  extends Promise<AsyncIterator<PhotoEdge>>,
    Fragmentable {
  node: <T = PhotoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StatusPreviousValues {
  id: ID_Output;
  content: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface StatusPreviousValuesPromise
  extends Promise<StatusPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface StatusPreviousValuesSubscription
  extends Promise<AsyncIterator<StatusPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InfluencerConnection {
  pageInfo: PageInfo;
  edges: InfluencerEdge[];
}

export interface InfluencerConnectionPromise
  extends Promise<InfluencerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InfluencerEdge>>() => T;
  aggregate: <T = AggregateInfluencerPromise>() => T;
}

export interface InfluencerConnectionSubscription
  extends Promise<AsyncIterator<InfluencerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InfluencerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInfluencerSubscription>() => T;
}

export interface UserRole {
  id: ID_Output;
  name: String;
  description: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserRolePromise extends Promise<UserRole>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserRoleSubscription
  extends Promise<AsyncIterator<UserRole>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserRoleNullablePromise
  extends Promise<UserRole | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateGameweek {
  count: Int;
}

export interface AggregateGameweekPromise
  extends Promise<AggregateGameweek>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGameweekSubscription
  extends Promise<AsyncIterator<AggregateGameweek>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TeamSubscriptionPayload {
  mutation: MutationType;
  node: Team;
  updatedFields: String[];
  previousValues: TeamPreviousValues;
}

export interface TeamSubscriptionPayloadPromise
  extends Promise<TeamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TeamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TeamPreviousValuesPromise>() => T;
}

export interface TeamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TeamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TeamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TeamPreviousValuesSubscription>() => T;
}

export interface FollowerEdge {
  node: Follower;
  cursor: String;
}

export interface FollowerEdgePromise
  extends Promise<FollowerEdge>,
    Fragmentable {
  node: <T = FollowerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FollowerEdgeSubscription
  extends Promise<AsyncIterator<FollowerEdge>>,
    Fragmentable {
  node: <T = FollowerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TeamPreviousValues {
  id: ID_Output;
  code: Int;
  fplTeamId: Int;
  name: String;
  shortName: String;
  strength: Int;
  strengthAttackAway: Int;
  strengthAttackHome: Int;
  strengthDefenceAway: Int;
  strengthDefenceHome: Int;
  strengthOverallAway: Int;
  strengthOverallHome: Int;
  teamDivision?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface TeamPreviousValuesPromise
  extends Promise<TeamPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<Int>;
  fplTeamId: () => Promise<Int>;
  name: () => Promise<String>;
  shortName: () => Promise<String>;
  strength: () => Promise<Int>;
  strengthAttackAway: () => Promise<Int>;
  strengthAttackHome: () => Promise<Int>;
  strengthDefenceAway: () => Promise<Int>;
  strengthDefenceHome: () => Promise<Int>;
  strengthOverallAway: () => Promise<Int>;
  strengthOverallHome: () => Promise<Int>;
  teamDivision: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TeamPreviousValuesSubscription
  extends Promise<AsyncIterator<TeamPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<Int>>;
  fplTeamId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  shortName: () => Promise<AsyncIterator<String>>;
  strength: () => Promise<AsyncIterator<Int>>;
  strengthAttackAway: () => Promise<AsyncIterator<Int>>;
  strengthAttackHome: () => Promise<AsyncIterator<Int>>;
  strengthDefenceAway: () => Promise<AsyncIterator<Int>>;
  strengthDefenceHome: () => Promise<AsyncIterator<Int>>;
  strengthOverallAway: () => Promise<AsyncIterator<Int>>;
  strengthOverallHome: () => Promise<AsyncIterator<Int>>;
  teamDivision: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FixtureConnection {
  pageInfo: PageInfo;
  edges: FixtureEdge[];
}

export interface FixtureConnectionPromise
  extends Promise<FixtureConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FixtureEdge>>() => T;
  aggregate: <T = AggregateFixturePromise>() => T;
}

export interface FixtureConnectionSubscription
  extends Promise<AsyncIterator<FixtureConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FixtureEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFixtureSubscription>() => T;
}

export interface Gameweek {
  id: ID_Output;
  averageEntryScore?: Int;
  dataChecked: Boolean;
  deadlineTime: DateTimeOutput;
  deadlineTimeEpoch: Int;
  deadlineTimeGameOffset: Int;
  finished: Boolean;
  highestScore?: Int;
  highestScoringEntry?: Int;
  fplEventId: Int;
  isCurrent: Boolean;
  isNext: Boolean;
  isPrevious: Boolean;
  name: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GameweekPromise extends Promise<Gameweek>, Fragmentable {
  id: () => Promise<ID_Output>;
  season: <T = SeasonPromise>() => T;
  averageEntryScore: () => Promise<Int>;
  dataChecked: () => Promise<Boolean>;
  deadlineTime: () => Promise<DateTimeOutput>;
  deadlineTimeEpoch: () => Promise<Int>;
  deadlineTimeGameOffset: () => Promise<Int>;
  finished: () => Promise<Boolean>;
  highestScore: () => Promise<Int>;
  highestScoringEntry: () => Promise<Int>;
  fplEventId: () => Promise<Int>;
  isCurrent: () => Promise<Boolean>;
  isNext: () => Promise<Boolean>;
  isPrevious: () => Promise<Boolean>;
  name: () => Promise<String>;
  fixtures: <T = FragmentableArray<Fixture>>(args?: {
    where?: FixtureWhereInput;
    orderBy?: FixtureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GameweekSubscription
  extends Promise<AsyncIterator<Gameweek>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  season: <T = SeasonSubscription>() => T;
  averageEntryScore: () => Promise<AsyncIterator<Int>>;
  dataChecked: () => Promise<AsyncIterator<Boolean>>;
  deadlineTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  deadlineTimeEpoch: () => Promise<AsyncIterator<Int>>;
  deadlineTimeGameOffset: () => Promise<AsyncIterator<Int>>;
  finished: () => Promise<AsyncIterator<Boolean>>;
  highestScore: () => Promise<AsyncIterator<Int>>;
  highestScoringEntry: () => Promise<AsyncIterator<Int>>;
  fplEventId: () => Promise<AsyncIterator<Int>>;
  isCurrent: () => Promise<AsyncIterator<Boolean>>;
  isNext: () => Promise<AsyncIterator<Boolean>>;
  isPrevious: () => Promise<AsyncIterator<Boolean>>;
  name: () => Promise<AsyncIterator<String>>;
  fixtures: <T = Promise<AsyncIterator<FixtureSubscription>>>(args?: {
    where?: FixtureWhereInput;
    orderBy?: FixtureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GameweekNullablePromise
  extends Promise<Gameweek | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  season: <T = SeasonPromise>() => T;
  averageEntryScore: () => Promise<Int>;
  dataChecked: () => Promise<Boolean>;
  deadlineTime: () => Promise<DateTimeOutput>;
  deadlineTimeEpoch: () => Promise<Int>;
  deadlineTimeGameOffset: () => Promise<Int>;
  finished: () => Promise<Boolean>;
  highestScore: () => Promise<Int>;
  highestScoringEntry: () => Promise<Int>;
  fplEventId: () => Promise<Int>;
  isCurrent: () => Promise<Boolean>;
  isNext: () => Promise<Boolean>;
  isPrevious: () => Promise<Boolean>;
  name: () => Promise<String>;
  fixtures: <T = FragmentableArray<Fixture>>(args?: {
    where?: FixtureWhereInput;
    orderBy?: FixtureOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateCountry {
  count: Int;
}

export interface AggregateCountryPromise
  extends Promise<AggregateCountry>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCountrySubscription
  extends Promise<AsyncIterator<AggregateCountry>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserRoleSubscriptionPayload {
  mutation: MutationType;
  node: UserRole;
  updatedFields: String[];
  previousValues: UserRolePreviousValues;
}

export interface UserRoleSubscriptionPayloadPromise
  extends Promise<UserRoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserRolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserRolePreviousValuesPromise>() => T;
}

export interface UserRoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserRoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserRoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserRolePreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  name: String;
  countryCode?: String;
  phoneNumber?: String;
  displayName: String;
  isPrivate: Boolean;
  password: String;
  emailValidationToken?: String;
  emailValidationTokenExpiry?: Float;
  emailValidated: Boolean;
  emailValidationDate?: DateTimeOutput;
  resetToken?: String;
  resetTokenExpiry?: Float;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  countryCode: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  displayName: () => Promise<String>;
  isPrivate: () => Promise<Boolean>;
  password: () => Promise<String>;
  emailValidationToken: () => Promise<String>;
  emailValidationTokenExpiry: () => Promise<Float>;
  emailValidated: () => Promise<Boolean>;
  emailValidationDate: () => Promise<DateTimeOutput>;
  resetToken: () => Promise<String>;
  resetTokenExpiry: () => Promise<Float>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  countryCode: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  displayName: () => Promise<AsyncIterator<String>>;
  isPrivate: () => Promise<AsyncIterator<Boolean>>;
  password: () => Promise<AsyncIterator<String>>;
  emailValidationToken: () => Promise<AsyncIterator<String>>;
  emailValidationTokenExpiry: () => Promise<AsyncIterator<Float>>;
  emailValidated: () => Promise<AsyncIterator<Boolean>>;
  emailValidationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  resetToken: () => Promise<AsyncIterator<String>>;
  resetTokenExpiry: () => Promise<AsyncIterator<Float>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateUserInfluencers {
  count: Int;
}

export interface AggregateUserInfluencersPromise
  extends Promise<AggregateUserInfluencers>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserInfluencersSubscription
  extends Promise<AsyncIterator<AggregateUserInfluencers>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FandemSubscription {
  id: ID_Output;
  name: String;
  description: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FandemSubscriptionPromise
  extends Promise<FandemSubscription>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FandemSubscriptionSubscription
  extends Promise<AsyncIterator<FandemSubscription>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FandemSubscriptionNullablePromise
  extends Promise<FandemSubscription | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface AggregateUserAssignedRole {
  count: Int;
}

export interface AggregateUserAssignedRolePromise
  extends Promise<AggregateUserAssignedRole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserAssignedRoleSubscription
  extends Promise<AsyncIterator<AggregateUserAssignedRole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserAssignedRoleSubscriptionPayload {
  mutation: MutationType;
  node: UserAssignedRole;
  updatedFields: String[];
  previousValues: UserAssignedRolePreviousValues;
}

export interface UserAssignedRoleSubscriptionPayloadPromise
  extends Promise<UserAssignedRoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserAssignedRolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserAssignedRolePreviousValuesPromise>() => T;
}

export interface UserAssignedRoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserAssignedRoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserAssignedRoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserAssignedRolePreviousValuesSubscription>() => T;
}

export interface Season {
  id: ID_Output;
  fplId: Int;
  label: String;
  competition: String;
  startYear: Int;
  endYear: Int;
  isCurrent: Boolean;
  isPrevious: Boolean;
  isNext: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SeasonPromise extends Promise<Season>, Fragmentable {
  id: () => Promise<ID_Output>;
  fplId: () => Promise<Int>;
  label: () => Promise<String>;
  competition: () => Promise<String>;
  startYear: () => Promise<Int>;
  endYear: () => Promise<Int>;
  isCurrent: () => Promise<Boolean>;
  isPrevious: () => Promise<Boolean>;
  isNext: () => Promise<Boolean>;
  events: <T = FragmentableArray<Gameweek>>(args?: {
    where?: GameweekWhereInput;
    orderBy?: GameweekOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SeasonSubscription
  extends Promise<AsyncIterator<Season>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fplId: () => Promise<AsyncIterator<Int>>;
  label: () => Promise<AsyncIterator<String>>;
  competition: () => Promise<AsyncIterator<String>>;
  startYear: () => Promise<AsyncIterator<Int>>;
  endYear: () => Promise<AsyncIterator<Int>>;
  isCurrent: () => Promise<AsyncIterator<Boolean>>;
  isPrevious: () => Promise<AsyncIterator<Boolean>>;
  isNext: () => Promise<AsyncIterator<Boolean>>;
  events: <T = Promise<AsyncIterator<GameweekSubscription>>>(args?: {
    where?: GameweekWhereInput;
    orderBy?: GameweekOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SeasonNullablePromise
  extends Promise<Season | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fplId: () => Promise<Int>;
  label: () => Promise<String>;
  competition: () => Promise<String>;
  startYear: () => Promise<Int>;
  endYear: () => Promise<Int>;
  isCurrent: () => Promise<Boolean>;
  isPrevious: () => Promise<Boolean>;
  isNext: () => Promise<Boolean>;
  events: <T = FragmentableArray<Gameweek>>(args?: {
    where?: GameweekWhereInput;
    orderBy?: GameweekOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserAssignedRolePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserAssignedRolePreviousValuesPromise
  extends Promise<UserAssignedRolePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserAssignedRolePreviousValuesSubscription
  extends Promise<AsyncIterator<UserAssignedRolePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateInfluencer {
  count: Int;
}

export interface AggregateInfluencerPromise
  extends Promise<AggregateInfluencer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInfluencerSubscription
  extends Promise<AsyncIterator<AggregateInfluencer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Fixture {
  id: ID_Output;
  fplCode: Int;
  finished: Boolean;
  finishedProvisional: Boolean;
  fixtureId: Int;
  kickoffTime?: DateTimeOutput;
  minutes: Int;
  provisionalStartTime: Boolean;
  started: Boolean;
  teamADifficulty: Int;
  teamAScore?: Int;
  teamHDifficulty: Int;
  teamHScore?: Int;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FixturePromise extends Promise<Fixture>, Fragmentable {
  id: () => Promise<ID_Output>;
  fplCode: () => Promise<Int>;
  event: <T = GameweekPromise>() => T;
  finished: () => Promise<Boolean>;
  finishedProvisional: () => Promise<Boolean>;
  fixtureId: () => Promise<Int>;
  kickoffTime: () => Promise<DateTimeOutput>;
  minutes: () => Promise<Int>;
  provisionalStartTime: () => Promise<Boolean>;
  started: () => Promise<Boolean>;
  teamA: <T = AwayTeamFixturePromise>() => T;
  teamADifficulty: () => Promise<Int>;
  teamAScore: () => Promise<Int>;
  teamH: <T = HomeTeamFixturePromise>() => T;
  teamHDifficulty: () => Promise<Int>;
  teamHScore: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FixtureSubscription
  extends Promise<AsyncIterator<Fixture>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fplCode: () => Promise<AsyncIterator<Int>>;
  event: <T = GameweekSubscription>() => T;
  finished: () => Promise<AsyncIterator<Boolean>>;
  finishedProvisional: () => Promise<AsyncIterator<Boolean>>;
  fixtureId: () => Promise<AsyncIterator<Int>>;
  kickoffTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  minutes: () => Promise<AsyncIterator<Int>>;
  provisionalStartTime: () => Promise<AsyncIterator<Boolean>>;
  started: () => Promise<AsyncIterator<Boolean>>;
  teamA: <T = AwayTeamFixtureSubscription>() => T;
  teamADifficulty: () => Promise<AsyncIterator<Int>>;
  teamAScore: () => Promise<AsyncIterator<Int>>;
  teamH: <T = HomeTeamFixtureSubscription>() => T;
  teamHDifficulty: () => Promise<AsyncIterator<Int>>;
  teamHScore: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FixtureNullablePromise
  extends Promise<Fixture | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fplCode: () => Promise<Int>;
  event: <T = GameweekPromise>() => T;
  finished: () => Promise<Boolean>;
  finishedProvisional: () => Promise<Boolean>;
  fixtureId: () => Promise<Int>;
  kickoffTime: () => Promise<DateTimeOutput>;
  minutes: () => Promise<Int>;
  provisionalStartTime: () => Promise<Boolean>;
  started: () => Promise<Boolean>;
  teamA: <T = AwayTeamFixturePromise>() => T;
  teamADifficulty: () => Promise<Int>;
  teamAScore: () => Promise<Int>;
  teamH: <T = HomeTeamFixturePromise>() => T;
  teamHDifficulty: () => Promise<Int>;
  teamHScore: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GameweekConnection {
  pageInfo: PageInfo;
  edges: GameweekEdge[];
}

export interface GameweekConnectionPromise
  extends Promise<GameweekConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GameweekEdge>>() => T;
  aggregate: <T = AggregateGameweekPromise>() => T;
}

export interface GameweekConnectionSubscription
  extends Promise<AsyncIterator<GameweekConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GameweekEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGameweekSubscription>() => T;
}

export interface UserFollowersSubscriptionPayload {
  mutation: MutationType;
  node: UserFollowers;
  updatedFields: String[];
  previousValues: UserFollowersPreviousValues;
}

export interface UserFollowersSubscriptionPayloadPromise
  extends Promise<UserFollowersSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserFollowersPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserFollowersPreviousValuesPromise>() => T;
}

export interface UserFollowersSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserFollowersSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserFollowersSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserFollowersPreviousValuesSubscription>() => T;
}

export interface FandemSubscriptionEdge {
  node: FandemSubscription;
  cursor: String;
}

export interface FandemSubscriptionEdgePromise
  extends Promise<FandemSubscriptionEdge>,
    Fragmentable {
  node: <T = FandemSubscriptionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FandemSubscriptionEdgeSubscription
  extends Promise<AsyncIterator<FandemSubscriptionEdge>>,
    Fragmentable {
  node: <T = FandemSubscriptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserFollowersPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserFollowersPreviousValuesPromise
  extends Promise<UserFollowersPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserFollowersPreviousValuesSubscription
  extends Promise<AsyncIterator<UserFollowersPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserRoleConnection {
  pageInfo: PageInfo;
  edges: UserRoleEdge[];
}

export interface UserRoleConnectionPromise
  extends Promise<UserRoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserRoleEdge>>() => T;
  aggregate: <T = AggregateUserRolePromise>() => T;
}

export interface UserRoleConnectionSubscription
  extends Promise<AsyncIterator<UserRoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserRoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserRoleSubscription>() => T;
}

export interface Photo {
  id: ID_Output;
  image: String;
  largeImage?: String;
  smallImage?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PhotoPromise extends Promise<Photo>, Fragmentable {
  id: () => Promise<ID_Output>;
  image: () => Promise<String>;
  largeImage: () => Promise<String>;
  smallImage: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PhotoSubscription
  extends Promise<AsyncIterator<Photo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  image: () => Promise<AsyncIterator<String>>;
  largeImage: () => Promise<AsyncIterator<String>>;
  smallImage: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PhotoNullablePromise
  extends Promise<Photo | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  image: () => Promise<String>;
  largeImage: () => Promise<String>;
  smallImage: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserAssignedRole {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserAssignedRolePromise
  extends Promise<UserAssignedRole>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  userRole: <T = UserRolePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserAssignedRoleSubscription
  extends Promise<AsyncIterator<UserAssignedRole>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  userRole: <T = UserRoleSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserAssignedRoleNullablePromise
  extends Promise<UserAssignedRole | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  userRole: <T = UserRolePromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HomeTeamFixtureEdge {
  node: HomeTeamFixture;
  cursor: String;
}

export interface HomeTeamFixtureEdgePromise
  extends Promise<HomeTeamFixtureEdge>,
    Fragmentable {
  node: <T = HomeTeamFixturePromise>() => T;
  cursor: () => Promise<String>;
}

export interface HomeTeamFixtureEdgeSubscription
  extends Promise<AsyncIterator<HomeTeamFixtureEdge>>,
    Fragmentable {
  node: <T = HomeTeamFixtureSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserPhotoSubscriptionPayload {
  mutation: MutationType;
  node: UserPhoto;
  updatedFields: String[];
  previousValues: UserPhotoPreviousValues;
}

export interface UserPhotoSubscriptionPayloadPromise
  extends Promise<UserPhotoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPhotoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPhotoPreviousValuesPromise>() => T;
}

export interface UserPhotoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserPhotoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserPhotoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPhotoPreviousValuesSubscription>() => T;
}

export interface UserPhoto {
  id: ID_Output;
  isProfile?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPhotoPromise extends Promise<UserPhoto>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  photo: <T = PhotoPromise>() => T;
  isProfile: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPhotoSubscription
  extends Promise<AsyncIterator<UserPhoto>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  photo: <T = PhotoSubscription>() => T;
  isProfile: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserPhotoNullablePromise
  extends Promise<UserPhoto | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  photo: <T = PhotoPromise>() => T;
  isProfile: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserInfluencersPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserInfluencersPreviousValuesPromise
  extends Promise<UserInfluencersPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserInfluencersPreviousValuesSubscription
  extends Promise<AsyncIterator<UserInfluencersPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserInfluencersSubscriptionPayload {
  mutation: MutationType;
  node: UserInfluencers;
  updatedFields: String[];
  previousValues: UserInfluencersPreviousValues;
}

export interface UserInfluencersSubscriptionPayloadPromise
  extends Promise<UserInfluencersSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserInfluencersPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserInfluencersPreviousValuesPromise>() => T;
}

export interface UserInfluencersSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserInfluencersSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserInfluencersSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserInfluencersPreviousValuesSubscription>() => T;
}

export interface AggregateFixture {
  count: Int;
}

export interface AggregateFixturePromise
  extends Promise<AggregateFixture>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFixtureSubscription
  extends Promise<AsyncIterator<AggregateFixture>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserStatusSubscriptionPayload {
  mutation: MutationType;
  node: UserStatus;
  updatedFields: String[];
  previousValues: UserStatusPreviousValues;
}

export interface UserStatusSubscriptionPayloadPromise
  extends Promise<UserStatusSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserStatusPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserStatusPreviousValuesPromise>() => T;
}

export interface UserStatusSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserStatusSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserStatusSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserStatusPreviousValuesSubscription>() => T;
}

export interface AggregateUserFollowers {
  count: Int;
}

export interface AggregateUserFollowersPromise
  extends Promise<AggregateUserFollowers>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserFollowersSubscription
  extends Promise<AsyncIterator<AggregateUserFollowers>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserRolePreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserRolePreviousValuesPromise
  extends Promise<UserRolePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserRolePreviousValuesSubscription
  extends Promise<AsyncIterator<UserRolePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserPhoto",
    embedded: false
  },
  {
    name: "Photo",
    embedded: false
  },
  {
    name: "Status",
    embedded: false
  },
  {
    name: "UserStatus",
    embedded: false
  },
  {
    name: "Follower",
    embedded: false
  },
  {
    name: "UserFollowers",
    embedded: false
  },
  {
    name: "Influencer",
    embedded: false
  },
  {
    name: "UserInfluencers",
    embedded: false
  },
  {
    name: "UserRole",
    embedded: false
  },
  {
    name: "UserAssignedRole",
    embedded: false
  },
  {
    name: "ActiveSubscriptions",
    embedded: false
  },
  {
    name: "FandemSubscription",
    embedded: false
  },
  {
    name: "Country",
    embedded: false
  },
  {
    name: "Team",
    embedded: false
  },
  {
    name: "Season",
    embedded: false
  },
  {
    name: "Gameweek",
    embedded: false
  },
  {
    name: "HomeTeamFixture",
    embedded: false
  },
  {
    name: "AwayTeamFixture",
    embedded: false
  },
  {
    name: "Fixture",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
